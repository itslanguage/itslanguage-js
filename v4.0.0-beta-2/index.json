[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/WebAudio/AudioContext.js",
    "content": "import debug from 'debug';\n\n/**\n * Recorder\n * Simple Audio Recorder based on WebAudio technology\n */\nexport default class AudioContext {\n  /**\n   * Private object to hold AudioContext node.\n   * @type {AudioContext}\n   * @inherit\n   */\n  audioContext = null;\n\n  /**\n   * This will be the log function.\n   * Will output to stdout.\n   * @type {Function}\n   * @inherit\n   */\n  log = null;\n\n  /**\n   * This will be the error function.\n   * Will output to stderr.\n   * @type {Function}\n   * @inherit\n   */\n  error = null;\n\n  /**\n   * Keep a list of all registered event listeners.\n   * This way, we could conveniently remove all the listeners at once.\n   * @type {Array}\n   * @private\n   */\n  eventListeners = [];\n\n  /**\n   * Construct the Player.\n   *\n   * @param {Object} audioContext - Allow to provide custom/own audioContext object.\n   * @param {string} debugNameSpace - Name to be used for debugging.\n   */\n  constructor(audioContext = null, debugNameSpace = 'AudioContext') {\n    // Provide AudioContext object. If not passed the\n    // default window.AudioContext will be used.\n    if (audioContext) {\n      this.audioContext = audioContext;\n    } else {\n      this.audioContext = this.createAudioContext();\n    }\n\n    // Prepare the log and error function to be used!\n    this.log = debug(`its-sdk:${debugNameSpace}`);\n    this.error = debug(`its-sdk:${debugNameSpace}`);\n\n    // Bind log to stdout in stead of stderr\n    this.log.log = console.log.bind(console);\n\n    this.suspendAudioContext = this.suspendAudioContext.bind(this);\n  }\n\n  /**\n   * Wraps the addEventListener which is available on the AudioContext node.\n   * Note that it is requierd to pass a named function to actually be able\n   * to remove an event listeners. This is just how the EventTarget.removeEventListener\n   * works. There are no extra checks for.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/attachEvent\n   * @param {...*} args - Array with passed arguments.\n   */\n  addEventListener(...args) {\n    // First, add the event listener to our local list.\n    this.eventListeners.push(args);\n\n    // Now, actually add the event listener!\n    this.audioContext.addEventListener(...args);\n  }\n\n  /**\n   * Wraps the removeEventListener which is available on the AudioContext node.\n   * Make sure to call with the same arguments as the addEventListner.\n   *\n   * If you didn't call the addEventListener with a named function, please note\n   * that you won't be able to remove the eventListener.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener\n   * @param {...*} args - Array with passed arguments.\n   */\n  removeEventListener(...args) {\n    // First, try to find the event in our list.\n    const itemIndex = this.eventListeners.findIndex(item => {\n      // If the count of items doesn't equal, it's definitely not the\n      // listener we want to remove.\n      if (item.length !== args.length) {\n        return false;\n      }\n\n      // Now we're gonna loop through the items to check if we can\n      // find an item which does not compare equal. If we find one\n      // 'some' will immediately return true and the party is over!\n      // Wubba lubba dub dub!\n      return !args.some((arg, index) => item[index] !== arg);\n    });\n\n    // Remove that item, and only that one, from the list\n    if (itemIndex) {\n      this.eventListeners.splice(itemIndex, 1);\n    }\n\n    // Remove the event handler!\n    this.audioContext.removeEventListener(...args);\n  }\n\n  removeAllEventListeners() {\n    this.eventListeners.forEach(listener => {\n      this.removeEventListener(...listener);\n    });\n    this.eventListeners = [];\n  }\n\n  /**\n   * Use this method to conveniently fire an event.\n   * We could, if we wanted, add some data.\n   *\n   * @param {string} eventName - Event to fire.\n   * @param {Object} data - Data to pass as detail.\n   * @inherit\n   */\n  fireEvent(eventName, data = null) {\n    if (!eventName) {\n      return;\n    }\n    const customEvent = new CustomEvent(eventName, {detail: data});\n    this.audioContext.dispatchEvent(customEvent);\n  }\n\n  /**\n   * Get the audio context or create one.\n   *\n   * @return {AudioContext} The AudioContext created will be returned\n   */\n  createAudioContext() {\n    if (!window.ItslAudioContext) {\n      window.AudioContext =\n        window.AudioContext || window.webkitAudioContext;\n      window.ItslAudioContext = new window.AudioContext();\n    }\n    return window.ItslAudioContext;\n  }\n\n  /**\n   * Suspend the AudioContext to preserve power and such.\n   */\n  suspendAudioContext() {\n    this.audioContext.suspend();\n  }\n\n  /**\n   * Resume a suspended AudioContext.\n   */\n  resumeAudioContext() {\n    if (this.audioContext.state === 'suspended') {\n      this.audioContext.resume();\n    }\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/WebAudio/AudioContext.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "AudioContext",
    "memberof": "src/WebAudio/AudioContext.js",
    "static": true,
    "longname": "src/WebAudio/AudioContext.js~AudioContext",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/WebAudio/AudioContext.js",
    "importStyle": "AudioContext",
    "description": "Recorder\nSimple Audio Recorder based on WebAudio technology",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "member",
    "name": "audioContext",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#audioContext",
    "access": "public",
    "description": "Private object to hold AudioContext node.",
    "lineNumber": 13,
    "unknown": [
      {
        "tagName": "@inherit",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "AudioContext"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "log",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#log",
    "access": "public",
    "description": "This will be the log function.\nWill output to stdout.",
    "lineNumber": 21,
    "unknown": [
      {
        "tagName": "@inherit",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "Function"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "error",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#error",
    "access": "public",
    "description": "This will be the error function.\nWill output to stderr.",
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@inherit",
        "tagValue": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "Function"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "eventListeners",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#eventListeners",
    "access": "private",
    "description": "Keep a list of all registered event listeners.\nThis way, we could conveniently remove all the listeners at once.",
    "lineNumber": 37,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 54,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#constructor",
    "access": "public",
    "description": "Construct the Player.",
    "lineNumber": 45,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "audioContext",
        "description": "Allow to provide custom/own audioContext object."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "debugNameSpace",
        "description": "Name to be used for debugging."
      }
    ]
  },
  {
    "__docId__": 60,
    "kind": "method",
    "name": "addEventListener",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#addEventListener",
    "access": "public",
    "description": "Wraps the addEventListener which is available on the AudioContext node.\nNote that it is requierd to pass a named function to actually be able\nto remove an event listeners. This is just how the EventTarget.removeEventListener\nworks. There are no extra checks for.",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/attachEvent"
    ],
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "...*"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Array with passed arguments."
      }
    ],
    "return": null
  },
  {
    "__docId__": 61,
    "kind": "method",
    "name": "removeEventListener",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#removeEventListener",
    "access": "public",
    "description": "Wraps the removeEventListener which is available on the AudioContext node.\nMake sure to call with the same arguments as the addEventListner.\n\nIf you didn't call the addEventListener with a named function, please note\nthat you won't be able to remove the eventListener.",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener"
    ],
    "lineNumber": 91,
    "params": [
      {
        "nullable": null,
        "types": [
          "...*"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Array with passed arguments."
      }
    ],
    "return": null
  },
  {
    "__docId__": 62,
    "kind": "method",
    "name": "removeAllEventListeners",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#removeAllEventListeners",
    "access": "public",
    "description": null,
    "lineNumber": 116,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 64,
    "kind": "method",
    "name": "fireEvent",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#fireEvent",
    "access": "public",
    "description": "Use this method to conveniently fire an event.\nWe could, if we wanted, add some data.",
    "lineNumber": 131,
    "unknown": [
      {
        "tagName": "@inherit",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "eventName",
        "description": "Event to fire."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Data to pass as detail."
      }
    ],
    "return": null
  },
  {
    "__docId__": 65,
    "kind": "method",
    "name": "createAudioContext",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#createAudioContext",
    "access": "public",
    "description": "Get the audio context or create one.",
    "lineNumber": 144,
    "return": {
      "nullable": null,
      "types": [
        "AudioContext"
      ],
      "spread": false,
      "description": "The AudioContext created will be returned"
    },
    "params": []
  },
  {
    "__docId__": 66,
    "kind": "method",
    "name": "suspendAudioContext",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#suspendAudioContext",
    "access": "public",
    "description": "Suspend the AudioContext to preserve power and such.",
    "lineNumber": 156,
    "params": [],
    "return": null
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "resumeAudioContext",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#resumeAudioContext",
    "access": "public",
    "description": "Resume a suspended AudioContext.",
    "lineNumber": 163,
    "params": [],
    "return": null
  },
  {
    "__docId__": 68,
    "kind": "file",
    "name": "src/WebAudio/Player.js",
    "content": "import {authorisedRequest, request} from '../api/communication';\nimport AudioContext from './AudioContext';\n\n/**\n * Player\n * Simple Audio Player based on Web Audio API technology\n */\nexport default class Player extends AudioContext {\n  /**\n   * Private object to hold AudioBuffer node.\n   * @private\n   */\n  audioBuffer = null;\n\n  /**\n   * Private object to hold AudioBufferSourceNode node.\n   * @private\n   */\n  audioSource = null;\n\n  createBufferSource() {\n    this.disconnectBufferSource();\n\n    // Create a sound source\n    this.audioSource = this.audioContext.createBufferSource();\n\n    // Select what to play\n    this.audioSource.buffer = this.audioBuffer;\n\n    // Connect to the speakers!\n    this.audioSource.connect(this.audioContext.destination);\n\n    // Add some event handlers;\n    this.audioSource.addEventListener('ended', this.suspendAudioContext);\n  }\n\n  disconnectBufferSource() {\n    if (this.audioSourceExists()) {\n      this.audioSource.disconnect();\n      this.audioSource.removeEventListener('ended', this.suspendAudioContext);\n    }\n  }\n\n  /**\n   * Get an audio stream from an URL.\n   *\n   * If the withItslToken is provided (and set to true) use the authorizedRequest method to load\n   * the audio. This in effect will set the ITSLanguage bearer token (if available) to the request.\n   *\n   * For both request methods goes: there's no check whether you're trying to load from ITSLanguage\n   * backend system or not.\n   *\n   * @param {string} url - Url to load.\n   * @param {boolean} withItslToken - Make use of authorizedRequest or just request if set to false.\n   */\n  async load(url, withItslToken = true) {\n    if (!url) {\n      return;\n    }\n\n    // Determine whether to ask authorized, or not.\n    const requestMethod = withItslToken ? authorisedRequest : request;\n    const {audioContext} = this;\n\n    try {\n      const response = await requestMethod('GET', url);\n      const audioData = await response.arrayBuffer();\n      audioContext.decodeAudioData(audioData, decodedAudio => {\n        this.audioBuffer = decodedAudio;\n        this.fireEvent('loaded');\n      });\n    } catch (error) {\n      this.error(`${error.name}: ${error.message}`);\n    }\n  }\n\n  /**\n   * Returns if the audioBuffer has been created and loaded, or not.\n\n   * @returns {boolean} The audioBuffer created.\n   */\n  audioBufferExists() {\n    return Boolean(this.audioBuffer);\n  }\n\n  /**\n   * Return if audioSource has been created, or not.\n   *\n   * @returns {boolean} The audioSource created.\n   */\n  audioSourceExists() {\n    return Boolean(this.audioSource);\n  }\n\n  /**\n   * Start audio playback of that what is in the buffer.\n   */\n  play() {\n    this.createBufferSource();\n\n    if (this.audioContext.state === 'suspended') {\n      this.audioContext.resume();\n    }\n\n    // play the source now\n    this.audioSource.start();\n    this.fireEvent('playing');\n  }\n\n  /**\n   * Stop playback of audio.\n   * Check for buffer and source to exist, if not, exit.\n   */\n  stop() {\n    if (!this.audioBufferExists() && !this.audioSourceExists()) {\n      return;\n    }\n\n    this.audioSource.stop();\n    this.fireEvent('stopped');\n  }\n\n  pause() {\n    if (!this.audioBufferExists() && !this.audioSourceExists()) {\n      return;\n    }\n\n    this.audioSource.stop();\n    this.fireEvent('pause');\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/WebAudio/Player.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 69,
    "kind": "class",
    "name": "Player",
    "memberof": "src/WebAudio/Player.js",
    "static": true,
    "longname": "src/WebAudio/Player.js~Player",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/WebAudio/Player.js",
    "importStyle": "Player",
    "description": "Player\nSimple Audio Player based on Web Audio API technology",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "src/WebAudio/AudioContext.js~AudioContext"
    ]
  },
  {
    "__docId__": 70,
    "kind": "member",
    "name": "audioBuffer",
    "memberof": "src/WebAudio/Player.js~Player",
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#audioBuffer",
    "access": "private",
    "description": "Private object to hold AudioBuffer node.",
    "lineNumber": 13,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 71,
    "kind": "member",
    "name": "audioSource",
    "memberof": "src/WebAudio/Player.js~Player",
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#audioSource",
    "access": "private",
    "description": "Private object to hold AudioBufferSourceNode node.",
    "lineNumber": 19,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "method",
    "name": "createBufferSource",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#createBufferSource",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 74,
    "kind": "method",
    "name": "disconnectBufferSource",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#disconnectBufferSource",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 75,
    "kind": "method",
    "name": "load",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#load",
    "access": "public",
    "description": "Get an audio stream from an URL.\n\nIf the withItslToken is provided (and set to true) use the authorizedRequest method to load\nthe audio. This in effect will set the ITSLanguage bearer token (if available) to the request.\n\nFor both request methods goes: there's no check whether you're trying to load from ITSLanguage\nbackend system or not.",
    "lineNumber": 56,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "Url to load."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "withItslToken",
        "description": "Make use of authorizedRequest or just request if set to false."
      }
    ],
    "return": null
  },
  {
    "__docId__": 77,
    "kind": "method",
    "name": "audioBufferExists",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#audioBufferExists",
    "access": "public",
    "description": "Returns if the audioBuffer has been created and loaded, or not.",
    "lineNumber": 82,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} The audioBuffer created."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "The audioBuffer created."
    },
    "params": []
  },
  {
    "__docId__": 78,
    "kind": "method",
    "name": "audioSourceExists",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#audioSourceExists",
    "access": "public",
    "description": "Return if audioSource has been created, or not.",
    "lineNumber": 91,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} The audioSource created."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "The audioSource created."
    },
    "params": []
  },
  {
    "__docId__": 79,
    "kind": "method",
    "name": "play",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#play",
    "access": "public",
    "description": "Start audio playback of that what is in the buffer.",
    "lineNumber": 98,
    "params": [],
    "return": null
  },
  {
    "__docId__": 80,
    "kind": "method",
    "name": "stop",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#stop",
    "access": "public",
    "description": "Stop playback of audio.\nCheck for buffer and source to exist, if not, exit.",
    "lineNumber": 114,
    "params": [],
    "return": null
  },
  {
    "__docId__": 81,
    "kind": "method",
    "name": "pause",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#pause",
    "access": "public",
    "description": null,
    "lineNumber": 123,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 82,
    "kind": "file",
    "name": "src/WebAudio/Recorder.js",
    "content": "import AudioContext from './AudioContext';\n\nconst DEFAULT_AUDIO_FORMAT = 'audio/wave';\nconst DEFAULT_CHANNELS = 1;\nconst DEFAULT_SAMPLE_WIDTH = 16;\nconst DEFAULT_SAMPLE_RATE = 48000;\n\n/**\n * Recorder\n * Simple Audio Recorder based on Web Audio API technology.\n *\n * This audio recorder tries to capture audio in WAV format\n * with some defaults that should work best.\n *\n * If this does not supply in your case, build your own recorder!\n */\nexport default class Recorder extends AudioContext {\n  /** @private */\n  audioFormat = null;\n  /** @private */\n  channels = null;\n  /** @private */\n  sampleRate = null;\n  /** @private */\n  sampleWidth = null;\n\n  /** @private */\n  stream = null;\n  mediaStreamSource = null;\n\n  constructor(options = {}) {\n    super();\n\n    const {\n      audioFormat = DEFAULT_AUDIO_FORMAT,\n      channels = DEFAULT_CHANNELS,\n      sampleRate = DEFAULT_SAMPLE_RATE,\n      sampleWidth = DEFAULT_SAMPLE_WIDTH\n    } = options;\n\n    this.audioFormat = audioFormat;\n    this.channels = channels;\n    this.sampleRate = sampleRate;\n    this.sampleWidth = sampleWidth;\n  }\n\n  async createStream() {\n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia({audio: true});\n      this.fireEvent('ready');\n    } catch ({name, message}) {\n      this.error(`${name}: ${message}`);\n    }\n  }\n\n  async startRecording() {\n    if (!this.stream) {\n      await this.createStream();\n    }\n    this.mediaStreamSource = this.audioContext.createMediaStreamSource(this.stream);\n    this.mediaStreamSource.connect(this.audioContext.destination);\n    this.fireEvent('recording');\n  }\n\n  stopRecording() {\n    this.mediaStreamSource.disconnect();\n    this.stream.getAudioTracks().forEach(track => {\n      track.stop();\n    });\n    this.suspendAudioContext();\n    this.fireEvent('recorded');\n  }\n\n  getAudioSpecs() {\n    return {\n      audioFormat: this.audioFormat,\n      audioParameters: {\n        channels: this.channels,\n        frameRate: this.sampleRate,\n        sampleWidth: this.sampleWidth\n      }\n    };\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/WebAudio/Recorder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 83,
    "kind": "variable",
    "name": "DEFAULT_AUDIO_FORMAT",
    "memberof": "src/WebAudio/Recorder.js",
    "static": true,
    "longname": "src/WebAudio/Recorder.js~DEFAULT_AUDIO_FORMAT",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/WebAudio/Recorder.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 84,
    "kind": "variable",
    "name": "DEFAULT_CHANNELS",
    "memberof": "src/WebAudio/Recorder.js",
    "static": true,
    "longname": "src/WebAudio/Recorder.js~DEFAULT_CHANNELS",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/WebAudio/Recorder.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 85,
    "kind": "variable",
    "name": "DEFAULT_SAMPLE_WIDTH",
    "memberof": "src/WebAudio/Recorder.js",
    "static": true,
    "longname": "src/WebAudio/Recorder.js~DEFAULT_SAMPLE_WIDTH",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/WebAudio/Recorder.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 86,
    "kind": "variable",
    "name": "DEFAULT_SAMPLE_RATE",
    "memberof": "src/WebAudio/Recorder.js",
    "static": true,
    "longname": "src/WebAudio/Recorder.js~DEFAULT_SAMPLE_RATE",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/WebAudio/Recorder.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 87,
    "kind": "class",
    "name": "Recorder",
    "memberof": "src/WebAudio/Recorder.js",
    "static": true,
    "longname": "src/WebAudio/Recorder.js~Recorder",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/WebAudio/Recorder.js",
    "importStyle": "Recorder",
    "description": "Recorder\nSimple Audio Recorder based on Web Audio API technology.\n\nThis audio recorder tries to capture audio in WAV format\nwith some defaults that should work best.\n\nIf this does not supply in your case, build your own recorder!",
    "lineNumber": 17,
    "interface": false,
    "extends": [
      "src/WebAudio/AudioContext.js~AudioContext"
    ]
  },
  {
    "__docId__": 88,
    "kind": "member",
    "name": "audioFormat",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#audioFormat",
    "access": "private",
    "description": null,
    "lineNumber": 19,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "member",
    "name": "channels",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#channels",
    "access": "private",
    "description": null,
    "lineNumber": 21,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 90,
    "kind": "member",
    "name": "sampleRate",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#sampleRate",
    "access": "private",
    "description": null,
    "lineNumber": 23,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 91,
    "kind": "member",
    "name": "sampleWidth",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#sampleWidth",
    "access": "private",
    "description": null,
    "lineNumber": 25,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "member",
    "name": "stream",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#stream",
    "access": "private",
    "description": null,
    "lineNumber": 28,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 93,
    "kind": "member",
    "name": "mediaStreamSource",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#mediaStreamSource",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true
  },
  {
    "__docId__": 99,
    "kind": "method",
    "name": "createStream",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#createStream",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 101,
    "kind": "method",
    "name": "startRecording",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#startRecording",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 103,
    "kind": "method",
    "name": "stopRecording",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#stopRecording",
    "access": "public",
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 104,
    "kind": "method",
    "name": "getAudioSpecs",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#getAudioSpecs",
    "access": "public",
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "{\"audioFormat\": *, \"audioParameters\": *}"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "file",
    "name": "src/administrative-sdk/administrative-sdk.js",
    "content": "import CategoryController from './category/category-controller';\nimport ChoiceChallengeController from './choice-challenge/choice-challenge-controller';\nimport ChoiceRecognitionController from './choice-recognition/choice-recognition-controller';\nimport EmailCredentialsController from './email-credentials/email-credentials-controller';\nimport GroupController from './group/group-controller';\nimport OrganisationController from './organisation/organisation-controller';\nimport ProfileController from './profile/profile-controller';\nimport ProgressController from './progress/progress-controller';\nimport PronAnalaController from './pronunciation-analysis/pronunciation-analysis-controller';\nimport PronChallController from './pronunciation-challenge/pronunciation-challenge-controller';\nimport RoleController from './role/role-controller';\nimport SpeechChallengeController from './speech-challenge/speech-challenge-controller';\nimport SpeechRecordingController from './speech-recording/speech-recording-controller';\nimport UserController from './user/user-controller';\n\n/**\n * Facade for all methods used in the ITSLanguage Administrative SDK.\n */\nexport default class AdministrativeSDK {\n  /**\n   * @param {Connection} connection - Object to use for making a connection to the REST API and Websocket server.\n   */\n  constructor(connection) {\n    this._connection = connection;\n    this._categoryController = new CategoryController(this._connection);\n    this._choiceChallengeController = new ChoiceChallengeController(this._connection);\n    this._choiceRecognitionController = new ChoiceRecognitionController(this._connection);\n    this._emailCredentialsController = new EmailCredentialsController(this._connection);\n    this._groupController = new GroupController(this._connection);\n    this._organisationController = new OrganisationController(this._connection);\n    this._profileController = new ProfileController(this._connection);\n    this._progressController = new ProgressController(this._connection);\n    this._pronAnalaController = new PronAnalaController(this._connection);\n    this._pronChallController = new PronChallController(this._connection);\n    this._roleController = new RoleController(this._connection);\n    this._speechChallengeController = new SpeechChallengeController(this._connection);\n    this._speechRecordingController = new SpeechRecordingController(this._connection);\n    this._userController = new UserController(this._connection);\n  }\n\n  /**\n   * Create a category.\n   *\n   * @param {Category} category - Object to create.\n   * @returns {Promise.<Category>} Promise containing the newly created Category.\n   * @throws {Promise.<Error>} category parameter of type \"Category\" is required.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  createCategory(category) {\n    return this._categoryController.createCategory(category);\n  }\n\n  /**\n   * Get a category.\n   *\n   * @param {string} categoryId - Specify a category identifier.\n   * @returns {Promise.<Category>} Promise containing an Category.\n   * @throws {Promise.<Error>} categoryId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getCategory(categoryId) {\n    return this._categoryController.getCategory(categoryId);\n  }\n\n  /**\n   * Get and return all top level categories which do not have a parent Category.\n   *\n   * @param {string} [groupId] - The ID of the group for which to fetch all top level categories.\n   * @returns {Promise.<Category[]>} Promise containing an array of Categories.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getTopLevelCategories(groupId) {\n    return this._categoryController.getTopLevelCategories(groupId);\n  }\n\n  /**\n   * Get and return all categories which have a specific category as parent.\n   *\n   * @param {string} parentId - Specify a category parent identifier.\n   * @returns {Promise.<Category[]>} Promise containing an array of Categories.\n   * @throws {Promise.<Error>} parentId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getCategoriesWithParent(parentId) {\n    return this._categoryController.getCategoriesWithParent(parentId);\n  }\n\n  /**\n   * Create a choice challenge. The choice challenge will be created in the current active {@link Organisation} derived\n   * from the OAuth2 scope.\n   * It is necessary for a choice challenge to exist for a recording to be valid.\n   *\n   * @param {ChoiceChallenge} choiceChallenge - Object to create.\n   * @returns {Promise.<ChoiceChallenge>} Containing the newly created ChoiceChallenge.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  createChoiceChallenge(choiceChallenge) {\n    return this._choiceChallengeController.createChoiceChallenge(choiceChallenge);\n  }\n\n  /**\n   * Get a choice challenge. A choice challenge is identified by its identifier and the current active\n   * {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {string} challengeId - Specify a choice challenge identifier.\n   * @returns {Promise.<ChoiceChallenge>} Containing a ChoiceChallenge.\n   * @throws {Promise.<Error>} {@link ChoiceChallenge#id} field is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getChoiceChallenge(challengeId) {\n    return this._choiceChallengeController.getChoiceChallenge(challengeId);\n  }\n\n  /**\n   * Get and return all choice challenges in the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @returns {Promise.<ChoiceChallenge[]>} Containing an array of ChoiceChallenges.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getChoiceChallenges() {\n    return this._choiceChallengeController.getChoiceChallenges();\n  }\n\n  /**\n   * Start a choice recognition from streaming audio.\n   *\n   * @param {ChoiceChallenge} challenge - The choice challenge to perform.\n   * @param {AudioRecorder} recorder - The audio recorder to extract audio from.\n   * @param {boolean} [trim=true] - Whether to trim the start and end of recorded audio.\n   * @returns {Promise.<ChoiceRecognition>} A {@link https://github.com/cujojs/when} Promise containing a {@link ChoiceRecognition}.\n   * @emits {string} 'ReadyToReceive' when the call is made to receive audio. The recorder can now send audio.\n   * @throws {Promise.<Error>} {@link ChoiceChallenge} parameter is required or invalid.\n   * @throws {Promise.<Error>} {@link ChoiceChallenge#id} field is required.\n   * @throws {Promise.<Error>} If the connection is not open.\n   * @throws {Promise.<Error>} If the recorder is already recording.\n   * @throws {Promise.<Error>} If a recognition session is already in progress.\n   * @throws {Promise.<Error>} If something went wrong during analysis.\n   */\n  startStreamingChoiceRecognition(challenge, recorder, trim) {\n    return this._choiceRecognitionController.startStreamingChoiceRecognition(challenge, recorder, trim);\n  }\n\n  /**\n   * Get a choice recognition in a choice challenge from the current active {@link Organisation} derived from\n   * the OAuth2 scope.\n   *\n   * @param {string} challengeId - Specify a choice challenge identifier.\n   * @param {string} recognitionId - Specify a choice recognition identifier.\n   * @returns {Promise.<ChoiceRecognition>} Promise containing a ChoiceRecognition.\n   * @throws {Promise.<Error>} {@link ChoiceChallenge#id} field is required.\n   * @throws {Promise.<Error>} {@link ChoiceRecognition#id} field is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getChoiceRecognition(challengeId, recognitionId) {\n    return this._choiceRecognitionController.getChoiceRecognition(challengeId, recognitionId);\n  }\n\n  /**\n   * Get and return all choice recognitions in a specific {@link ChoiceChallenge} from the current active\n   * {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {string} challengeId - Specify a choice challenge to list speech recognitions for.\n   * @returns {Promise.<ChoiceRecognition[]>} Promise containing an array of ChoiceRecognitions.\n   * @throws {Promise.<Error>} {@link ChoiceChallenge#id} is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getChoiceRecognitions(challengeId) {\n    return this._choiceRecognitionController.getChoiceRecognitions(challengeId);\n  }\n\n  /**\n   * Create an organisation. The organisation will be owned by the current active tenant.\n   *\n   * @param {Organisation} organisation - Object to create.\n   * @returns {Promise.<Organisation>} Promise containing the newly created Organisation.\n   * @throws {Promise.<Error>} organisation field of type \"Organisation\" is required.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  createOrganisation(organisation) {\n    return this._organisationController.createOrganisation(organisation);\n  }\n\n  /**\n   * Get an organisation. You can only get an organisation the current tenant is the owner of.\n   *\n   * @param {string} organisationId - Specify an organisation identifier.\n   * @returns {Promise.<Organisation>} Promise containing an Organisation.\n   * @throws {Promise.<Error>} {@link Organisation#id} field of type \"string\" is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getOrganisation(organisationId) {\n    return this._organisationController.getOrganisation(organisationId);\n  }\n\n  /**\n   * Get and return all organisations the current tenant is the owner of.\n   *\n   * @returns {Promise.<Organisation[]>} Promise containing an array of Organisations.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getOrganisations() {\n    return this._organisationController.getOrganisations();\n  }\n\n  /**\n   * Start a pronunciation analysis from streaming audio.\n   *\n   * @param {PronunciationChallenge} challenge - The pronunciation challenge to perform.\n   * @param {AudioRecorder} recorder - The audio recorder to extract audio from.\n   * @param {boolean} [trim] - Whether to trim the start and end of recorded audio (default: true).\n   * @returns {Promise.<PronunciationAnalysis>} A {@link https://github.com/cujojs/when} Promise containing a {@link PronunciationAnalysis}.\n   * @emits {string} 'ReadyToReceive' when the call is made to receive audio. The recorder can now send audio.\n   * @emits {Object} When the sent audio has finished alignment. Aligning audio is the process of mapping the audio\n   * to spoken words and determining when what is said. An object is sent containing a property 'progress',\n   * which is the sent audio alignment, and a property 'referenceAlignment' which is the alignment of the\n   * reference audio.\n   * @throws {Promise.<Error>} If challenge is not an object or not defined.\n   * @throws {Promise.<Error>} If challenge has no id.\n   * @throws {Promise.<Error>} If the connection is not open.\n   * @throws {Promise.<Error>} If the recorder is already recording.\n   * @throws {Promise.<Error>} If a session is already in progress.\n   * @throws {Promise.<Error>} If something went wrong during analysis.\n   */\n  startStreamingPronunciationAnalysis(challenge, recorder, trim) {\n    return this._pronAnalaController.startStreamingPronunciationAnalysis(challenge, recorder, trim);\n  }\n\n  /**\n   * Get a pronunciation analysis in a pronunciation challenge from the current active {@link Organisation} derived\n   * from the OAuth2 scope.\n   *\n   * @param {string} challengeId - Specify a pronunciation challenge identifier.\n   * @param {string} analysisId - Specify a pronunciation analysis identifier.\n   * @returns {Promise.<PronunciationAnalysis>} Promise containing a PronunciationAnalysis.\n   * @throws {Promise.<Error>} {@link PronunciationChallenge#id} field is required.\n   * @throws {Promise.<Error>} {@link PronunciationAnalysis#id} field is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getPronunciationAnalysis(challengeId, analysisId) {\n    return this._pronAnalaController.getPronunciationAnalysis(challengeId, analysisId);\n  }\n\n  /**\n   * Get and return all pronunciation analyses in a specific pronunciation challenge from the current active\n   * {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {string} challengeId - Specify a pronunciation challenge identifier to list\n   * speech recordings for.\n   * @param {boolean} [detailed=false] - Returns extra analysis metadata when true.\n   * @returns {Promise.<PronunciationAnalysis[]>} Promise containing an array PronunciationAnalyses.\n   * @throws {Promise.<Error>} {@link PronunciationChallenge#id} field is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getPronunciationAnalyses(challengeId, detailed) {\n    return this._pronAnalaController.getPronunciationAnalyses(challengeId, detailed);\n  }\n\n  /**\n   * Create a pronunciation challenge. The created challenge will be part of the current active {@link Organisation}\n   * derived from the OAuth2 scope.\n   *\n   * @param {PronunciationChallenge} challenge - Object to create..\n   * @returns {Promise.<PronunciationChallenge>} Promise containing the newly created PronunciationChallenge.\n   * @throws {Promise.<Error>} {@link PronunciationChallenge#referenceAudio} of type \"Blob\" is required.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  createPronunciationChallenge(challenge) {\n    return this._pronChallController.createPronunciationChallenge(challenge);\n  }\n\n  /**\n   * Get a pronunciation challenge from the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {string} challengeId - Specify a pronunciation challenge identifier.\n   * @returns {Promise.<PronunciationChallenge>} Promise containing a PronunciationChallenge.\n   * @throws {Promise.<Error>} {@link PronunciationChallenge#id} field is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getPronunciationChallenge(challengeId) {\n    return this._pronChallController.getPronunciationChallenge(challengeId);\n  }\n\n  /**\n   * Get and return all pronunciation challenges in the current active {@link Organisation} derived from\n   * the OAuth2 scope.\n   *\n   * @returns {Promise.<PronunciationChallenge[]>} Promise containing an array of PronunciationChallenges.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getPronunciationChallenges() {\n    return this._pronChallController.getPronunciationChallenges();\n  }\n\n  /**\n   * Delete a pronunciation challenge from the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {string} challengeId - A pronunciation challenge identifier.\n   * @returns {Promise.<PronunciationChallenge>} Promise containing the given challenge ID.\n   * @throws {Promise.<Error>} {@link PronunciationChallenge#id} field is required.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  deletePronunciationChallenge(challengeId) {\n    return this._pronChallController.deletePronunciationChallenge(challengeId);\n  }\n\n  /**\n   * Create a speech challenge in the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {SpeechChallenge} speechChallenge - Object to create.\n   * @param {?Blob} audioBlob - Audio fragment to link to the challenge.\n   * @returns {Promise.<PronunciationChallenge>} Promise containing the newly created SpeechChallenge.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  createSpeechChallenge(speechChallenge, audioBlob) {\n    return this._speechChallengeController.createSpeechChallenge(speechChallenge, audioBlob);\n  }\n\n  /**\n   * Get a speech challenge from the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {string} challengeId - Specify a speech challenge identifier.\n   * @returns {Promise.<PronunciationChallenge>} Promise containing a SpeechChallenge.\n   * @throws {Promise.<Error>} {@link SpeechChallenge#id} field is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getSpeechChallenge(challengeId) {\n    return this._speechChallengeController.getSpeechChallenge(challengeId);\n  }\n\n  /**\n   * Get and return all speech challenges in the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @returns {Promise.<SpeechChallenge[]>} Promise containing an array of SpeechChallenges.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getSpeechChallenges() {\n    return this._speechChallengeController.getSpeechChallenges();\n  }\n\n  /**\n   * Start a speech recording from streaming audio.\n   *\n   * @param {SpeechChallenge} challenge - The speech challenge to perform.\n   * @param {AudioRecorder} recorder - The audio recorder to extract audio from.\n   * @returns {Promise.<SpeechRecording>} A {@link https://github.com/cujojs/when} Promise containing a {@link SpeechRecording}.\n   * @emits {string} 'ReadyToReceive' when the call is made to receive audio. The recorder can now send audio.\n   * @throws {Promise.<Error>} If challenge is not an object or not defined.\n   * @throws {Promise.<Error>} If challenge has no id.\n   * @throws {Promise.<Error>} If the connection is not open.\n   * @throws {Promise.<Error>} If the recorder is already recording.\n   * @throws {Promise.<Error>} If a session is already in progress.\n   * @throws {Promise.<Error>} If something went wrong during recording.\n   */\n  startStreamingSpeechRecording(challenge, recorder) {\n    return this._speechRecordingController.startStreamingSpeechRecording(challenge, recorder);\n  }\n\n  /**\n   * Get a speech recording in a speech challenge from the current active {@link Organisation} derived from the OAuth2\n   * scope.\n   *\n   * @param {string} challengeId - Specify a speech challenge identifier.\n   * @param {string} recordingId - Specify a speech recording identifier.\n   * @returns {Promise.<SpeechRecording>} Promise containing a SpeechRecording.\n   * @throws {Promise.<Error>} {@link SpeechChallenge#id} field is required.\n   * @throws {Promise.<Error>} {@link SpeechRecording#id} field is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getSpeechRecording(challengeId, recordingId) {\n    return this._speechRecordingController.getSpeechRecording(challengeId, recordingId);\n  }\n\n  /**\n   * Get and return all speech recordings in a specific speech challenge from the current active {@link Organisation}\n   * derived from the OAuth2 scope.\n   *\n   * @param {string} challengeId - Specify a speech challenge identifier to list speech recordings for.\n   * @returns {Promise.<SpeechRecording[]>} Promise containing an array of SpeechRecordings.\n   * @throws {Promise.<Error>} {@link SpeechChallenge#id} is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getSpeechRecordings(challengeId) {\n    return this._speechRecordingController.getSpeechRecordings(challengeId);\n  }\n\n  /**\n   * Create a user. The user will be created in the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {User} user - User to create.\n   * @returns {Promise.<User>} Promise containing the newly created User.\n   * @throws {Promise.<Error>} user parameter of type \"User\" is required.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  createUser(user) {\n    return this._userController.createUser(user);\n  }\n\n  /**\n   * Get a user in the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {string} userId - Specify a user identifier.\n   * @returns {Promise.<User>} Promise containing a User.\n   * @throws {Promise.<Error>} userId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getUser(userId) {\n    return this._userController.getUser(userId);\n  }\n\n  /**\n   * Get the current authenticated user.\n   *\n   * @returns {Promise.<User>} The current authenticated user.\n   * @throws {Promise.<Error>} If something went wrong in the server.\n   */\n  getCurrentUser() {\n    return this._userController.getCurrentUser();\n  }\n\n  /**\n   * Get and return all users in the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @returns {Promise.<User[]>} Promise containing an array of Users.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getUsers() {\n    return this._userController.getUsers();\n  }\n\n  /**\n   * Register credentials to the given user. Multiple credentials can be registered to one user.\n   *\n   * @param {string} userId - The identifier of the user to register credentials to.\n   * @param {EmailCredentials} emailCredentials - The credentials to register to the user.\n   * @returns {Promise.<EmailCredentials>} A promise containing the created EmailCredentials.\n   * @throws {Promise.<Error>} UserId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} EmailCredentials parameter of type \"EmailCredentials\" is required.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  createEmailCredentials(userId, emailCredentials) {\n    return this._emailCredentialsController.createEmailCredentials(userId, emailCredentials);\n  }\n\n  /**\n   * Get and return all roles available in the API.\n   *\n   * @returns {Promise.<Role[]>} Promise containing an array of Roles.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  getRoles() {\n    return this._roleController.getRoles();\n  }\n\n  /**\n   * Get a single role.\n   *\n   * @param {string} roleId - Identifier of the role.\n   * @returns {Promise.<Role>} Promise containing a Role.\n   * @throws {Promise.<Error>} roleId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getRole(roleId) {\n    return this._roleController.getRole(roleId);\n  }\n\n  /**\n   * Get the profile of the given user active in the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {string} userId - Specify a User identifier.\n   * @returns {Promise.<Profile>} Promise containing a Profile.\n   * @throws {Promise.<Error>} userId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getProfile(userId) {\n    return this._profileController.getProfile(userId);\n  }\n\n  /**\n   * Get and return all profiles of all users in the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @returns {Promise.<Profile[]>} Array of Profiles.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  getProfiles() {\n    return this._profileController.getProfiles();\n  }\n\n  /**\n   * Create a group. The group will be part of the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {Organisation} group - Object to create.\n   * @returns {Promise.<Group>} Promise containing the newly created Group.\n   * @throws {Promise.<Error>} organisation parameter of type \"Group\" is required.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  createGroup(group) {\n    return this._groupController.createGroup(group);\n  }\n\n  /**\n   * Get a group which is part of the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {string} groupId - Specify a group identifier.\n   * @returns {Promise.<Group>} Promise containing an Group.\n   * @throws {Promise.<Error>} groupId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getGroup(groupId) {\n    return this._groupController.getGroup(groupId);\n  }\n\n  /**\n   * Get and return all groups in the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @returns {Promise.<Group[]>} Promise containing an array of Groups.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getGroups() {\n    return this._groupController.getGroups();\n  }\n\n  /**\n   * Get and return progress on the requested {@Link Category} for the current {@Link User} derived\n   * from the OAuth2 scope. The progress wil be returned for the current user. If a user is eligible\n   * to see the progress of more user, that progress is returned as well.\n   *\n   * It is also possible to obtain the progress for the members of a given group.\n   *\n   * @param {string} categoryId - Specify a Category identifier.\n   * @param {string} [groupId] - Optionally specify the group identifier.\n   * @param {Array} [roles] - Optionally specify user roles to filter.\n   * @returns {Promise.<Progress[]>} Array of Progress.\n   * @throws {Promise.<Error>} categoryId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  getProgress(categoryId, groupId, roles) {\n    return this._progressController.getProgress(categoryId, groupId, roles);\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/administrative-sdk.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 106,
    "kind": "class",
    "name": "AdministrativeSDK",
    "memberof": "src/administrative-sdk/administrative-sdk.js",
    "static": true,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/administrative-sdk.js",
    "importStyle": "AdministrativeSDK",
    "description": "Facade for all methods used in the ITSLanguage Administrative SDK.",
    "lineNumber": 19,
    "interface": false
  },
  {
    "__docId__": 107,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "Connection"
        ],
        "spread": false,
        "optional": false,
        "name": "connection",
        "description": "Object to use for making a connection to the REST API and Websocket server."
      }
    ]
  },
  {
    "__docId__": 108,
    "kind": "member",
    "name": "_connection",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#_connection",
    "access": "private",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 109,
    "kind": "member",
    "name": "_categoryController",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#_categoryController",
    "access": "private",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 110,
    "kind": "member",
    "name": "_choiceChallengeController",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#_choiceChallengeController",
    "access": "private",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 111,
    "kind": "member",
    "name": "_choiceRecognitionController",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#_choiceRecognitionController",
    "access": "private",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 112,
    "kind": "member",
    "name": "_emailCredentialsController",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#_emailCredentialsController",
    "access": "private",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 113,
    "kind": "member",
    "name": "_groupController",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#_groupController",
    "access": "private",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 114,
    "kind": "member",
    "name": "_organisationController",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#_organisationController",
    "access": "private",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 115,
    "kind": "member",
    "name": "_profileController",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#_profileController",
    "access": "private",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 116,
    "kind": "member",
    "name": "_progressController",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#_progressController",
    "access": "private",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 117,
    "kind": "member",
    "name": "_pronAnalaController",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#_pronAnalaController",
    "access": "private",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 118,
    "kind": "member",
    "name": "_pronChallController",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#_pronChallController",
    "access": "private",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 119,
    "kind": "member",
    "name": "_roleController",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#_roleController",
    "access": "private",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 120,
    "kind": "member",
    "name": "_speechChallengeController",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#_speechChallengeController",
    "access": "private",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 121,
    "kind": "member",
    "name": "_speechRecordingController",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#_speechRecordingController",
    "access": "private",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 122,
    "kind": "member",
    "name": "_userController",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#_userController",
    "access": "private",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "createCategory",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#createCategory",
    "access": "public",
    "description": "Create a category.",
    "lineNumber": 49,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Category>} Promise containing the newly created Category."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Category"
        ],
        "spread": false,
        "optional": false,
        "name": "category",
        "description": "Object to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Category>"
      ],
      "spread": false,
      "description": "Promise containing the newly created Category."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "category parameter of type \"Category\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "getCategory",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getCategory",
    "access": "public",
    "description": "Get a category.",
    "lineNumber": 61,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Category>} Promise containing an Category."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "categoryId",
        "description": "Specify a category identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Category>"
      ],
      "spread": false,
      "description": "Promise containing an Category."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "categoryId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "getTopLevelCategories",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getTopLevelCategories",
    "access": "public",
    "description": "Get and return all top level categories which do not have a parent Category.",
    "lineNumber": 72,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Category[]>} Promise containing an array of Categories."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "groupId",
        "description": "The ID of the group for which to fetch all top level categories."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Category[]>"
      ],
      "spread": false,
      "description": "Promise containing an array of Categories."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "getCategoriesWithParent",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getCategoriesWithParent",
    "access": "public",
    "description": "Get and return all categories which have a specific category as parent.",
    "lineNumber": 84,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Category[]>} Promise containing an array of Categories."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "parentId",
        "description": "Specify a category parent identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Category[]>"
      ],
      "spread": false,
      "description": "Promise containing an array of Categories."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "parentId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 127,
    "kind": "method",
    "name": "createChoiceChallenge",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#createChoiceChallenge",
    "access": "public",
    "description": "Create a choice challenge. The choice challenge will be created in the current active {@link Organisation} derived\nfrom the OAuth2 scope.\nIt is necessary for a choice challenge to exist for a recording to be valid.",
    "lineNumber": 97,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<ChoiceChallenge>} Containing the newly created ChoiceChallenge."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "ChoiceChallenge"
        ],
        "spread": false,
        "optional": false,
        "name": "choiceChallenge",
        "description": "Object to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<ChoiceChallenge>"
      ],
      "spread": false,
      "description": "Containing the newly created ChoiceChallenge."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "getChoiceChallenge",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getChoiceChallenge",
    "access": "public",
    "description": "Get a choice challenge. A choice challenge is identified by its identifier and the current active\n{@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 110,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<ChoiceChallenge>} Containing a ChoiceChallenge."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "Specify a choice challenge identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<ChoiceChallenge>"
      ],
      "spread": false,
      "description": "Containing a ChoiceChallenge."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link ChoiceChallenge#id} field is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "getChoiceChallenges",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getChoiceChallenges",
    "access": "public",
    "description": "Get and return all choice challenges in the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 120,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<ChoiceChallenge[]>} Containing an array of ChoiceChallenges."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<ChoiceChallenge[]>"
      ],
      "spread": false,
      "description": "Containing an array of ChoiceChallenges."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ],
    "params": []
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "startStreamingChoiceRecognition",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#startStreamingChoiceRecognition",
    "access": "public",
    "description": "Start a choice recognition from streaming audio.",
    "lineNumber": 139,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<ChoiceRecognition>} A {@link https://github.com/cujojs/when} Promise containing a {@link ChoiceRecognition}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "ChoiceChallenge"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "The choice challenge to perform."
      },
      {
        "nullable": null,
        "types": [
          "AudioRecorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "The audio recorder to extract audio from."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "trim",
        "description": "Whether to trim the start and end of recorded audio."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<ChoiceRecognition>"
      ],
      "spread": false,
      "description": "A {@link https://github.com/cujojs/when} Promise containing a {@link ChoiceRecognition}."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link ChoiceChallenge} parameter is required or invalid."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link ChoiceChallenge#id} field is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the connection is not open."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the recorder is already recording."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If a recognition session is already in progress."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If something went wrong during analysis."
      }
    ],
    "emits": [
      {
        "types": [
          "string"
        ],
        "description": "'ReadyToReceive' when the call is made to receive audio. The recorder can now send audio."
      }
    ]
  },
  {
    "__docId__": 131,
    "kind": "method",
    "name": "getChoiceRecognition",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getChoiceRecognition",
    "access": "public",
    "description": "Get a choice recognition in a choice challenge from the current active {@link Organisation} derived from\nthe OAuth2 scope.",
    "lineNumber": 154,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<ChoiceRecognition>} Promise containing a ChoiceRecognition."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "Specify a choice challenge identifier."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "recognitionId",
        "description": "Specify a choice recognition identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<ChoiceRecognition>"
      ],
      "spread": false,
      "description": "Promise containing a ChoiceRecognition."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link ChoiceChallenge#id} field is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link ChoiceRecognition#id} field is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "getChoiceRecognitions",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getChoiceRecognitions",
    "access": "public",
    "description": "Get and return all choice recognitions in a specific {@link ChoiceChallenge} from the current active\n{@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 167,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<ChoiceRecognition[]>} Promise containing an array of ChoiceRecognitions."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "Specify a choice challenge to list speech recognitions for."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<ChoiceRecognition[]>"
      ],
      "spread": false,
      "description": "Promise containing an array of ChoiceRecognitions."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link ChoiceChallenge#id} is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 133,
    "kind": "method",
    "name": "createOrganisation",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#createOrganisation",
    "access": "public",
    "description": "Create an organisation. The organisation will be owned by the current active tenant.",
    "lineNumber": 179,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Organisation>} Promise containing the newly created Organisation."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Organisation"
        ],
        "spread": false,
        "optional": false,
        "name": "organisation",
        "description": "Object to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Organisation>"
      ],
      "spread": false,
      "description": "Promise containing the newly created Organisation."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "organisation field of type \"Organisation\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 134,
    "kind": "method",
    "name": "getOrganisation",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getOrganisation",
    "access": "public",
    "description": "Get an organisation. You can only get an organisation the current tenant is the owner of.",
    "lineNumber": 191,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Organisation>} Promise containing an Organisation."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "organisationId",
        "description": "Specify an organisation identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Organisation>"
      ],
      "spread": false,
      "description": "Promise containing an Organisation."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link Organisation#id} field of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 135,
    "kind": "method",
    "name": "getOrganisations",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getOrganisations",
    "access": "public",
    "description": "Get and return all organisations the current tenant is the owner of.",
    "lineNumber": 201,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Organisation[]>} Promise containing an array of Organisations."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Organisation[]>"
      ],
      "spread": false,
      "description": "Promise containing an array of Organisations."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ],
    "params": []
  },
  {
    "__docId__": 136,
    "kind": "method",
    "name": "startStreamingPronunciationAnalysis",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#startStreamingPronunciationAnalysis",
    "access": "public",
    "description": "Start a pronunciation analysis from streaming audio.",
    "lineNumber": 224,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PronunciationAnalysis>} A {@link https://github.com/cujojs/when} Promise containing a {@link PronunciationAnalysis}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "PronunciationChallenge"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "The pronunciation challenge to perform."
      },
      {
        "nullable": null,
        "types": [
          "AudioRecorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "The audio recorder to extract audio from."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "trim",
        "description": "Whether to trim the start and end of recorded audio (default: true)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PronunciationAnalysis>"
      ],
      "spread": false,
      "description": "A {@link https://github.com/cujojs/when} Promise containing a {@link PronunciationAnalysis}."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If challenge is not an object or not defined."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If challenge has no id."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the connection is not open."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the recorder is already recording."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If a session is already in progress."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If something went wrong during analysis."
      }
    ],
    "emits": [
      {
        "types": [
          "string"
        ],
        "description": "'ReadyToReceive' when the call is made to receive audio. The recorder can now send audio."
      },
      {
        "types": [
          "Object"
        ],
        "description": "When the sent audio has finished alignment. Aligning audio is the process of mapping the audio\nto spoken words and determining when what is said. An object is sent containing a property 'progress',\nwhich is the sent audio alignment, and a property 'referenceAlignment' which is the alignment of the\nreference audio."
      }
    ]
  },
  {
    "__docId__": 137,
    "kind": "method",
    "name": "getPronunciationAnalysis",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getPronunciationAnalysis",
    "access": "public",
    "description": "Get a pronunciation analysis in a pronunciation challenge from the current active {@link Organisation} derived\nfrom the OAuth2 scope.",
    "lineNumber": 239,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PronunciationAnalysis>} Promise containing a PronunciationAnalysis."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "Specify a pronunciation challenge identifier."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "analysisId",
        "description": "Specify a pronunciation analysis identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PronunciationAnalysis>"
      ],
      "spread": false,
      "description": "Promise containing a PronunciationAnalysis."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link PronunciationChallenge#id} field is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link PronunciationAnalysis#id} field is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 138,
    "kind": "method",
    "name": "getPronunciationAnalyses",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getPronunciationAnalyses",
    "access": "public",
    "description": "Get and return all pronunciation analyses in a specific pronunciation challenge from the current active\n{@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 254,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PronunciationAnalysis[]>} Promise containing an array PronunciationAnalyses."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "Specify a pronunciation challenge identifier to list\nspeech recordings for."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "detailed",
        "description": "Returns extra analysis metadata when true."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PronunciationAnalysis[]>"
      ],
      "spread": false,
      "description": "Promise containing an array PronunciationAnalyses."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link PronunciationChallenge#id} field is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 139,
    "kind": "method",
    "name": "createPronunciationChallenge",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#createPronunciationChallenge",
    "access": "public",
    "description": "Create a pronunciation challenge. The created challenge will be part of the current active {@link Organisation}\nderived from the OAuth2 scope.",
    "lineNumber": 267,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PronunciationChallenge>} Promise containing the newly created PronunciationChallenge."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "PronunciationChallenge"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "Object to create.."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PronunciationChallenge>"
      ],
      "spread": false,
      "description": "Promise containing the newly created PronunciationChallenge."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link PronunciationChallenge#referenceAudio} of type \"Blob\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 140,
    "kind": "method",
    "name": "getPronunciationChallenge",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getPronunciationChallenge",
    "access": "public",
    "description": "Get a pronunciation challenge from the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 279,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PronunciationChallenge>} Promise containing a PronunciationChallenge."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "Specify a pronunciation challenge identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PronunciationChallenge>"
      ],
      "spread": false,
      "description": "Promise containing a PronunciationChallenge."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link PronunciationChallenge#id} field is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 141,
    "kind": "method",
    "name": "getPronunciationChallenges",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getPronunciationChallenges",
    "access": "public",
    "description": "Get and return all pronunciation challenges in the current active {@link Organisation} derived from\nthe OAuth2 scope.",
    "lineNumber": 290,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PronunciationChallenge[]>} Promise containing an array of PronunciationChallenges."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PronunciationChallenge[]>"
      ],
      "spread": false,
      "description": "Promise containing an array of PronunciationChallenges."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ],
    "params": []
  },
  {
    "__docId__": 142,
    "kind": "method",
    "name": "deletePronunciationChallenge",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#deletePronunciationChallenge",
    "access": "public",
    "description": "Delete a pronunciation challenge from the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 302,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PronunciationChallenge>} Promise containing the given challenge ID."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "A pronunciation challenge identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PronunciationChallenge>"
      ],
      "spread": false,
      "description": "Promise containing the given challenge ID."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link PronunciationChallenge#id} field is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 143,
    "kind": "method",
    "name": "createSpeechChallenge",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#createSpeechChallenge",
    "access": "public",
    "description": "Create a speech challenge in the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 314,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PronunciationChallenge>} Promise containing the newly created SpeechChallenge."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "SpeechChallenge"
        ],
        "spread": false,
        "optional": false,
        "name": "speechChallenge",
        "description": "Object to create."
      },
      {
        "nullable": true,
        "types": [
          "Blob"
        ],
        "spread": false,
        "optional": false,
        "name": "audioBlob",
        "description": "Audio fragment to link to the challenge."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PronunciationChallenge>"
      ],
      "spread": false,
      "description": "Promise containing the newly created SpeechChallenge."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "getSpeechChallenge",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getSpeechChallenge",
    "access": "public",
    "description": "Get a speech challenge from the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 326,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PronunciationChallenge>} Promise containing a SpeechChallenge."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "Specify a speech challenge identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PronunciationChallenge>"
      ],
      "spread": false,
      "description": "Promise containing a SpeechChallenge."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link SpeechChallenge#id} field is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 145,
    "kind": "method",
    "name": "getSpeechChallenges",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getSpeechChallenges",
    "access": "public",
    "description": "Get and return all speech challenges in the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 336,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<SpeechChallenge[]>} Promise containing an array of SpeechChallenges."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<SpeechChallenge[]>"
      ],
      "spread": false,
      "description": "Promise containing an array of SpeechChallenges."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ],
    "params": []
  },
  {
    "__docId__": 146,
    "kind": "method",
    "name": "startStreamingSpeechRecording",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#startStreamingSpeechRecording",
    "access": "public",
    "description": "Start a speech recording from streaming audio.",
    "lineNumber": 354,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<SpeechRecording>} A {@link https://github.com/cujojs/when} Promise containing a {@link SpeechRecording}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "SpeechChallenge"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "The speech challenge to perform."
      },
      {
        "nullable": null,
        "types": [
          "AudioRecorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "The audio recorder to extract audio from."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<SpeechRecording>"
      ],
      "spread": false,
      "description": "A {@link https://github.com/cujojs/when} Promise containing a {@link SpeechRecording}."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If challenge is not an object or not defined."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If challenge has no id."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the connection is not open."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the recorder is already recording."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If a session is already in progress."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If something went wrong during recording."
      }
    ],
    "emits": [
      {
        "types": [
          "string"
        ],
        "description": "'ReadyToReceive' when the call is made to receive audio. The recorder can now send audio."
      }
    ]
  },
  {
    "__docId__": 147,
    "kind": "method",
    "name": "getSpeechRecording",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getSpeechRecording",
    "access": "public",
    "description": "Get a speech recording in a speech challenge from the current active {@link Organisation} derived from the OAuth2\nscope.",
    "lineNumber": 369,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<SpeechRecording>} Promise containing a SpeechRecording."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "Specify a speech challenge identifier."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "recordingId",
        "description": "Specify a speech recording identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<SpeechRecording>"
      ],
      "spread": false,
      "description": "Promise containing a SpeechRecording."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link SpeechChallenge#id} field is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link SpeechRecording#id} field is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 148,
    "kind": "method",
    "name": "getSpeechRecordings",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getSpeechRecordings",
    "access": "public",
    "description": "Get and return all speech recordings in a specific speech challenge from the current active {@link Organisation}\nderived from the OAuth2 scope.",
    "lineNumber": 382,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<SpeechRecording[]>} Promise containing an array of SpeechRecordings."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "Specify a speech challenge identifier to list speech recordings for."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<SpeechRecording[]>"
      ],
      "spread": false,
      "description": "Promise containing an array of SpeechRecordings."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link SpeechChallenge#id} is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 149,
    "kind": "method",
    "name": "createUser",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#createUser",
    "access": "public",
    "description": "Create a user. The user will be created in the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 394,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<User>} Promise containing the newly created User."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "User"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "User to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<User>"
      ],
      "spread": false,
      "description": "Promise containing the newly created User."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "user parameter of type \"User\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 150,
    "kind": "method",
    "name": "getUser",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getUser",
    "access": "public",
    "description": "Get a user in the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 406,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<User>} Promise containing a User."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": "Specify a user identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<User>"
      ],
      "spread": false,
      "description": "Promise containing a User."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "userId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 151,
    "kind": "method",
    "name": "getCurrentUser",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getCurrentUser",
    "access": "public",
    "description": "Get the current authenticated user.",
    "lineNumber": 416,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<User>} The current authenticated user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<User>"
      ],
      "spread": false,
      "description": "The current authenticated user."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If something went wrong in the server."
      }
    ],
    "params": []
  },
  {
    "__docId__": 152,
    "kind": "method",
    "name": "getUsers",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getUsers",
    "access": "public",
    "description": "Get and return all users in the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 426,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<User[]>} Promise containing an array of Users."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<User[]>"
      ],
      "spread": false,
      "description": "Promise containing an array of Users."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ],
    "params": []
  },
  {
    "__docId__": 153,
    "kind": "method",
    "name": "createEmailCredentials",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#createEmailCredentials",
    "access": "public",
    "description": "Register credentials to the given user. Multiple credentials can be registered to one user.",
    "lineNumber": 440,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<EmailCredentials>} A promise containing the created EmailCredentials."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": "The identifier of the user to register credentials to."
      },
      {
        "nullable": null,
        "types": [
          "EmailCredentials"
        ],
        "spread": false,
        "optional": false,
        "name": "emailCredentials",
        "description": "The credentials to register to the user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<EmailCredentials>"
      ],
      "spread": false,
      "description": "A promise containing the created EmailCredentials."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "UserId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "EmailCredentials parameter of type \"EmailCredentials\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 154,
    "kind": "method",
    "name": "getRoles",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getRoles",
    "access": "public",
    "description": "Get and return all roles available in the API.",
    "lineNumber": 450,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Role[]>} Promise containing an array of Roles."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Role[]>"
      ],
      "spread": false,
      "description": "Promise containing an array of Roles."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ],
    "params": []
  },
  {
    "__docId__": 155,
    "kind": "method",
    "name": "getRole",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getRole",
    "access": "public",
    "description": "Get a single role.",
    "lineNumber": 462,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Role>} Promise containing a Role."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "roleId",
        "description": "Identifier of the role."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Role>"
      ],
      "spread": false,
      "description": "Promise containing a Role."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "roleId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 156,
    "kind": "method",
    "name": "getProfile",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getProfile",
    "access": "public",
    "description": "Get the profile of the given user active in the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 474,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Profile>} Promise containing a Profile."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": "Specify a User identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Profile>"
      ],
      "spread": false,
      "description": "Promise containing a Profile."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "userId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 157,
    "kind": "method",
    "name": "getProfiles",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getProfiles",
    "access": "public",
    "description": "Get and return all profiles of all users in the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 484,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Profile[]>} Array of Profiles."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Profile[]>"
      ],
      "spread": false,
      "description": "Array of Profiles."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ],
    "params": []
  },
  {
    "__docId__": 158,
    "kind": "method",
    "name": "createGroup",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#createGroup",
    "access": "public",
    "description": "Create a group. The group will be part of the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 496,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Group>} Promise containing the newly created Group."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Organisation"
        ],
        "spread": false,
        "optional": false,
        "name": "group",
        "description": "Object to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Group>"
      ],
      "spread": false,
      "description": "Promise containing the newly created Group."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "organisation parameter of type \"Group\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 159,
    "kind": "method",
    "name": "getGroup",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getGroup",
    "access": "public",
    "description": "Get a group which is part of the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 508,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Group>} Promise containing an Group."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "groupId",
        "description": "Specify a group identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Group>"
      ],
      "spread": false,
      "description": "Promise containing an Group."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "groupId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 160,
    "kind": "method",
    "name": "getGroups",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getGroups",
    "access": "public",
    "description": "Get and return all groups in the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 518,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Group[]>} Promise containing an array of Groups."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Group[]>"
      ],
      "spread": false,
      "description": "Promise containing an array of Groups."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ],
    "params": []
  },
  {
    "__docId__": 161,
    "kind": "method",
    "name": "getProgress",
    "memberof": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/administrative-sdk.js~AdministrativeSDK#getProgress",
    "access": "public",
    "description": "Get and return progress on the requested {@Link Category} for the current {@Link User} derived\nfrom the OAuth2 scope. The progress wil be returned for the current user. If a user is eligible\nto see the progress of more user, that progress is returned as well.\n\nIt is also possible to obtain the progress for the members of a given group.",
    "lineNumber": 536,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Progress[]>} Array of Progress."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "categoryId",
        "description": "Specify a Category identifier."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "groupId",
        "description": "Optionally specify the group identifier."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "roles",
        "description": "Optionally specify user roles to filter."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Progress[]>"
      ],
      "spread": false,
      "description": "Array of Progress."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "categoryId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 162,
    "kind": "file",
    "name": "src/administrative-sdk/basic-auth/basic-auth.js",
    "content": "/**\n * BasicAuth domain model.\n */\nexport default class BasicAuth {\n  /**\n   * @param {string} tenantId - The Tenant identifier to create this BasicAuth for.\n   * @param {?string} principal - The principal. If none is given, one is generated.\n   * @param {?string} credentials - The credentials. If none are given, one is generated.\n   * @throws {Error} tenantId parameter of type \"string\" is required.\n   * @throws {Error} principal parameter of type \"string|null\" is required.\n   * @throws {Error} credentials parameter of type \"string|null\" is required.\n   */\n  constructor(tenantId, principal = null, credentials = null) {\n    if (typeof tenantId !== 'string') {\n      throw new Error(\n        'tenantId parameter of type \"string\" is required');\n    }\n\n    if (principal !== null && typeof principal !== 'string') {\n      throw new Error(\n        'principal parameter of type \"string|null\" is required');\n    }\n\n    if (credentials !== null && typeof credentials !== 'string') {\n      throw new Error(\n        'credentials parameter of type \"string|null\" is required');\n    }\n\n    /**\n     * The Tenant identifier to create this BasicAuth for.\n     * @type {string}\n     */\n    this.tenantId = tenantId;\n\n    /**\n     * The principal. If none is given, one is generated.\n     * @type {string}\n     */\n    this.principal = principal;\n\n    /**\n     * The credentials. If none are given, one is generated.\n     * @type {string}\n     */\n    this.credentials = credentials;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/basic-auth/basic-auth.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 163,
    "kind": "class",
    "name": "BasicAuth",
    "memberof": "src/administrative-sdk/basic-auth/basic-auth.js",
    "static": true,
    "longname": "src/administrative-sdk/basic-auth/basic-auth.js~BasicAuth",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/basic-auth/basic-auth.js",
    "importStyle": "BasicAuth",
    "description": "BasicAuth domain model.",
    "lineNumber": 4,
    "interface": false
  },
  {
    "__docId__": 164,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/basic-auth/basic-auth.js~BasicAuth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/basic-auth/basic-auth.js~BasicAuth#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tenantId",
        "description": "The Tenant identifier to create this BasicAuth for."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "principal",
        "description": "The principal. If none is given, one is generated."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "credentials",
        "description": "The credentials. If none are given, one is generated."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "tenantId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "principal parameter of type \"string|null\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "credentials parameter of type \"string|null\" is required."
      }
    ]
  },
  {
    "__docId__": 165,
    "kind": "member",
    "name": "tenantId",
    "memberof": "src/administrative-sdk/basic-auth/basic-auth.js~BasicAuth",
    "static": false,
    "longname": "src/administrative-sdk/basic-auth/basic-auth.js~BasicAuth#tenantId",
    "access": "public",
    "description": "The Tenant identifier to create this BasicAuth for.",
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 166,
    "kind": "member",
    "name": "principal",
    "memberof": "src/administrative-sdk/basic-auth/basic-auth.js~BasicAuth",
    "static": false,
    "longname": "src/administrative-sdk/basic-auth/basic-auth.js~BasicAuth#principal",
    "access": "public",
    "description": "The principal. If none is given, one is generated.",
    "lineNumber": 39,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 167,
    "kind": "member",
    "name": "credentials",
    "memberof": "src/administrative-sdk/basic-auth/basic-auth.js~BasicAuth",
    "static": false,
    "longname": "src/administrative-sdk/basic-auth/basic-auth.js~BasicAuth#credentials",
    "access": "public",
    "description": "The credentials. If none are given, one is generated.",
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 168,
    "kind": "file",
    "name": "src/administrative-sdk/category/category-controller.js",
    "content": "import Category from './category';\n\n/**\n * Controller class for the Category model.\n * @private\n */\nexport default class CategoryController {\n  /**\n   * @param {Connection} connection - Object to use for making a connection to the REST API and Websocket server.\n   */\n  constructor(connection) {\n    /**\n     * Object to use for making a connection to the REST API and Websocket server.\n     * @type {Connection}\n     */\n    this._connection = connection;\n  }\n\n  /**\n   * Create a category.\n   *\n   * @param {Category} category - Object to create.\n   * @returns {Promise.<Category>} Promise containing the newly created Category.\n   * @throws {Promise.<Error>} category parameter of type \"Category\" is required.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  createCategory(category) {\n    if (!(category instanceof Category)) {\n      return Promise.reject(new Error('category parameter of type \"Category\" is required'));\n    }\n\n    const url = this._connection._settings.apiUrl + '/categories';\n    const fd = JSON.stringify(category);\n    return this._connection._secureAjaxPost(url, fd)\n      .then(data => {\n        const result = new Category(data.id, data.parent, data.name, data.description, data.color,\n          data.speechChallenges);\n        result.imageUrl = data.imageUrl;\n        result.iconUrl = data.iconUrl;\n        result.created = new Date(data.created);\n        result.updated = new Date(data.updated);\n        return result;\n      });\n  }\n\n  /**\n   * Get a category.\n   *\n   * @param {string} categoryId - Specify a category identifier.\n   * @returns {Promise.<Category>} Promise containing an Category.\n   * @throws {Promise.<Error>} categoryId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getCategory(categoryId) {\n    if (typeof categoryId !== 'string') {\n      return Promise.reject(new Error('categoryId parameter of type \"string\" is required'));\n    }\n\n    const url = this._connection._settings.apiUrl + '/categories/' + categoryId;\n    return this._connection._secureAjaxGet(url)\n      .then(data => {\n        const result = new Category(data.id, data.parent, data.name, data.description, data.color,\n          data.speechChallenges);\n        result.imageUrl = data.imageUrl;\n        result.iconUrl = data.iconUrl;\n        result.created = new Date(data.created);\n        result.updated = new Date(data.updated);\n        return result;\n      });\n  }\n\n  /**\n   * Get and return all top level categories which do not have a parent Category.\n   *\n   * @param {string} [groupId] - The ID of the group for which to fetch the categories.\n   * @returns {Promise.<Category[]>} Promise containing an array of Categories.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getTopLevelCategories(groupId) {\n    let urlMod;\n    if (groupId) {\n      urlMod = `?group=${groupId}`;\n    }\n    return this.getCategories(urlMod);\n  }\n\n  /**\n   * Get and return all categories which have a specific category as parent.\n   *\n   * @param {string} parentId - Specify a category parent identifier.\n   * @returns {Promise.<Category[]>} Promise containing an array of Categories.\n   * @throws {Promise.<Error>} parentId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getCategoriesWithParent(parentId) {\n    if (typeof parentId !== 'string') {\n      return Promise.reject(new Error('parentId parameter of type \"string\" is required'));\n    }\n    return this.getCategories('/' + parentId + '/categories');\n  }\n\n  getCategories(urlModification = null) {\n    let url = this._connection._settings.apiUrl + '/categories';\n    if (urlModification !== null) {\n      url += urlModification;\n    }\n    return this._connection._secureAjaxGet(url)\n      .then(data => data.map(datum => {\n        const category = new Category(datum.id, datum.parent, datum.name, datum.description, datum.color,\n          datum.speechChallenges);\n        category.imageUrl = datum.imageUrl;\n        category.iconUrl = datum.iconUrl;\n        category.created = new Date(datum.created);\n        category.updated = new Date(datum.updated);\n        return category;\n      }));\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/category/category-controller.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 169,
    "kind": "class",
    "name": "CategoryController",
    "memberof": "src/administrative-sdk/category/category-controller.js",
    "static": true,
    "longname": "src/administrative-sdk/category/category-controller.js~CategoryController",
    "access": "private",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/category/category-controller.js",
    "importStyle": "CategoryController",
    "description": "Controller class for the Category model.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 170,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/category/category-controller.js~CategoryController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/category/category-controller.js~CategoryController#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "Connection"
        ],
        "spread": false,
        "optional": false,
        "name": "connection",
        "description": "Object to use for making a connection to the REST API and Websocket server."
      }
    ]
  },
  {
    "__docId__": 171,
    "kind": "member",
    "name": "_connection",
    "memberof": "src/administrative-sdk/category/category-controller.js~CategoryController",
    "static": false,
    "longname": "src/administrative-sdk/category/category-controller.js~CategoryController#_connection",
    "access": "private",
    "description": "Object to use for making a connection to the REST API and Websocket server.",
    "lineNumber": 16,
    "type": {
      "nullable": null,
      "types": [
        "Connection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 172,
    "kind": "method",
    "name": "createCategory",
    "memberof": "src/administrative-sdk/category/category-controller.js~CategoryController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/category/category-controller.js~CategoryController#createCategory",
    "access": "public",
    "description": "Create a category.",
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Category>} Promise containing the newly created Category."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Category"
        ],
        "spread": false,
        "optional": false,
        "name": "category",
        "description": "Object to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Category>"
      ],
      "spread": false,
      "description": "Promise containing the newly created Category."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "category parameter of type \"Category\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 173,
    "kind": "method",
    "name": "getCategory",
    "memberof": "src/administrative-sdk/category/category-controller.js~CategoryController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/category/category-controller.js~CategoryController#getCategory",
    "access": "public",
    "description": "Get a category.",
    "lineNumber": 54,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Category>} Promise containing an Category."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "categoryId",
        "description": "Specify a category identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Category>"
      ],
      "spread": false,
      "description": "Promise containing an Category."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "categoryId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 174,
    "kind": "method",
    "name": "getTopLevelCategories",
    "memberof": "src/administrative-sdk/category/category-controller.js~CategoryController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/category/category-controller.js~CategoryController#getTopLevelCategories",
    "access": "public",
    "description": "Get and return all top level categories which do not have a parent Category.",
    "lineNumber": 79,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Category[]>} Promise containing an array of Categories."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "groupId",
        "description": "The ID of the group for which to fetch the categories."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Category[]>"
      ],
      "spread": false,
      "description": "Promise containing an array of Categories."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 175,
    "kind": "method",
    "name": "getCategoriesWithParent",
    "memberof": "src/administrative-sdk/category/category-controller.js~CategoryController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/category/category-controller.js~CategoryController#getCategoriesWithParent",
    "access": "public",
    "description": "Get and return all categories which have a specific category as parent.",
    "lineNumber": 95,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Category[]>} Promise containing an array of Categories."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "parentId",
        "description": "Specify a category parent identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Category[]>"
      ],
      "spread": false,
      "description": "Promise containing an array of Categories."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "parentId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 176,
    "kind": "method",
    "name": "getCategories",
    "memberof": "src/administrative-sdk/category/category-controller.js~CategoryController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/category/category-controller.js~CategoryController#getCategories",
    "access": "public",
    "description": null,
    "lineNumber": 102,
    "undocument": true,
    "params": [
      {
        "name": "urlModification",
        "optional": true,
        "types": [
          "undefined"
        ],
        "defaultValue": "undefined"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 177,
    "kind": "file",
    "name": "src/administrative-sdk/category/category.js",
    "content": "/**\n * A category for a challenge.\n * It is used to give a challenge front end attributes such as an icon, a color palette etc.\n */\nexport default class Category {\n  /**\n   * Create a category.\n   *\n   * @param {?string} id - Identifier of this category. If none is given one is generated upon creation in the API.\n   * @param {?string} parent - Identifier of the parent category.\n   * @param {?string} name - Name associated with this category.\n   * @param {?string} description - Description associated with this category.\n   * @param {?string} color - Color code in hexadecimal format associated with this category.\n   * @param {?Array.<string>} speechChallenges - Identifiers of the challenges this category contains.\n   * A category can only contain either more categories or challenges.\n   * @throws {Error} id parameter of type \"string|null\" is required.\n   * @throws {Error} name parameter of type \"string|null\" is required.\n   * @throws {Error} description parameter of type \"string|null\" is required.\n   * @throws {Error} color parameter of type \"string|null\" is required.\n   * @throws {Error} speechChallenges parameter of type \"Array.<string>|null\" is required.\n   */\n  constructor(id = null, parent = null, name = null, description = null, color = null, speechChallenges = null) {\n    if (id !== null && typeof id !== 'string') {\n      throw new Error('id parameter of type \"string|null\" is required');\n    }\n\n    if (parent !== null && typeof parent !== 'string') {\n      throw new Error('parent parameter of type \"string|null\" is required');\n    }\n\n    if (typeof name !== 'string') {\n      throw new Error('name parameter of type \"string|null\" is required');\n    }\n\n    if (description !== null && typeof description !== 'string') {\n      throw new Error('description parameter of type \"string|null\" is required');\n    }\n\n    if (color !== null && typeof color !== 'string') {\n      throw new Error('color parameter of type \"string|null\" is required');\n    }\n\n    if (speechChallenges !== null && !Array.isArray(speechChallenges)) {\n      throw new Error('speechChallenges parameter of type \"Array.<string>|null\" is required');\n    }\n\n    /**\n     * Identifier of this category. If none is given one is generated upon creation in the API.\n     * @type {string}\n     */\n    this.id = id;\n\n    /**\n     * Identifier of the parent category.\n     * @type {string}\n     */\n    this.parent = parent;\n\n    /**\n     * Name associated with this category.\n     * @type {string}\n     */\n    this.name = name;\n\n    /**\n     * Description associated with this category.\n     * @type {string}\n     */\n    this.description = description;\n\n    /**\n     * Color code in hexadecimal format associated with this category.\n     * @type {string}\n     */\n    this.color = color;\n\n    /**\n     * Download URL of the image associated with this category. This URL is only generated from the backend.\n     * @type {string}\n     */\n    this.imageUrl = null;\n\n    /**\n     * Download URL of the icon associated with this category. This URL is only generated from the backend.\n     * @type {string}\n     */\n    this.iconUrl = null;\n\n    /**\n     * Challenges this category contains. A category can only contain either more categories or challenges.\n     * @type {Array.<string>}\n     */\n    this.speechChallenges = speechChallenges;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/category/category.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 178,
    "kind": "class",
    "name": "Category",
    "memberof": "src/administrative-sdk/category/category.js",
    "static": true,
    "longname": "src/administrative-sdk/category/category.js~Category",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/category/category.js",
    "importStyle": "Category",
    "description": "A category for a challenge.\nIt is used to give a challenge front end attributes such as an icon, a color palette etc.",
    "lineNumber": 5,
    "interface": false
  },
  {
    "__docId__": 179,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/category/category.js~Category",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/category/category.js~Category#constructor",
    "access": "public",
    "description": "Create a category.",
    "lineNumber": 22,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "Identifier of this category. If none is given one is generated upon creation in the API."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "parent",
        "description": "Identifier of the parent category."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name associated with this category."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "description",
        "description": "Description associated with this category."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "color",
        "description": "Color code in hexadecimal format associated with this category."
      },
      {
        "nullable": true,
        "types": [
          "Array.<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "speechChallenges",
        "description": "Identifiers of the challenges this category contains.\nA category can only contain either more categories or challenges."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "id parameter of type \"string|null\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "name parameter of type \"string|null\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "description parameter of type \"string|null\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "color parameter of type \"string|null\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "speechChallenges parameter of type \"Array.<string>|null\" is required."
      }
    ]
  },
  {
    "__docId__": 180,
    "kind": "member",
    "name": "id",
    "memberof": "src/administrative-sdk/category/category.js~Category",
    "static": false,
    "longname": "src/administrative-sdk/category/category.js~Category#id",
    "access": "public",
    "description": "Identifier of this category. If none is given one is generated upon creation in the API.",
    "lineNumber": 51,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 181,
    "kind": "member",
    "name": "parent",
    "memberof": "src/administrative-sdk/category/category.js~Category",
    "static": false,
    "longname": "src/administrative-sdk/category/category.js~Category#parent",
    "access": "public",
    "description": "Identifier of the parent category.",
    "lineNumber": 57,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 182,
    "kind": "member",
    "name": "name",
    "memberof": "src/administrative-sdk/category/category.js~Category",
    "static": false,
    "longname": "src/administrative-sdk/category/category.js~Category#name",
    "access": "public",
    "description": "Name associated with this category.",
    "lineNumber": 63,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 183,
    "kind": "member",
    "name": "description",
    "memberof": "src/administrative-sdk/category/category.js~Category",
    "static": false,
    "longname": "src/administrative-sdk/category/category.js~Category#description",
    "access": "public",
    "description": "Description associated with this category.",
    "lineNumber": 69,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 184,
    "kind": "member",
    "name": "color",
    "memberof": "src/administrative-sdk/category/category.js~Category",
    "static": false,
    "longname": "src/administrative-sdk/category/category.js~Category#color",
    "access": "public",
    "description": "Color code in hexadecimal format associated with this category.",
    "lineNumber": 75,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 185,
    "kind": "member",
    "name": "imageUrl",
    "memberof": "src/administrative-sdk/category/category.js~Category",
    "static": false,
    "longname": "src/administrative-sdk/category/category.js~Category#imageUrl",
    "access": "public",
    "description": "Download URL of the image associated with this category. This URL is only generated from the backend.",
    "lineNumber": 81,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 186,
    "kind": "member",
    "name": "iconUrl",
    "memberof": "src/administrative-sdk/category/category.js~Category",
    "static": false,
    "longname": "src/administrative-sdk/category/category.js~Category#iconUrl",
    "access": "public",
    "description": "Download URL of the icon associated with this category. This URL is only generated from the backend.",
    "lineNumber": 87,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 187,
    "kind": "member",
    "name": "speechChallenges",
    "memberof": "src/administrative-sdk/category/category.js~Category",
    "static": false,
    "longname": "src/administrative-sdk/category/category.js~Category#speechChallenges",
    "access": "public",
    "description": "Challenges this category contains. A category can only contain either more categories or challenges.",
    "lineNumber": 93,
    "type": {
      "nullable": null,
      "types": [
        "Array.<string>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 188,
    "kind": "file",
    "name": "src/administrative-sdk/choice-challenge/choice-challenge-controller.js",
    "content": "import ChoiceChallenge from './choice-challenge';\n\n/**\n * Controller class for the {@link ChoiceChallenge} model.\n * @private\n */\nexport default class ChoiceChallengeController {\n  /**\n   * @param {Connection} connection - Object to use for making a connection to the REST API and Websocket server.\n   */\n  constructor(connection) {\n    /**\n     * Object to use for making a connection to the REST API and Websocket server.\n     * @type {Connection}\n     */\n    this._connection = connection;\n  }\n\n  /**\n   * Create a choice challenge. The choice challenge will be created in the current active {@link Organisation} derived\n   * from the OAuth2 scope.\n   * It is necessary for a choice challenge to exist for a recording to be valid.\n   *\n   * @param {ChoiceChallenge} choiceChallenge - Object to create.\n   * @returns {Promise.<ChoiceChallenge>} Containing the newly created ChoiceChallenge.\n   * @throws {Promise.<Error>} choiceChallenge parameter of type \"ChoiceChallenge\" is required.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  createChoiceChallenge(choiceChallenge) {\n    if (!(choiceChallenge instanceof ChoiceChallenge)) {\n      return Promise.reject(new Error('choiceChallenge parameter of type \"ChoiceChallenge\" is required'));\n    }\n    const url = this._connection._settings.apiUrl + '/challenges/choice';\n    const fd = JSON.stringify(choiceChallenge);\n    return this._connection._secureAjaxPost(url, fd)\n      .then(data => {\n        const result = new ChoiceChallenge(data.id, data.question, data.choices);\n        result.created = new Date(data.created);\n        result.updated = new Date(data.updated);\n        result.status = data.status;\n        result.choices = data.choices.map(pair => pair.choice);\n        return result;\n      });\n  }\n\n  /**\n   * Get a choice challenge. A choice challenge is identified by its identifier and the current active\n   * {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {string} challengeId - Specify a choice challenge identifier.\n   * @returns {Promise.<ChoiceChallenge>} Containing a ChoiceChallenge.\n   * @throws {Promise.<Error>} challengeId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getChoiceChallenge(challengeId) {\n    if (typeof challengeId !== 'string') {\n      return Promise.reject(new Error('challengeId parameter of type \"string\" is required'));\n    }\n    const url = this._connection._settings.apiUrl + '/challenges/choice/' + challengeId;\n    return this._connection._secureAjaxGet(url)\n      .then(data => {\n        const challenge = new ChoiceChallenge(data.id, data.question, data.choices);\n        challenge.created = new Date(data.created);\n        challenge.updated = new Date(data.updated);\n        challenge.status = data.status;\n        challenge.choices = data.choices.map(pair => pair.choice);\n        return challenge;\n      });\n  }\n\n  /**\n   * Get and return all choice challenges in the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @returns {Promise.<ChoiceChallenge[]>} Containing an array of ChoiceChallenges.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getChoiceChallenges() {\n    const url = this._connection._settings.apiUrl + '/challenges/choice';\n    return this._connection._secureAjaxGet(url)\n      .then(data => data.map(datum => {\n        const challenge = new ChoiceChallenge(datum.id, datum.question, datum.choices);\n        challenge.created = new Date(datum.created);\n        challenge.updated = new Date(datum.updated);\n        challenge.status = datum.status;\n        challenge.choices = datum.choices.map(pair => pair.choice);\n        return challenge;\n      }));\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/choice-challenge/choice-challenge-controller.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 189,
    "kind": "class",
    "name": "ChoiceChallengeController",
    "memberof": "src/administrative-sdk/choice-challenge/choice-challenge-controller.js",
    "static": true,
    "longname": "src/administrative-sdk/choice-challenge/choice-challenge-controller.js~ChoiceChallengeController",
    "access": "private",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/choice-challenge/choice-challenge-controller.js",
    "importStyle": "ChoiceChallengeController",
    "description": "Controller class for the {@link ChoiceChallenge} model.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 190,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/choice-challenge/choice-challenge-controller.js~ChoiceChallengeController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/choice-challenge/choice-challenge-controller.js~ChoiceChallengeController#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "Connection"
        ],
        "spread": false,
        "optional": false,
        "name": "connection",
        "description": "Object to use for making a connection to the REST API and Websocket server."
      }
    ]
  },
  {
    "__docId__": 191,
    "kind": "member",
    "name": "_connection",
    "memberof": "src/administrative-sdk/choice-challenge/choice-challenge-controller.js~ChoiceChallengeController",
    "static": false,
    "longname": "src/administrative-sdk/choice-challenge/choice-challenge-controller.js~ChoiceChallengeController#_connection",
    "access": "private",
    "description": "Object to use for making a connection to the REST API and Websocket server.",
    "lineNumber": 16,
    "type": {
      "nullable": null,
      "types": [
        "Connection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 192,
    "kind": "method",
    "name": "createChoiceChallenge",
    "memberof": "src/administrative-sdk/choice-challenge/choice-challenge-controller.js~ChoiceChallengeController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/choice-challenge/choice-challenge-controller.js~ChoiceChallengeController#createChoiceChallenge",
    "access": "public",
    "description": "Create a choice challenge. The choice challenge will be created in the current active {@link Organisation} derived\nfrom the OAuth2 scope.\nIt is necessary for a choice challenge to exist for a recording to be valid.",
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<ChoiceChallenge>} Containing the newly created ChoiceChallenge."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "ChoiceChallenge"
        ],
        "spread": false,
        "optional": false,
        "name": "choiceChallenge",
        "description": "Object to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<ChoiceChallenge>"
      ],
      "spread": false,
      "description": "Containing the newly created ChoiceChallenge."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "choiceChallenge parameter of type \"ChoiceChallenge\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 193,
    "kind": "method",
    "name": "getChoiceChallenge",
    "memberof": "src/administrative-sdk/choice-challenge/choice-challenge-controller.js~ChoiceChallengeController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/choice-challenge/choice-challenge-controller.js~ChoiceChallengeController#getChoiceChallenge",
    "access": "public",
    "description": "Get a choice challenge. A choice challenge is identified by its identifier and the current active\n{@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 55,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<ChoiceChallenge>} Containing a ChoiceChallenge."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "Specify a choice challenge identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<ChoiceChallenge>"
      ],
      "spread": false,
      "description": "Containing a ChoiceChallenge."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "challengeId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 194,
    "kind": "method",
    "name": "getChoiceChallenges",
    "memberof": "src/administrative-sdk/choice-challenge/choice-challenge-controller.js~ChoiceChallengeController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/choice-challenge/choice-challenge-controller.js~ChoiceChallengeController#getChoiceChallenges",
    "access": "public",
    "description": "Get and return all choice challenges in the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 77,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<ChoiceChallenge[]>} Containing an array of ChoiceChallenges."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<ChoiceChallenge[]>"
      ],
      "spread": false,
      "description": "Containing an array of ChoiceChallenges."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ],
    "params": []
  },
  {
    "__docId__": 195,
    "kind": "file",
    "name": "src/administrative-sdk/choice-challenge/choice-challenge.js",
    "content": "/**\n * ChoiceChallenge domain model.\n */\nexport default class ChoiceChallenge {\n  /**\n   * Create a choice challenge domain model.\n   *\n   * @param {?string} id - The {@link ChoiceChallenge} identifier. If none is given, one is generated.\n   * @param {?string} question - A hint or question related to the choices.\n   * @param {string[]} choices - The sentences of which at most one may be recognised.\n   * @throws {Error} id parameter of type \"string|null\" is required.\n   * @throws {Error} question parameter of type \"string|null|undefined\" is required.\n   * @throws {Error} choices parameter of type \"Array.<string>\" is required.\n   */\n  constructor(id = null, question = null, choices) {\n    if (id !== null && typeof id !== 'string') {\n      throw new Error(\n        'id parameter of type \"string|null\" is required');\n    }\n\n    if (question !== null && typeof question !== 'string') {\n      throw new Error(\n        'question parameter of type \"string|null\" is required');\n    }\n\n    if (!Array.isArray(choices)) {\n      throw new Error(\n        'choices parameter of type \"Array.<string>\" is required');\n    }\n\n    /**\n     * The choice challenge identifier.\n     * @type {string}\n     */\n    this.id = id;\n\n    /**\n     * A hint or question related to the choices.\n     * @type {string}\n     */\n    this.question = question;\n\n    /**\n     * The sentences of which at most one may be recognised.\n     * @type {string[]}\n     */\n    this.choices = choices;\n\n    /**\n     * The status of the challenge's preparation. Either 'unprepared', 'preparing' or 'prepared'.\n     * @type {string}\n     */\n    this.status = null;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/choice-challenge/choice-challenge.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 196,
    "kind": "class",
    "name": "ChoiceChallenge",
    "memberof": "src/administrative-sdk/choice-challenge/choice-challenge.js",
    "static": true,
    "longname": "src/administrative-sdk/choice-challenge/choice-challenge.js~ChoiceChallenge",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/choice-challenge/choice-challenge.js",
    "importStyle": "ChoiceChallenge",
    "description": "ChoiceChallenge domain model.",
    "lineNumber": 4,
    "interface": false
  },
  {
    "__docId__": 197,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/choice-challenge/choice-challenge.js~ChoiceChallenge",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/choice-challenge/choice-challenge.js~ChoiceChallenge#constructor",
    "access": "public",
    "description": "Create a choice challenge domain model.",
    "lineNumber": 15,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The {@link ChoiceChallenge} identifier. If none is given, one is generated."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "question",
        "description": "A hint or question related to the choices."
      },
      {
        "nullable": null,
        "types": [
          "string[]"
        ],
        "spread": false,
        "optional": false,
        "name": "choices",
        "description": "The sentences of which at most one may be recognised."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "id parameter of type \"string|null\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "question parameter of type \"string|null|undefined\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "choices parameter of type \"Array.<string>\" is required."
      }
    ]
  },
  {
    "__docId__": 198,
    "kind": "member",
    "name": "id",
    "memberof": "src/administrative-sdk/choice-challenge/choice-challenge.js~ChoiceChallenge",
    "static": false,
    "longname": "src/administrative-sdk/choice-challenge/choice-challenge.js~ChoiceChallenge#id",
    "access": "public",
    "description": "The choice challenge identifier.",
    "lineNumber": 35,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 199,
    "kind": "member",
    "name": "question",
    "memberof": "src/administrative-sdk/choice-challenge/choice-challenge.js~ChoiceChallenge",
    "static": false,
    "longname": "src/administrative-sdk/choice-challenge/choice-challenge.js~ChoiceChallenge#question",
    "access": "public",
    "description": "A hint or question related to the choices.",
    "lineNumber": 41,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 200,
    "kind": "member",
    "name": "choices",
    "memberof": "src/administrative-sdk/choice-challenge/choice-challenge.js~ChoiceChallenge",
    "static": false,
    "longname": "src/administrative-sdk/choice-challenge/choice-challenge.js~ChoiceChallenge#choices",
    "access": "public",
    "description": "The sentences of which at most one may be recognised.",
    "lineNumber": 47,
    "type": {
      "nullable": null,
      "types": [
        "string[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 201,
    "kind": "member",
    "name": "status",
    "memberof": "src/administrative-sdk/choice-challenge/choice-challenge.js~ChoiceChallenge",
    "static": false,
    "longname": "src/administrative-sdk/choice-challenge/choice-challenge.js~ChoiceChallenge#status",
    "access": "public",
    "description": "The status of the challenge's preparation. Either 'unprepared', 'preparing' or 'prepared'.",
    "lineNumber": 53,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 202,
    "kind": "file",
    "name": "src/administrative-sdk/choice-recognition/choice-recognition-controller.js",
    "content": "import Base64Utils from '../utils/base64-utils';\nimport ChoiceChallenge from '../choice-challenge/choice-challenge';\nimport ChoiceRecognition from './choice-recognition';\nimport Connection from '../connection/connection-controller';\nimport when from 'when';\n/**\n * Controller class for the ChoiceRecognition model.\n * @private\n */\nexport default class ChoiceRecognitionController {\n  /**\n   * @param {Connection} connection - Object to use for making a connection to the REST API and Websocket server.\n   */\n  constructor(connection) {\n    /**\n     * Object to use for making a connection to the REST API and Websocket server.\n     * @type {Connection}\n     */\n    this._connection = connection;\n  }\n\n  /**\n   * Initialise the choice recognition challenge through RPCs.\n   *\n   * @param {ChoiceChallenge} challenge - ChoiceChallenge.\n   * @private\n   */\n  choiceRecognitionInitChallenge(challenge) {\n    return this._connection.call('choice.init_challenge',\n      [this._connection._recognitionId, challenge.id])\n      .then(\n        // RPC success callback\n        recognitionId => {\n          console.log('Challenge initialised for recognitionId: ' + this._connection._recognitionId);\n          return recognitionId;\n        });\n  }\n\n  /**\n   * Initialise the pronunciation analysis audio specs through RPCs.\n   *\n   * @param {AudioRecorder} recorder - AudioRecorder.\n   * @param {Function} dataavailableCb - Callback.\n   * @private\n   */\n  choiceRecognitionInitAudio(recorder, dataavailableCb) {\n    // Indicate to the socket server that we're about to start recording a\n    // challenge. This allows the socket server some time to fetch the metadata\n    // and reference audio to start the analysis when audio is actually submitted.\n    const specs = recorder.getAudioSpecs();\n    return this._connection.call('choice.init_audio',\n      [this._connection._recognitionId, specs.audioFormat], specs.audioParameters).then(\n      // RPC success callback\n      recognitionId => {\n        console.log('Accepted audio parameters for recognitionId after init_audio: ' + this._connection._recognitionId);\n        // Start listening for streaming data.\n        recorder.addEventListener('dataavailable', dataavailableCb);\n        return recognitionId;\n      });\n  }\n\n  /**\n   * Start a choice recognition from streaming audio.\n   *\n   * @param {ChoiceChallenge} challenge - The choice challenge to perform.\n   * @param {AudioRecorder} recorder - The audio recorder to extract audio from.\n   * @param {boolean} [trim=true] - Whether to trim the start and end of recorded audio.\n   * @returns {Promise.<ChoiceRecognition>} A {@link https://github.com/cujojs/when} Promise containing a {@link ChoiceRecognition}.\n   * @emits {string} 'ReadyToReceive' when the call is made to receive audio. The recorder can now send audio.\n   * @throws {Promise.<Error>} challenge parameter of type \"ChoiceChallenge\" is required.\n   * @throws {Promise.<Error>} challenge.id field of type \"string\" is required.\n   * @throws {Promise.<Error>} If the connection is not open.\n   * @throws {Promise.<Error>} If the recorder is already recording.\n   * @throws {Promise.<Error>} If a recognition session is already in progress.\n   * @throws {Promise.<Error>} If something went wrong during analysis.\n   */\n  startStreamingChoiceRecognition(challenge, recorder, trim) {\n    if (!(challenge instanceof ChoiceChallenge)) {\n      return Promise.reject(new Error('challenge parameter of type \"ChoiceChallenge\" is required'));\n    }\n\n    if (typeof challenge.id !== 'string') {\n      return Promise.reject(new Error('challenge.id field of type \"string\" is required'));\n    }\n\n    // Validate environment prerequisites.\n    if (!this._connection._session) {\n      return Promise.reject(new Error('WebSocket connection was not open.'));\n    }\n\n    if (recorder.isRecording()) {\n      return Promise.reject(new Error('Recorder should not yet be recording.'));\n    }\n\n    if (this._connection._recognitionId !== null) {\n      return Promise.reject(new Error('Session with recognitionId ' + this._connection._recognitionId +\n        ' still in progress.'));\n    }\n\n    const self = this;\n    let trimAudioStart = 0.15;\n    const trimAudioEnd = 0.0;\n    if (trim === false) {\n      trimAudioStart = 0.0;\n    }\n    return new when.Promise((resolve, reject, notify) => {\n      function _cb(data) {\n        const recognition = new ChoiceRecognition(\n          challenge.id, data.userId, data.id,\n          new Date(data.created), new Date(data.updated),\n          self._connection.addAccessToken(data.audioUrl), data.recognised);\n        resolve({recognitionId: self._connection._recognitionId, recognition});\n      }\n\n      function _ecb(data) {\n        // There was an unexpected error.\n        const recognition = new ChoiceRecognition(\n          challenge.id, data.userId, data.id,\n          new Date(data.created), new Date(data.updated),\n          self._connection.addAccessToken(data.audioUrl), null);\n        reject(\n          {\n            recognition,\n            message: data.message\n          }\n        );\n      }\n\n      self._connection._recognitionId = null;\n\n      // Start streaming the binary audio when the user instructs\n      // the audio recorder to start recording.\n      function dataavailableCb(chunk) {\n        const encoded = Base64Utils._arrayBufferToBase64(chunk);\n        console.log('Sending audio chunk to websocket for recognitionId: ' +\n          self._connection._recognitionId);\n        self._connection.call('choice.write',\n          [self._connection._recognitionId, encoded, 'base64'])\n          .catch(res => {\n            console.error('RPC error returned:', res.error);\n            _ecb(res);\n          });\n      }\n\n      function recognitionInitCb(recognitionId) {\n        self._connection._recognitionId = recognitionId;\n        console.log('Got recognitionId after initialisation: ' + self._connection._recognitionId);\n      }\n      self._connection.call('choice.init_recognition', [],\n        {\n          trimStart: trimAudioStart,\n          trimEnd: trimAudioEnd\n        })\n        .then(recognitionInitCb)\n        .then(() =>\n          self.choiceRecognitionInitChallenge(challenge)\n            .then(() => {\n              const p = new Promise(resolve_ => {\n                if (recorder.hasUserMediaApproval()) {\n                  resolve_();\n                } else {\n                  recorder.addEventListener('ready', resolve_);\n                }\n              });\n              p.then(() => {\n                self.choiceRecognitionInitAudio(recorder, dataavailableCb)\n                  .catch(reject);\n              });\n            })\n            .then(() => notify('ReadyToReceive'))\n        )\n        .catch(reject);\n\n      // Stop listening when the audio recorder stopped.\n      function recordedCb() {\n        // When done, submit any plain text (non-JSON) to start analysing.\n        self._connection.call('choice.recognise',\n          [self._connection._recognitionId]).then(\n          // RPC success callback\n          res => {\n            // Wait for analysis results to come back.\n            _cb(res);\n          },\n          // RPC error callback\n          res => {\n            console.error('RPC error returned:', res.error);\n            if (res.error === 'nl.itslanguage.recognition_failed') {\n              res.kwargs.recognition.message = 'Recognition failed';\n            } else {\n              res.kwargs.recognition.message = 'Unhandled error';\n            }\n            _ecb(res.kwargs.analysis);\n          });\n\n        recorder.removeEventListener('recorded', recordedCb);\n        recorder.removeEventListener('dataavailable', dataavailableCb);\n      }\n      recorder.addEventListener('recorded', recordedCb);\n    })\n      .then(res => {\n        self._connection._recognitionId = null;\n        return Promise.resolve(res);\n      })\n      .catch(error => {\n        self._connection._recognitionId = null;\n        Connection.logRPCError(error);\n        return Promise.reject(error);\n      });\n  }\n\n  /**\n   * Get a choice recognition in a choice challenge from the current active {@link Organisation} derived from\n   * the OAuth2 scope.\n   *\n   * @param {string} challengeId - Specify a choice challenge identifier.\n   * @param {string} recognitionId - Specify a choice recognition identifier.\n   * @returns {Promise.<ChoiceRecognition>} Promise containing a ChoiceRecognition.\n   * @throws {Promise.<Error>} challengeId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} recognitionId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getChoiceRecognition(challengeId, recognitionId) {\n    if (typeof challengeId !== 'string') {\n      return Promise.reject(new Error('challengeId parameter of type \"string\" is required'));\n    }\n\n    if (typeof recognitionId !== 'string') {\n      return Promise.reject(new Error('recognitionId parameter of type \"string\" is required'));\n    }\n    const url = this._connection._settings.apiUrl + '/challenges/choice/' +\n      challengeId + '/recognitions/' + recognitionId;\n\n    return this._connection._secureAjaxGet(url)\n      .then(datum => new ChoiceRecognition(challengeId, datum.userId,\n        datum.id, new Date(datum.created), new Date(datum.updated),\n        datum.audioUrl, datum.recognised));\n  }\n\n  /**\n   * Get and return all choice recognitions in a specific {@link ChoiceChallenge} from the current active\n   * {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {string} challengeId - Specify a choice challenge to list speech recognitions for.\n   * @returns {Promise.<ChoiceRecognition[]>} Promise containing an array of ChoiceRecognitions.\n   * @throws {Promise.<Error>} challengeId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getChoiceRecognitions(challengeId) {\n    if (typeof challengeId !== 'string') {\n      return Promise.reject(new Error('challengeId parameter of type \"string\" is required'));\n    }\n    const url = this._connection._settings.apiUrl + '/challenges/choice/' +\n      challengeId + '/recognitions';\n    return this._connection._secureAjaxGet(url)\n      .then(data => data.map(datum => {\n        const recognition = new ChoiceRecognition(challengeId, datum.userId,\n          datum.id, new Date(datum.created), new Date(datum.updated),\n          datum.audioUrl, datum.recognised);\n        return recognition;\n      }));\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/choice-recognition/choice-recognition-controller.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 203,
    "kind": "class",
    "name": "ChoiceRecognitionController",
    "memberof": "src/administrative-sdk/choice-recognition/choice-recognition-controller.js",
    "static": true,
    "longname": "src/administrative-sdk/choice-recognition/choice-recognition-controller.js~ChoiceRecognitionController",
    "access": "private",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/choice-recognition/choice-recognition-controller.js",
    "importStyle": "ChoiceRecognitionController",
    "description": "Controller class for the ChoiceRecognition model.",
    "lineNumber": 10,
    "interface": false
  },
  {
    "__docId__": 204,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/choice-recognition/choice-recognition-controller.js~ChoiceRecognitionController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/choice-recognition/choice-recognition-controller.js~ChoiceRecognitionController#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "Connection"
        ],
        "spread": false,
        "optional": false,
        "name": "connection",
        "description": "Object to use for making a connection to the REST API and Websocket server."
      }
    ]
  },
  {
    "__docId__": 205,
    "kind": "member",
    "name": "_connection",
    "memberof": "src/administrative-sdk/choice-recognition/choice-recognition-controller.js~ChoiceRecognitionController",
    "static": false,
    "longname": "src/administrative-sdk/choice-recognition/choice-recognition-controller.js~ChoiceRecognitionController#_connection",
    "access": "private",
    "description": "Object to use for making a connection to the REST API and Websocket server.",
    "lineNumber": 19,
    "type": {
      "nullable": null,
      "types": [
        "Connection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 206,
    "kind": "method",
    "name": "choiceRecognitionInitChallenge",
    "memberof": "src/administrative-sdk/choice-recognition/choice-recognition-controller.js~ChoiceRecognitionController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/choice-recognition/choice-recognition-controller.js~ChoiceRecognitionController#choiceRecognitionInitChallenge",
    "access": "private",
    "description": "Initialise the choice recognition challenge through RPCs.",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "ChoiceChallenge"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "ChoiceChallenge."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 207,
    "kind": "method",
    "name": "choiceRecognitionInitAudio",
    "memberof": "src/administrative-sdk/choice-recognition/choice-recognition-controller.js~ChoiceRecognitionController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/choice-recognition/choice-recognition-controller.js~ChoiceRecognitionController#choiceRecognitionInitAudio",
    "access": "private",
    "description": "Initialise the pronunciation analysis audio specs through RPCs.",
    "lineNumber": 46,
    "params": [
      {
        "nullable": null,
        "types": [
          "AudioRecorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "AudioRecorder."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "dataavailableCb",
        "description": "Callback."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 208,
    "kind": "method",
    "name": "startStreamingChoiceRecognition",
    "memberof": "src/administrative-sdk/choice-recognition/choice-recognition-controller.js~ChoiceRecognitionController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/choice-recognition/choice-recognition-controller.js~ChoiceRecognitionController#startStreamingChoiceRecognition",
    "access": "public",
    "description": "Start a choice recognition from streaming audio.",
    "lineNumber": 77,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<ChoiceRecognition>} A {@link https://github.com/cujojs/when} Promise containing a {@link ChoiceRecognition}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "ChoiceChallenge"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "The choice challenge to perform."
      },
      {
        "nullable": null,
        "types": [
          "AudioRecorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "The audio recorder to extract audio from."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "trim",
        "description": "Whether to trim the start and end of recorded audio."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<ChoiceRecognition>"
      ],
      "spread": false,
      "description": "A {@link https://github.com/cujojs/when} Promise containing a {@link ChoiceRecognition}."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "challenge parameter of type \"ChoiceChallenge\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "challenge.id field of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the connection is not open."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the recorder is already recording."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If a recognition session is already in progress."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If something went wrong during analysis."
      }
    ],
    "emits": [
      {
        "types": [
          "string"
        ],
        "description": "'ReadyToReceive' when the call is made to receive audio. The recorder can now send audio."
      }
    ]
  },
  {
    "__docId__": 209,
    "kind": "method",
    "name": "getChoiceRecognition",
    "memberof": "src/administrative-sdk/choice-recognition/choice-recognition-controller.js~ChoiceRecognitionController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/choice-recognition/choice-recognition-controller.js~ChoiceRecognitionController#getChoiceRecognition",
    "access": "public",
    "description": "Get a choice recognition in a choice challenge from the current active {@link Organisation} derived from\nthe OAuth2 scope.",
    "lineNumber": 222,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<ChoiceRecognition>} Promise containing a ChoiceRecognition."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "Specify a choice challenge identifier."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "recognitionId",
        "description": "Specify a choice recognition identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<ChoiceRecognition>"
      ],
      "spread": false,
      "description": "Promise containing a ChoiceRecognition."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "challengeId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "recognitionId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 210,
    "kind": "method",
    "name": "getChoiceRecognitions",
    "memberof": "src/administrative-sdk/choice-recognition/choice-recognition-controller.js~ChoiceRecognitionController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/choice-recognition/choice-recognition-controller.js~ChoiceRecognitionController#getChoiceRecognitions",
    "access": "public",
    "description": "Get and return all choice recognitions in a specific {@link ChoiceChallenge} from the current active\n{@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 248,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<ChoiceRecognition[]>} Promise containing an array of ChoiceRecognitions."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "Specify a choice challenge to list speech recognitions for."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<ChoiceRecognition[]>"
      ],
      "spread": false,
      "description": "Promise containing an array of ChoiceRecognitions."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "challengeId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 211,
    "kind": "file",
    "name": "src/administrative-sdk/choice-recognition/choice-recognition.js",
    "content": "/**\n * ChoiceRecognition domain model.\n */\nexport default class ChoiceRecognition {\n  /**\n   * Create a choice recognition domain model.\n   *\n   * @param {string} challengeId - The {@link ChoiceChallenge} identifier.\n   * @param {string} userId - The {@link User} identifier on whose behalf this audio is uploaded.\n   * @param {string} id - The {@link ChoiceRecognition} identifier.\n   * @param {Date} created - The creation date of the entity.\n   * @param {Date} updated - The most recent update date of the entity.\n   * @param {string} audioUrl - The audio fragment as streaming audio link.\n   * @param {string} recognised - The recognised sentence.\n   */\n  constructor(challengeId, userId, id, created, updated, audioUrl, recognised) {\n    /**\n     *\n     * @type {string}\n     */\n    this.id = id;\n\n    /**\n     *\n     * @type {string}\n     */\n    this.challengeId = challengeId;\n\n    /**\n     *\n     * @type {string}\n     */\n    this.userId = userId;\n\n    /**\n     *\n     * @type {Date}\n     */\n    this.created = created;\n\n    /**\n     *\n     * @type {Date}\n     */\n    this.updated = updated;\n\n    /**\n     *\n     * @type {string}\n     */\n    this.audioUrl = audioUrl;\n\n    /**\n     *\n     * @type {string}\n     */\n    this.recognised = recognised;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/choice-recognition/choice-recognition.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 212,
    "kind": "class",
    "name": "ChoiceRecognition",
    "memberof": "src/administrative-sdk/choice-recognition/choice-recognition.js",
    "static": true,
    "longname": "src/administrative-sdk/choice-recognition/choice-recognition.js~ChoiceRecognition",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/choice-recognition/choice-recognition.js",
    "importStyle": "ChoiceRecognition",
    "description": "ChoiceRecognition domain model.",
    "lineNumber": 4,
    "interface": false
  },
  {
    "__docId__": 213,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/choice-recognition/choice-recognition.js~ChoiceRecognition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/choice-recognition/choice-recognition.js~ChoiceRecognition#constructor",
    "access": "public",
    "description": "Create a choice recognition domain model.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "The {@link ChoiceChallenge} identifier."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": "The {@link User} identifier on whose behalf this audio is uploaded."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The {@link ChoiceRecognition} identifier."
      },
      {
        "nullable": null,
        "types": [
          "Date"
        ],
        "spread": false,
        "optional": false,
        "name": "created",
        "description": "The creation date of the entity."
      },
      {
        "nullable": null,
        "types": [
          "Date"
        ],
        "spread": false,
        "optional": false,
        "name": "updated",
        "description": "The most recent update date of the entity."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "audioUrl",
        "description": "The audio fragment as streaming audio link."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "recognised",
        "description": "The recognised sentence."
      }
    ]
  },
  {
    "__docId__": 214,
    "kind": "member",
    "name": "id",
    "memberof": "src/administrative-sdk/choice-recognition/choice-recognition.js~ChoiceRecognition",
    "static": false,
    "longname": "src/administrative-sdk/choice-recognition/choice-recognition.js~ChoiceRecognition#id",
    "access": "public",
    "description": "",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 215,
    "kind": "member",
    "name": "challengeId",
    "memberof": "src/administrative-sdk/choice-recognition/choice-recognition.js~ChoiceRecognition",
    "static": false,
    "longname": "src/administrative-sdk/choice-recognition/choice-recognition.js~ChoiceRecognition#challengeId",
    "access": "public",
    "description": "",
    "lineNumber": 27,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 216,
    "kind": "member",
    "name": "userId",
    "memberof": "src/administrative-sdk/choice-recognition/choice-recognition.js~ChoiceRecognition",
    "static": false,
    "longname": "src/administrative-sdk/choice-recognition/choice-recognition.js~ChoiceRecognition#userId",
    "access": "public",
    "description": "",
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 217,
    "kind": "member",
    "name": "created",
    "memberof": "src/administrative-sdk/choice-recognition/choice-recognition.js~ChoiceRecognition",
    "static": false,
    "longname": "src/administrative-sdk/choice-recognition/choice-recognition.js~ChoiceRecognition#created",
    "access": "public",
    "description": "",
    "lineNumber": 39,
    "type": {
      "nullable": null,
      "types": [
        "Date"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 218,
    "kind": "member",
    "name": "updated",
    "memberof": "src/administrative-sdk/choice-recognition/choice-recognition.js~ChoiceRecognition",
    "static": false,
    "longname": "src/administrative-sdk/choice-recognition/choice-recognition.js~ChoiceRecognition#updated",
    "access": "public",
    "description": "",
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "Date"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 219,
    "kind": "member",
    "name": "audioUrl",
    "memberof": "src/administrative-sdk/choice-recognition/choice-recognition.js~ChoiceRecognition",
    "static": false,
    "longname": "src/administrative-sdk/choice-recognition/choice-recognition.js~ChoiceRecognition#audioUrl",
    "access": "public",
    "description": "",
    "lineNumber": 51,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 220,
    "kind": "member",
    "name": "recognised",
    "memberof": "src/administrative-sdk/choice-recognition/choice-recognition.js~ChoiceRecognition",
    "static": false,
    "longname": "src/administrative-sdk/choice-recognition/choice-recognition.js~ChoiceRecognition#recognised",
    "access": "public",
    "description": "",
    "lineNumber": 57,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 221,
    "kind": "file",
    "name": "src/administrative-sdk/connection/connection-controller.js",
    "content": "/* eslint-disable\ncamelcase\n */\n\nimport {authorisedRequest, request, updateSettings} from '../../api/communication';\n\nimport autobahn from 'autobahn';\nimport ee from 'event-emitter';\n/**\n * Controller class for managing connection interaction.\n */\nexport default class Connection {\n  /**\n   *\n   * @param {Object} options - Options to configure the connection with.\n   * Valid options include:\n   * * apiUrl - The URL of the REST api.\n   * * wsUrl - The URL of the Websocket server.\n   * * oAuth2Token - An OAuth2 token string.\n   * * adminPrincipal - The username of the admin account.\n   * * adminPassword - The password of the admin account.\n   */\n  constructor(options = {}) {\n    /**\n     * @type {Object}\n     */\n    this._settings = Object.assign({\n      // ITSL connection parameters.\n      apiUrl: 'https://api.itslanguage.nl',\n      oAuth2Token: null,\n      wsUrl: null,\n      wsToken: null\n    }, options);\n    Connection._sdkCompatibility();\n    this._analysisId = null;\n    this._recordingId = null;\n    this._recognitionId = null;\n    this._emitter = ee({});\n    this._connection = null;\n\n    // Use the new connection file for future requests.\n    updateSettings(Object.assign({}, options, {authorizationToken: options.oAuth2Token}));\n  }\n\n  /**\n   * Add an event listener. Listens to events emitted from the websocket server connection.\n   *\n   * @param {string} name - Name of the event.\n   * @param {Function} handler - Handler function to add.\n   */\n  addEventListener(name, handler) {\n    this._emitter.on(name, handler);\n  }\n\n  /**\n   * Remove an event listener of the websocket connection.\n   *\n   * @param {string} name - Name of the event.\n   * @param {Function} handler - Handler function to remove.\n   */\n  removeEventListener(name, handler) {\n    this._emitter.off(name, handler);\n  }\n\n  /**\n   * Fire an event.\n   *\n   * @param {string} name - Name of the event.\n   * @param {[]} args - Arguments.\n   * @private\n   */\n  fireEvent(name, args = []) {\n    this._emitter.emit(name, ...args);\n  }\n\n  /**\n   * Create a connection to the websocket server.\n   *\n   */\n  webSocketConnect() {\n    const self = this;\n    /**\n     * This callback is fired during Ticket-based authentication.\n     *\n     * @param {Session} session - Session.\n     * @param {string} method - Authentication method.\n     */\n    function onOAuth2Challenge(session, method) {\n      if (method === 'ticket') {\n        return self._settings.oAuth2Token;\n      }\n      throw new Error(`don't know how to authenticate using '${method}'`);\n    }\n\n    const authUrl = this._settings.wsUrl;\n    let connection = null;\n    // Open a websocket connection for streaming audio\n    try {\n      // Set up WAMP connection to router\n      connection = new autobahn.Connection({\n        url: authUrl,\n        realm: 'default',\n        // the following attributes must be set for Ticket-based authentication\n        authmethods: ['ticket'],\n        authid: 'oauth2',\n        details: {\n          ticket: this._settings.oAuth2Token\n        },\n        onchallenge: onOAuth2Challenge\n      });\n    } catch (e) {\n      console.log('WebSocket creation error: ' + e);\n      return;\n    }\n    connection.onerror = function(e) {\n      console.log('WebSocket error: ' + e);\n      self.fireEvent('websocketError', [e]);\n    };\n    connection.onopen = function(session) {\n      console.log('WebSocket connection opened');\n      self._session = session;\n      self.fireEvent('websocketOpened');\n    };\n    connection.onclose = function() {\n      console.log('WebSocket disconnected');\n      self._session = null;\n      self.fireEvent('websocketClosed');\n    };\n    this._connection = connection;\n    this._connection.open();\n  }\n\n  /**\n   * Make an RPC to active current session.\n   *\n   * @param {string} rpc - The RPC to call. It will be prefixed with `'nl.itslanguage.'`.\n   * @param {...any} args - Any arguments to pass to the RPC.\n   * @return {Promise} The result of the call.\n   */\n  call(rpc, ...args) {\n    const url = 'nl.itslanguage.' + rpc;\n    console.debug('Calling RPC:', url);\n    return this._session.call(url, ...args);\n  }\n\n  webSocketDisconnect() {\n    this._connection.close(null, 'Requested formal disconnect');\n  }\n\n  /**\n   * Perform a HTTP GET to the API using authentication.\n   *\n   * @param {string} url - Url to retrieve.\n   * @returns {Promise} Promise containing a result.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  _secureAjaxGet(url) {\n    return authorisedRequest('GET', url);\n  }\n\n  /**\n   * Perform a HTTP POST to the API using authentication.\n   *\n   * @param {string} url - Url to submit to.\n   * @param {FormData} formdata - The form to POST.\n   * @returns {Promise} Promise containing a result.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  _secureAjaxPost(url, formdata) {\n    return authorisedRequest('POST', url, formdata);\n  }\n\n  /**\n   * Perform a HTTP DELETE to the API using authentication.\n   *\n   * @param {string} url - Url to submit to.\n   * @returns {Promise} Promise containing a result.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  _secureAjaxDelete(url) {\n    return authorisedRequest('DELETE', url);\n  }\n\n  /**\n   * Add an access token to the given URL.\n   *\n   * @param {string} url - The URL to add an access token to.\n   * @returns {string} An url with the access token appended.\n   */\n  addAccessToken(url) {\n    if (!this._settings.oAuth2Token) {\n      throw new Error('Please set oAuth2Token');\n    }\n    const secureUrl = url + (url.match(/\\?/) ? '&' : '?') + 'access_token=' +\n      encodeURIComponent(this._settings.oAuth2Token);\n    return secureUrl;\n  }\n\n  /**\n   * Logs browser compatibility for required and optional SDK capabilities.\n   *\n   * @throws {Error} In case of compatibility issues.\n   */\n  static _sdkCompatibility() {\n    // WebSocket\n    // http://caniuse.com/#feat=websockets\n    if (!('WebSocket' in window)) {\n      throw new Error('No WebSocket capabilities');\n    }\n  }\n\n  /**\n   * Cancel any current streaming audio recording.\n   *\n   * @param {AudioRecorder} recorder - The audio recorder currently recording.\n   */\n  cancelStreaming(recorder) {\n    const self = this;\n\n    if (this._recordingId === null && this._analysisId === null && this._recognitionId === null) {\n      console.info('No session in progress, nothing to cancel.');\n      return;\n    }\n\n    recorder.removeAllEventListeners();\n    if (recorder.isRecording()) {\n      recorder.stop();\n    }\n\n    // This session is over.\n    self._recordingId = null;\n    self._analysisId = null;\n    self._recognitionId = null;\n  }\n\n  /**\n   * Log an error caught from an RPC call.\n   *\n   * @param {Object} result - Error object.\n   */\n  static logRPCError(result) {\n    console.error('RPC error returned:', result.error);\n  }\n\n  /**\n   * Ask the server for an OAuth2 token.\n   *\n   * @param {BasicAuth} basicAuth - Basic Auth to obtain credentials from.\n   * @param {string} [scope] - The scope which should be availible for the requested token.\n   * @returns {Promise} Promise containing a access_token, token_type and scope.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  getOauth2Token(basicAuth, scope) {\n    const body = new URLSearchParams();\n    body.append('grant_type', 'password');\n    body.append('username', basicAuth.principal);\n    body.append('password', basicAuth.credentials);\n\n    if (scope) {\n      body.append('scope', scope);\n    }\n\n    return request('POST', '/tokens', body).then(response => {\n      this._settings.oAuth2Token = response.access_token;\n      updateSettings({authorizationToken: response.access_token});\n      return response;\n    });\n  }\n\n  /**\n   * Request authentication for a {@link User}. The basicAuth now contains the user's username and password.\n   *\n   * This method also generates the appropriate scope for the given params.\n   *\n   * @param {BasicAuth} basicAuth - Basic Auth to obtain credentials from.\n   * @param {string} organisationId - Id of the organisation this user is part of.\n   */\n  getUserAuth(basicAuth, organisationId) {\n    let scopes = 'tenant/' + basicAuth.tenantId;\n    if (organisationId) {\n      scopes += '/organisation/' + organisationId;\n      if (basicAuth.principal) {\n        scopes += '/user/' + basicAuth.principal;\n      }\n    }\n\n    return this.getOauth2Token(basicAuth, scopes);\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/connection/connection-controller.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 222,
    "kind": "class",
    "name": "Connection",
    "memberof": "src/administrative-sdk/connection/connection-controller.js",
    "static": true,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/connection/connection-controller.js",
    "importStyle": "Connection",
    "description": "Controller class for managing connection interaction.",
    "lineNumber": 12,
    "interface": false
  },
  {
    "__docId__": 223,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Options to configure the connection with.\nValid options include:\n* apiUrl - The URL of the REST api.\n* wsUrl - The URL of the Websocket server.\n* oAuth2Token - An OAuth2 token string.\n* adminPrincipal - The username of the admin account.\n* adminPassword - The password of the admin account."
      }
    ]
  },
  {
    "__docId__": 224,
    "kind": "member",
    "name": "_settings",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#_settings",
    "access": "private",
    "description": "",
    "lineNumber": 27,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 225,
    "kind": "member",
    "name": "_analysisId",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#_analysisId",
    "access": "private",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 226,
    "kind": "member",
    "name": "_recordingId",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#_recordingId",
    "access": "private",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 227,
    "kind": "member",
    "name": "_recognitionId",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#_recognitionId",
    "access": "private",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 228,
    "kind": "member",
    "name": "_emitter",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#_emitter",
    "access": "private",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 229,
    "kind": "member",
    "name": "_connection",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#_connection",
    "access": "private",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 230,
    "kind": "method",
    "name": "addEventListener",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#addEventListener",
    "access": "public",
    "description": "Add an event listener. Listens to events emitted from the websocket server connection.",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of the event."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "handler",
        "description": "Handler function to add."
      }
    ],
    "return": null
  },
  {
    "__docId__": 231,
    "kind": "method",
    "name": "removeEventListener",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#removeEventListener",
    "access": "public",
    "description": "Remove an event listener of the websocket connection.",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of the event."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "handler",
        "description": "Handler function to remove."
      }
    ],
    "return": null
  },
  {
    "__docId__": 232,
    "kind": "method",
    "name": "fireEvent",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#fireEvent",
    "access": "private",
    "description": "Fire an event.",
    "lineNumber": 72,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of the event."
      },
      {
        "nullable": null,
        "types": [
          "[]"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": "Arguments."
      }
    ],
    "return": null
  },
  {
    "__docId__": 233,
    "kind": "method",
    "name": "webSocketConnect",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#webSocketConnect",
    "access": "public",
    "description": "Create a connection to the websocket server.",
    "lineNumber": 80,
    "params": [],
    "return": null
  },
  {
    "__docId__": 235,
    "kind": "method",
    "name": "call",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#call",
    "access": "public",
    "description": "Make an RPC to active current session.",
    "lineNumber": 140,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rpc",
        "description": "The RPC to call. It will be prefixed with `'nl.itslanguage.'`."
      },
      {
        "nullable": null,
        "types": [
          "...any"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Any arguments to pass to the RPC."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The result of the call."
    }
  },
  {
    "__docId__": 236,
    "kind": "method",
    "name": "webSocketDisconnect",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#webSocketDisconnect",
    "access": "public",
    "description": null,
    "lineNumber": 146,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 237,
    "kind": "method",
    "name": "_secureAjaxGet",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#_secureAjaxGet",
    "access": "private",
    "description": "Perform a HTTP GET to the API using authentication.",
    "lineNumber": 157,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} Promise containing a result."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "Url to retrieve."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise containing a result."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 238,
    "kind": "method",
    "name": "_secureAjaxPost",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#_secureAjaxPost",
    "access": "private",
    "description": "Perform a HTTP POST to the API using authentication.",
    "lineNumber": 169,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} Promise containing a result."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "Url to submit to."
      },
      {
        "nullable": null,
        "types": [
          "FormData"
        ],
        "spread": false,
        "optional": false,
        "name": "formdata",
        "description": "The form to POST."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise containing a result."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 239,
    "kind": "method",
    "name": "_secureAjaxDelete",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#_secureAjaxDelete",
    "access": "private",
    "description": "Perform a HTTP DELETE to the API using authentication.",
    "lineNumber": 180,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} Promise containing a result."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "Url to submit to."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise containing a result."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 240,
    "kind": "method",
    "name": "addAccessToken",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#addAccessToken",
    "access": "public",
    "description": "Add an access token to the given URL.",
    "lineNumber": 190,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} An url with the access token appended."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "The URL to add an access token to."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "An url with the access token appended."
    }
  },
  {
    "__docId__": 241,
    "kind": "method",
    "name": "_sdkCompatibility",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection._sdkCompatibility",
    "access": "private",
    "description": "Logs browser compatibility for required and optional SDK capabilities.",
    "lineNumber": 204,
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "In case of compatibility issues."
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 242,
    "kind": "method",
    "name": "cancelStreaming",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#cancelStreaming",
    "access": "public",
    "description": "Cancel any current streaming audio recording.",
    "lineNumber": 217,
    "params": [
      {
        "nullable": null,
        "types": [
          "AudioRecorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "The audio recorder currently recording."
      }
    ],
    "return": null
  },
  {
    "__docId__": 243,
    "kind": "method",
    "name": "logRPCError",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection.logRPCError",
    "access": "public",
    "description": "Log an error caught from an RPC call.",
    "lineNumber": 241,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "result",
        "description": "Error object."
      }
    ],
    "return": null
  },
  {
    "__docId__": 244,
    "kind": "method",
    "name": "getOauth2Token",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#getOauth2Token",
    "access": "public",
    "description": "Ask the server for an OAuth2 token.",
    "lineNumber": 253,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} Promise containing a access_token, token_type and scope."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicAuth"
        ],
        "spread": false,
        "optional": false,
        "name": "basicAuth",
        "description": "Basic Auth to obtain credentials from."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "scope",
        "description": "The scope which should be availible for the requested token."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise containing a access_token, token_type and scope."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 245,
    "kind": "method",
    "name": "getUserAuth",
    "memberof": "src/administrative-sdk/connection/connection-controller.js~Connection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/connection/connection-controller.js~Connection#getUserAuth",
    "access": "public",
    "description": "Request authentication for a {@link User}. The basicAuth now contains the user's username and password.\n\nThis method also generates the appropriate scope for the given params.",
    "lineNumber": 278,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicAuth"
        ],
        "spread": false,
        "optional": false,
        "name": "basicAuth",
        "description": "Basic Auth to obtain credentials from."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "organisationId",
        "description": "Id of the organisation this user is part of."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 246,
    "kind": "file",
    "name": "src/administrative-sdk/email-credentials/email-credentials-controller.js",
    "content": "import EmailCredentials from './email-credentials';\n\n/**\n * Controller class for the Email Credentials model.\n * @private\n */\nexport default class EmailCredentialsController {\n  /**\n   * @param {Connection} connection - Object to use for making a connection to the REST API and Websocket server.\n   */\n  constructor(connection) {\n    /**\n     * Object to use for making a connection to the REST API and Websocket server.\n     * @type {Connection}\n     */\n    this._connection = connection;\n  }\n\n  /**\n   * Register credentials to the given user. Multiple credentials can be registered to one user.\n   *\n   * @param {string} userId - The identifier of the user to register credentials to.\n   * @param {EmailCredentials} emailCredentials - The credentials to register to the user.\n   * @returns {Promise.<EmailCredentials>} A promise containing the created EmailCredentials.\n   * @throws {Promise.<Error>} userId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} emailCredentials parameter of type \"EmailCredentials\" is required.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  createEmailCredentials(userId, emailCredentials) {\n    if (typeof userId !== 'string') {\n      return Promise.reject(new Error('userId parameter of type \"string\" is required'));\n    }\n\n    if (!(emailCredentials instanceof EmailCredentials)) {\n      return Promise.reject(new Error('emailCredentials parameter of type \"EmailCredentials\" is required'));\n    }\n\n    const url = this._connection._settings.apiUrl + '/users/' + userId + '/emailauths';\n    const fd = JSON.stringify(emailCredentials);\n    return this._connection._secureAjaxPost(url, fd)\n      .then(data => {\n        const result = new EmailCredentials(data.email, data.password);\n        result.created = new Date(data.created);\n        result.updated = new Date(data.updated);\n        return result;\n      });\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/email-credentials/email-credentials-controller.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 247,
    "kind": "class",
    "name": "EmailCredentialsController",
    "memberof": "src/administrative-sdk/email-credentials/email-credentials-controller.js",
    "static": true,
    "longname": "src/administrative-sdk/email-credentials/email-credentials-controller.js~EmailCredentialsController",
    "access": "private",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/email-credentials/email-credentials-controller.js",
    "importStyle": "EmailCredentialsController",
    "description": "Controller class for the Email Credentials model.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 248,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/email-credentials/email-credentials-controller.js~EmailCredentialsController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/email-credentials/email-credentials-controller.js~EmailCredentialsController#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "Connection"
        ],
        "spread": false,
        "optional": false,
        "name": "connection",
        "description": "Object to use for making a connection to the REST API and Websocket server."
      }
    ]
  },
  {
    "__docId__": 249,
    "kind": "member",
    "name": "_connection",
    "memberof": "src/administrative-sdk/email-credentials/email-credentials-controller.js~EmailCredentialsController",
    "static": false,
    "longname": "src/administrative-sdk/email-credentials/email-credentials-controller.js~EmailCredentialsController#_connection",
    "access": "private",
    "description": "Object to use for making a connection to the REST API and Websocket server.",
    "lineNumber": 16,
    "type": {
      "nullable": null,
      "types": [
        "Connection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 250,
    "kind": "method",
    "name": "createEmailCredentials",
    "memberof": "src/administrative-sdk/email-credentials/email-credentials-controller.js~EmailCredentialsController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/email-credentials/email-credentials-controller.js~EmailCredentialsController#createEmailCredentials",
    "access": "public",
    "description": "Register credentials to the given user. Multiple credentials can be registered to one user.",
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<EmailCredentials>} A promise containing the created EmailCredentials."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": "The identifier of the user to register credentials to."
      },
      {
        "nullable": null,
        "types": [
          "EmailCredentials"
        ],
        "spread": false,
        "optional": false,
        "name": "emailCredentials",
        "description": "The credentials to register to the user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<EmailCredentials>"
      ],
      "spread": false,
      "description": "A promise containing the created EmailCredentials."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "userId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "emailCredentials parameter of type \"EmailCredentials\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 251,
    "kind": "file",
    "name": "src/administrative-sdk/email-credentials/email-credentials.js",
    "content": "/**\n * Users can have email based credentials.\n * These credentials can be managed using the REST API. Only users with administrative powers can perform these calls.\n */\nexport default class EmailCredentials {\n  /**\n   * Create an EmailCredentials object.\n   *\n   * @param {string} email - A unique email address.\n   * @param {?string} password - A secure password, if none is given, one will be generated.\n   * @throws {Error} email parameter of type \"string\" is required.\n   * @throws {Error} password parameter of type \"string|null\" is required\n   */\n  constructor(email, password = null) {\n    if (typeof email !== 'string') {\n      throw new Error('email parameter of type \"string\" is required');\n    }\n\n    if (password !== null && typeof password !== 'string') {\n      throw new Error('password parameter of type \"string|null\" is required');\n    }\n\n    /**\n     * @type {string} A unique email address.\n     */\n    this.email = email;\n\n    /**\n     * @type {string} A secure password, if none is given, one will be generated.\n     */\n    this.password = password;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/email-credentials/email-credentials.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 252,
    "kind": "class",
    "name": "EmailCredentials",
    "memberof": "src/administrative-sdk/email-credentials/email-credentials.js",
    "static": true,
    "longname": "src/administrative-sdk/email-credentials/email-credentials.js~EmailCredentials",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/email-credentials/email-credentials.js",
    "importStyle": "EmailCredentials",
    "description": "Users can have email based credentials.\nThese credentials can be managed using the REST API. Only users with administrative powers can perform these calls.",
    "lineNumber": 5,
    "interface": false
  },
  {
    "__docId__": 253,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/email-credentials/email-credentials.js~EmailCredentials",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/email-credentials/email-credentials.js~EmailCredentials#constructor",
    "access": "public",
    "description": "Create an EmailCredentials object.",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "email",
        "description": "A unique email address."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "password",
        "description": "A secure password, if none is given, one will be generated."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "email parameter of type \"string\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "password parameter of type \"string|null\" is required"
      }
    ]
  },
  {
    "__docId__": 254,
    "kind": "member",
    "name": "email",
    "memberof": "src/administrative-sdk/email-credentials/email-credentials.js~EmailCredentials",
    "static": false,
    "longname": "src/administrative-sdk/email-credentials/email-credentials.js~EmailCredentials#email",
    "access": "public",
    "description": "",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 255,
    "kind": "member",
    "name": "password",
    "memberof": "src/administrative-sdk/email-credentials/email-credentials.js~EmailCredentials",
    "static": false,
    "longname": "src/administrative-sdk/email-credentials/email-credentials.js~EmailCredentials#password",
    "access": "public",
    "description": "",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 256,
    "kind": "file",
    "name": "src/administrative-sdk/group/group-controller.js",
    "content": "import Group from './group';\n\n/**\n * Controller class for the Group model.\n * @private\n */\nexport default class GroupController {\n  /**\n   * @param {Connection} connection - Object to use for making a connection to the REST API and Websocket server.\n   */\n  constructor(connection) {\n    /**\n     * Object to use for making a connection to the REST API and Websocket server.\n     * @type {Connection}\n     */\n    this._connection = connection;\n  }\n\n  /**\n   * Create a group. The group will be part of the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {Organisation} group - Object to create.\n   * @returns {Promise.<Group>} Promise containing the newly created Group.\n   * @throws {Promise.<Error>} organisation parameter of type \"Group\" is required.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  createGroup(group) {\n    if (!(group instanceof Group)) {\n      return Promise.reject(new Error('group parameter of type \"Group\" is required'));\n    }\n    const url = this._connection._settings.apiUrl + '/groups';\n    const fd = JSON.stringify(group);\n\n    return this._connection._secureAjaxPost(url, fd)\n      .then(data => {\n        const result = new Group(data.id, data.name);\n        result.created = new Date(data.created);\n        result.updated = new Date(data.updated);\n        return result;\n      });\n  }\n\n  /**\n   * Get a group which is part of the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {string} groupId - Specify a group identifier.\n   * @returns {Promise.<Group>} Promise containing an Group.\n   * @throws {Promise.<Error>} groupId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getGroup(groupId) {\n    if (typeof groupId !== 'string') {\n      return Promise.reject(new Error('groupId parameter of type \"string\" is required'));\n    }\n    const url = this._connection._settings.apiUrl + '/groups/' + groupId;\n\n    return this._connection._secureAjaxGet(url)\n      .then(data => {\n        const organisation = new Group(data.id, data.name);\n        organisation.created = new Date(data.created);\n        organisation.updated = new Date(data.updated);\n        return organisation;\n      });\n  }\n\n  /**\n   * Get and return all groups in the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @returns {Promise.<Group[]>} Promise containing an array of Groups.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getGroups() {\n    const url = this._connection._settings.apiUrl + '/groups';\n\n    return this._connection._secureAjaxGet(url)\n      .then(data => {\n        const groups = [];\n        data.forEach(datum => {\n          const group = new Group(datum.id, datum.name);\n          group.created = new Date(datum.created);\n          group.updated = new Date(datum.updated);\n          groups.push(group);\n        });\n        return groups;\n      });\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/group/group-controller.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 257,
    "kind": "class",
    "name": "GroupController",
    "memberof": "src/administrative-sdk/group/group-controller.js",
    "static": true,
    "longname": "src/administrative-sdk/group/group-controller.js~GroupController",
    "access": "private",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/group/group-controller.js",
    "importStyle": "GroupController",
    "description": "Controller class for the Group model.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 258,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/group/group-controller.js~GroupController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/group/group-controller.js~GroupController#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "Connection"
        ],
        "spread": false,
        "optional": false,
        "name": "connection",
        "description": "Object to use for making a connection to the REST API and Websocket server."
      }
    ]
  },
  {
    "__docId__": 259,
    "kind": "member",
    "name": "_connection",
    "memberof": "src/administrative-sdk/group/group-controller.js~GroupController",
    "static": false,
    "longname": "src/administrative-sdk/group/group-controller.js~GroupController#_connection",
    "access": "private",
    "description": "Object to use for making a connection to the REST API and Websocket server.",
    "lineNumber": 16,
    "type": {
      "nullable": null,
      "types": [
        "Connection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 260,
    "kind": "method",
    "name": "createGroup",
    "memberof": "src/administrative-sdk/group/group-controller.js~GroupController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/group/group-controller.js~GroupController#createGroup",
    "access": "public",
    "description": "Create a group. The group will be part of the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Group>} Promise containing the newly created Group."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Organisation"
        ],
        "spread": false,
        "optional": false,
        "name": "group",
        "description": "Object to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Group>"
      ],
      "spread": false,
      "description": "Promise containing the newly created Group."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "organisation parameter of type \"Group\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 261,
    "kind": "method",
    "name": "getGroup",
    "memberof": "src/administrative-sdk/group/group-controller.js~GroupController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/group/group-controller.js~GroupController#getGroup",
    "access": "public",
    "description": "Get a group which is part of the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 51,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Group>} Promise containing an Group."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "groupId",
        "description": "Specify a group identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Group>"
      ],
      "spread": false,
      "description": "Promise containing an Group."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "groupId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 262,
    "kind": "method",
    "name": "getGroups",
    "memberof": "src/administrative-sdk/group/group-controller.js~GroupController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/group/group-controller.js~GroupController#getGroups",
    "access": "public",
    "description": "Get and return all groups in the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 72,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Group[]>} Promise containing an array of Groups."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Group[]>"
      ],
      "spread": false,
      "description": "Promise containing an array of Groups."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ],
    "params": []
  },
  {
    "__docId__": 263,
    "kind": "file",
    "name": "src/administrative-sdk/group/group.js",
    "content": "/**\n * Group domain model. A {@link User} can be part of one or multiple groups\n */\nexport default class Group {\n  /**\n   * Create a group.\n   *\n   * @param {?string} id - The group identifier. If none is given, one is generated.\n   * @param {string} name - The name of the group.\n   * @throws {Error} id parameter of type \"string|null\" is required\n   * @throws {Error} name parameter of type \"string\" is required\n   */\n  constructor(id, name) {\n    if (id !== null && typeof id !== 'string') {\n      throw new Error('id parameter of type \"string|null\" is required');\n    }\n\n    if (typeof name !== 'string') {\n      throw new Error('name parameter of type \"string\" is required');\n    }\n\n    /**\n     * @type {string} The group identifier. If none is given, one is generated.\n     */\n    this.id = id;\n\n    /**\n     * @type {string} The name of the group.\n     */\n    this.name = name;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/group/group.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 264,
    "kind": "class",
    "name": "Group",
    "memberof": "src/administrative-sdk/group/group.js",
    "static": true,
    "longname": "src/administrative-sdk/group/group.js~Group",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/group/group.js",
    "importStyle": "Group",
    "description": "Group domain model. A {@link User} can be part of one or multiple groups",
    "lineNumber": 4,
    "interface": false
  },
  {
    "__docId__": 265,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/group/group.js~Group",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/group/group.js~Group#constructor",
    "access": "public",
    "description": "Create a group.",
    "lineNumber": 13,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The group identifier. If none is given, one is generated."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the group."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "id parameter of type \"string|null\" is required"
      },
      {
        "types": [
          "Error"
        ],
        "description": "name parameter of type \"string\" is required"
      }
    ]
  },
  {
    "__docId__": 266,
    "kind": "member",
    "name": "id",
    "memberof": "src/administrative-sdk/group/group.js~Group",
    "static": false,
    "longname": "src/administrative-sdk/group/group.js~Group#id",
    "access": "public",
    "description": "",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 267,
    "kind": "member",
    "name": "name",
    "memberof": "src/administrative-sdk/group/group.js~Group",
    "static": false,
    "longname": "src/administrative-sdk/group/group.js~Group#name",
    "access": "public",
    "description": "",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 268,
    "kind": "file",
    "name": "src/administrative-sdk/organisation/organisation-controller.js",
    "content": "import Organisation from './organisation';\n\n/**\n * Controller class for the Organisation model.\n * @private\n */\nexport default class OrganisationController {\n  /**\n   * @param {Connection} connection - Object to use for making a connection to the REST API and Websocket server.\n   */\n  constructor(connection) {\n    /**\n     * Object to use for making a connection to the REST API and Websocket server.\n     * @type {Connection}\n     */\n    this._connection = connection;\n  }\n\n  /**\n   * Create an organisation. The organisation will be owned by the current active tenant.\n   *\n   * @param {Organisation} organisation - Object to create.\n   * @returns {Promise.<Organisation>} Promise containing the newly created Organisation.\n   * @throws {Promise.<Error>} organisation parameter of type \"Organisation\" is required.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  createOrganisation(organisation) {\n    if (!(organisation instanceof Organisation)) {\n      return Promise.reject(new Error('organisation parameter of type \"Organisation\" is required'));\n    }\n    const url = this._connection._settings.apiUrl + '/organisations';\n    const fd = JSON.stringify(organisation);\n\n    return this._connection._secureAjaxPost(url, fd)\n      .then(data => {\n        const result = new Organisation(data.id, data.name);\n        result.created = new Date(data.created);\n        result.updated = new Date(data.updated);\n        return result;\n      });\n  }\n\n  /**\n   * Get an organisation the current tenant is the owner of.\n   *\n   * @param {string} organisationId - Specify an organisation identifier.\n   * @returns {Promise.<Organisation>} Promise containing an Organisation.\n   * @throws {Promise.<Error>} organisationId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getOrganisation(organisationId) {\n    if (typeof organisationId !== 'string') {\n      return Promise.reject(new Error('organisationId parameter of type \"string\" is required'));\n    }\n    const url = this._connection._settings.apiUrl + '/organisations/' + organisationId;\n\n    return this._connection._secureAjaxGet(url)\n      .then(data => {\n        const organisation = new Organisation(data.id, data.name);\n        organisation.created = new Date(data.created);\n        organisation.updated = new Date(data.updated);\n        return organisation;\n      });\n  }\n\n  /**\n   * Get and return all organisations the current tenant is the owner of.\n   *\n   * @returns {Promise.<Organisation[]>} Promise containing an array of Organisations.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getOrganisations() {\n    const url = this._connection._settings.apiUrl + '/organisations';\n\n    return this._connection._secureAjaxGet(url)\n      .then(data => data.map(datum => {\n        const organisation = new Organisation(datum.id, datum.name);\n        organisation.created = new Date(datum.created);\n        organisation.updated = new Date(datum.updated);\n        return organisation;\n      }));\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/organisation/organisation-controller.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 269,
    "kind": "class",
    "name": "OrganisationController",
    "memberof": "src/administrative-sdk/organisation/organisation-controller.js",
    "static": true,
    "longname": "src/administrative-sdk/organisation/organisation-controller.js~OrganisationController",
    "access": "private",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/organisation/organisation-controller.js",
    "importStyle": "OrganisationController",
    "description": "Controller class for the Organisation model.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 270,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/organisation/organisation-controller.js~OrganisationController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/organisation/organisation-controller.js~OrganisationController#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "Connection"
        ],
        "spread": false,
        "optional": false,
        "name": "connection",
        "description": "Object to use for making a connection to the REST API and Websocket server."
      }
    ]
  },
  {
    "__docId__": 271,
    "kind": "member",
    "name": "_connection",
    "memberof": "src/administrative-sdk/organisation/organisation-controller.js~OrganisationController",
    "static": false,
    "longname": "src/administrative-sdk/organisation/organisation-controller.js~OrganisationController#_connection",
    "access": "private",
    "description": "Object to use for making a connection to the REST API and Websocket server.",
    "lineNumber": 16,
    "type": {
      "nullable": null,
      "types": [
        "Connection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 272,
    "kind": "method",
    "name": "createOrganisation",
    "memberof": "src/administrative-sdk/organisation/organisation-controller.js~OrganisationController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/organisation/organisation-controller.js~OrganisationController#createOrganisation",
    "access": "public",
    "description": "Create an organisation. The organisation will be owned by the current active tenant.",
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Organisation>} Promise containing the newly created Organisation."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Organisation"
        ],
        "spread": false,
        "optional": false,
        "name": "organisation",
        "description": "Object to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Organisation>"
      ],
      "spread": false,
      "description": "Promise containing the newly created Organisation."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "organisation parameter of type \"Organisation\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 273,
    "kind": "method",
    "name": "getOrganisation",
    "memberof": "src/administrative-sdk/organisation/organisation-controller.js~OrganisationController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/organisation/organisation-controller.js~OrganisationController#getOrganisation",
    "access": "public",
    "description": "Get an organisation the current tenant is the owner of.",
    "lineNumber": 51,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Organisation>} Promise containing an Organisation."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "organisationId",
        "description": "Specify an organisation identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Organisation>"
      ],
      "spread": false,
      "description": "Promise containing an Organisation."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "organisationId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 274,
    "kind": "method",
    "name": "getOrganisations",
    "memberof": "src/administrative-sdk/organisation/organisation-controller.js~OrganisationController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/organisation/organisation-controller.js~OrganisationController#getOrganisations",
    "access": "public",
    "description": "Get and return all organisations the current tenant is the owner of.",
    "lineNumber": 72,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Organisation[]>} Promise containing an array of Organisations."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Organisation[]>"
      ],
      "spread": false,
      "description": "Promise containing an array of Organisations."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ],
    "params": []
  },
  {
    "__docId__": 275,
    "kind": "file",
    "name": "src/administrative-sdk/organisation/organisation.js",
    "content": "export default class Organisation {\n  /**\n   * Organisation domain model.\n   *\n   * @param {?string} id - The organisation identifier. If none is given, one is generated.\n   * @param {string} name - Name of the organisation.\n   */\n  constructor(id = null, name) {\n    if (id !== null && typeof id !== 'string') {\n      throw new Error('id parameter of type \"string|null\" is required');\n    }\n\n    if (typeof name !== 'string') {\n      throw new Error('name parameter of type \"string\" is required');\n    }\n\n    /**\n     * @type {string}\n     */\n    this.id = id;\n\n    /**\n     * @type {string}\n     */\n    this.name = name;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/organisation/organisation.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 276,
    "kind": "class",
    "name": "Organisation",
    "memberof": "src/administrative-sdk/organisation/organisation.js",
    "static": true,
    "longname": "src/administrative-sdk/organisation/organisation.js~Organisation",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/organisation/organisation.js",
    "importStyle": "Organisation",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 277,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/organisation/organisation.js~Organisation",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/organisation/organisation.js~Organisation#constructor",
    "access": "public",
    "description": "Organisation domain model.",
    "lineNumber": 8,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The organisation identifier. If none is given, one is generated."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of the organisation."
      }
    ]
  },
  {
    "__docId__": 278,
    "kind": "member",
    "name": "id",
    "memberof": "src/administrative-sdk/organisation/organisation.js~Organisation",
    "static": false,
    "longname": "src/administrative-sdk/organisation/organisation.js~Organisation#id",
    "access": "public",
    "description": "",
    "lineNumber": 20,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 279,
    "kind": "member",
    "name": "name",
    "memberof": "src/administrative-sdk/organisation/organisation.js~Organisation",
    "static": false,
    "longname": "src/administrative-sdk/organisation/organisation.js~Organisation#name",
    "access": "public",
    "description": "",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 280,
    "kind": "file",
    "name": "src/administrative-sdk/phoneme/phoneme.js",
    "content": "export default class Phoneme {\n  /**\n   * Create a phoneme domain model.\n   *\n   * @param {string} ipa - The pronunciation of the grapheme(s) indicated as International Phonetic Alphabet (IPA).\n   * @param {float} score - The audio is scored per phoneme and consists of several measurements. 0 would be bad,\n   * 1 the perfect score.\n   * @param {float} confidenceScore - This value provides a reliable prediction that the pronounced phoneme is\n   * actually the phoneme that is supposed to be pronounced. There is no absolute scale defined yet.\n   * @param {string} verdict - Bad when the score is below 0.4, moderate when equal to 0.4 or between 0.4 and 0.6.\n   * good when the score is 0.6 or above.\n   */\n  constructor(ipa, score, confidenceScore, verdict) {\n    /**\n     * @type {string}\n     */\n    this.ipa = ipa;\n\n    /**\n     * @type {float}\n     */\n    this.score = score;\n\n    /**\n     * @type {float}\n     */\n    this.confidenceScore = confidenceScore;\n\n    /**\n     * @type {string}\n     */\n    this.verdict = verdict;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/phoneme/phoneme.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 281,
    "kind": "class",
    "name": "Phoneme",
    "memberof": "src/administrative-sdk/phoneme/phoneme.js",
    "static": true,
    "longname": "src/administrative-sdk/phoneme/phoneme.js~Phoneme",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/phoneme/phoneme.js",
    "importStyle": "Phoneme",
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 282,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/phoneme/phoneme.js~Phoneme",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/phoneme/phoneme.js~Phoneme#constructor",
    "access": "public",
    "description": "Create a phoneme domain model.",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "ipa",
        "description": "The pronunciation of the grapheme(s) indicated as International Phonetic Alphabet (IPA)."
      },
      {
        "nullable": null,
        "types": [
          "float"
        ],
        "spread": false,
        "optional": false,
        "name": "score",
        "description": "The audio is scored per phoneme and consists of several measurements. 0 would be bad,\n1 the perfect score."
      },
      {
        "nullable": null,
        "types": [
          "float"
        ],
        "spread": false,
        "optional": false,
        "name": "confidenceScore",
        "description": "This value provides a reliable prediction that the pronounced phoneme is\nactually the phoneme that is supposed to be pronounced. There is no absolute scale defined yet."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "verdict",
        "description": "Bad when the score is below 0.4, moderate when equal to 0.4 or between 0.4 and 0.6.\ngood when the score is 0.6 or above."
      }
    ]
  },
  {
    "__docId__": 283,
    "kind": "member",
    "name": "ipa",
    "memberof": "src/administrative-sdk/phoneme/phoneme.js~Phoneme",
    "static": false,
    "longname": "src/administrative-sdk/phoneme/phoneme.js~Phoneme#ipa",
    "access": "public",
    "description": "",
    "lineNumber": 17,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 284,
    "kind": "member",
    "name": "score",
    "memberof": "src/administrative-sdk/phoneme/phoneme.js~Phoneme",
    "static": false,
    "longname": "src/administrative-sdk/phoneme/phoneme.js~Phoneme#score",
    "access": "public",
    "description": "",
    "lineNumber": 22,
    "type": {
      "nullable": null,
      "types": [
        "float"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 285,
    "kind": "member",
    "name": "confidenceScore",
    "memberof": "src/administrative-sdk/phoneme/phoneme.js~Phoneme",
    "static": false,
    "longname": "src/administrative-sdk/phoneme/phoneme.js~Phoneme#confidenceScore",
    "access": "public",
    "description": "",
    "lineNumber": 27,
    "type": {
      "nullable": null,
      "types": [
        "float"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 286,
    "kind": "member",
    "name": "verdict",
    "memberof": "src/administrative-sdk/phoneme/phoneme.js~Phoneme",
    "static": false,
    "longname": "src/administrative-sdk/phoneme/phoneme.js~Phoneme#verdict",
    "access": "public",
    "description": "",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 287,
    "kind": "file",
    "name": "src/administrative-sdk/profile/profile-controller.js",
    "content": "import Profile from './profile';\n\n/**\n * Controller class for the Profile model.\n * @private\n */\nexport default class ProfileController {\n  /**\n   * @param {Connection} connection - Object to use for making a connection to the REST API and Websocket server.\n   */\n  constructor(connection) {\n    /**\n     * Object to use for making a connection to the REST API and Websocket server.\n     * @type {Connection}\n     */\n    this._connection = connection;\n  }\n\n  /**\n   * Get the profile of the given user active in the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {string} userId - Specify a User identifier.\n   * @returns {Promise.<Profile>} Promise containing a Profile.\n   * @throws {Promise.<Error>} userId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getProfile(userId) {\n    if (typeof userId !== 'string') {\n      return Promise.reject(new Error('userId parameter of type \"string\" is required'));\n    }\n    const url = this._connection._settings.apiUrl + '/profiles/' + userId;\n\n    return this._connection._secureAjaxGet(url)\n      .then(data => {\n        const profile = new Profile(data.firstName, data.lastName, data.infix, data.gender, new Date(data.birthDate));\n        profile.created = new Date(data.created);\n        profile.updated = new Date(data.updated);\n        return profile;\n      });\n  }\n\n  /**\n   * Get and return all profiles of all users in the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @returns {Promise.<Profile[]>} Array of Profiles.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  getProfiles() {\n    const url = this._connection._settings.apiUrl + '/profiles';\n    return this._connection._secureAjaxGet(url)\n      .then(data => data.map(datum => {\n        const profile = new Profile(datum.firstName, datum.lastName, datum.infix, datum.gender,\n          new Date(datum.birthDate));\n        profile.created = new Date(datum.created);\n        profile.updated = new Date(datum.updated);\n        return profile;\n      }));\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/profile/profile-controller.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 288,
    "kind": "class",
    "name": "ProfileController",
    "memberof": "src/administrative-sdk/profile/profile-controller.js",
    "static": true,
    "longname": "src/administrative-sdk/profile/profile-controller.js~ProfileController",
    "access": "private",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/profile/profile-controller.js",
    "importStyle": "ProfileController",
    "description": "Controller class for the Profile model.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 289,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/profile/profile-controller.js~ProfileController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/profile/profile-controller.js~ProfileController#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "Connection"
        ],
        "spread": false,
        "optional": false,
        "name": "connection",
        "description": "Object to use for making a connection to the REST API and Websocket server."
      }
    ]
  },
  {
    "__docId__": 290,
    "kind": "member",
    "name": "_connection",
    "memberof": "src/administrative-sdk/profile/profile-controller.js~ProfileController",
    "static": false,
    "longname": "src/administrative-sdk/profile/profile-controller.js~ProfileController#_connection",
    "access": "private",
    "description": "Object to use for making a connection to the REST API and Websocket server.",
    "lineNumber": 16,
    "type": {
      "nullable": null,
      "types": [
        "Connection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 291,
    "kind": "method",
    "name": "getProfile",
    "memberof": "src/administrative-sdk/profile/profile-controller.js~ProfileController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/profile/profile-controller.js~ProfileController#getProfile",
    "access": "public",
    "description": "Get the profile of the given user active in the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Profile>} Promise containing a Profile."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": "Specify a User identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Profile>"
      ],
      "spread": false,
      "description": "Promise containing a Profile."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "userId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 292,
    "kind": "method",
    "name": "getProfiles",
    "memberof": "src/administrative-sdk/profile/profile-controller.js~ProfileController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/profile/profile-controller.js~ProfileController#getProfiles",
    "access": "public",
    "description": "Get and return all profiles of all users in the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Profile[]>} Array of Profiles."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Profile[]>"
      ],
      "spread": false,
      "description": "Array of Profiles."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ],
    "params": []
  },
  {
    "__docId__": 293,
    "kind": "file",
    "name": "src/administrative-sdk/profile/profile.js",
    "content": "/**\n * Profile domain model. A profile is part of a {@link User} and stores general information about the user.\n */\nexport default class Profile {\n  /**\n   * Create a Profile.\n   *\n   * @param {string} firstName - The first name of the {@link User}.\n   * @param {string} lastName - The last name of the {@link User}.\n   * @param {?string} [infix] - The infix of the {@link User}'s name.\n   * @param {string} gender - The gender of the {@link User}.\n   * @param {Date} birthDate - The birth date of the {@link User}.\n   * @throws {Error} firstName parameter of type \"string\" is required.\n   * @throws {Error} lastName parameter of type \"string\" is required.\n   * @throws {Error} gender parameter of type \"string\" is required.\n   * @throws {Error} birthDate parameter of type \"Date\" is required.\n   */\n  constructor(firstName, lastName, infix = null, gender, birthDate) {\n    if (typeof firstName !== 'string') {\n      throw new Error('firstName parameter of type \"string\" is required');\n    }\n\n    if (typeof lastName !== 'string') {\n      throw new Error('lastName parameter of type \"string\" is required');\n    }\n\n    if (infix !== null && typeof infix !== 'string') {\n      throw new Error('infix parameter of type \"string|null\" is required');\n    }\n\n    if (typeof gender !== 'string') {\n      throw new Error('gender parameter of type \"string\" is required');\n    }\n\n    if (!(birthDate instanceof Date)) {\n      throw new Error('birthDate parameter of type \"Date\" is required');\n    }\n\n    /**\n     * The first name of the {@link User}.\n     * @type {string}\n     */\n    this.firstName = firstName;\n\n    /**\n     * The last name of the {@link User}.\n     * @type {string}\n     */\n    this.lastName = lastName;\n\n    /**\n     * @type {string} The infix of the {@link User}'s name.\n     */\n    this.infix = infix;\n\n    /**\n     * The gender of the {@link User}.\n     * @type {string}\n     */\n    this.gender = gender;\n\n    /**\n     * The birth date of the {@link User}.\n     * @type {Date}\n     */\n    this.birthDate = birthDate;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/profile/profile.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 294,
    "kind": "class",
    "name": "Profile",
    "memberof": "src/administrative-sdk/profile/profile.js",
    "static": true,
    "longname": "src/administrative-sdk/profile/profile.js~Profile",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/profile/profile.js",
    "importStyle": "Profile",
    "description": "Profile domain model. A profile is part of a {@link User} and stores general information about the user.",
    "lineNumber": 4,
    "interface": false
  },
  {
    "__docId__": 295,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/profile/profile.js~Profile",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/profile/profile.js~Profile#constructor",
    "access": "public",
    "description": "Create a Profile.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "firstName",
        "description": "The first name of the {@link User}."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "lastName",
        "description": "The last name of the {@link User}."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "infix",
        "description": "The infix of the {@link User}'s name."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "gender",
        "description": "The gender of the {@link User}."
      },
      {
        "nullable": null,
        "types": [
          "Date"
        ],
        "spread": false,
        "optional": false,
        "name": "birthDate",
        "description": "The birth date of the {@link User}."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "firstName parameter of type \"string\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "lastName parameter of type \"string\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "gender parameter of type \"string\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "birthDate parameter of type \"Date\" is required."
      }
    ]
  },
  {
    "__docId__": 296,
    "kind": "member",
    "name": "firstName",
    "memberof": "src/administrative-sdk/profile/profile.js~Profile",
    "static": false,
    "longname": "src/administrative-sdk/profile/profile.js~Profile#firstName",
    "access": "public",
    "description": "The first name of the {@link User}.",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 297,
    "kind": "member",
    "name": "lastName",
    "memberof": "src/administrative-sdk/profile/profile.js~Profile",
    "static": false,
    "longname": "src/administrative-sdk/profile/profile.js~Profile#lastName",
    "access": "public",
    "description": "The last name of the {@link User}.",
    "lineNumber": 49,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 298,
    "kind": "member",
    "name": "infix",
    "memberof": "src/administrative-sdk/profile/profile.js~Profile",
    "static": false,
    "longname": "src/administrative-sdk/profile/profile.js~Profile#infix",
    "access": "public",
    "description": "",
    "lineNumber": 54,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 299,
    "kind": "member",
    "name": "gender",
    "memberof": "src/administrative-sdk/profile/profile.js~Profile",
    "static": false,
    "longname": "src/administrative-sdk/profile/profile.js~Profile#gender",
    "access": "public",
    "description": "The gender of the {@link User}.",
    "lineNumber": 60,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 300,
    "kind": "member",
    "name": "birthDate",
    "memberof": "src/administrative-sdk/profile/profile.js~Profile",
    "static": false,
    "longname": "src/administrative-sdk/profile/profile.js~Profile#birthDate",
    "access": "public",
    "description": "The birth date of the {@link User}.",
    "lineNumber": 66,
    "type": {
      "nullable": null,
      "types": [
        "Date"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 301,
    "kind": "file",
    "name": "src/administrative-sdk/progress/progress-controller.js",
    "content": "import Progress from './progress';\n\n/**\n * Controller class for the Progress model.\n * @private\n */\nexport default class ProgressController {\n  /**\n   * @param {Connection} connection - Object to use for making a connection to the REST API and Websocket server.\n   */\n  constructor(connection) {\n    /**\n     * Object to use for making a connection to the REST API and Websocket server.\n     * @type {Connection}\n     */\n    this._connection = connection;\n  }\n\n  /**\n   * Get Progress corresponding to a {@Link Category} for the current active {@Link User} derived from\n   * the OAuth2 scope. If a user is allowed to see the progress of multiple users (depending of its\n   * {@Link Role} and permissions) then more Progress objects could be returned. This can be controlled\n   * with the groupId parameter. This way, only users in a specific group will be returned as a result.\n   *\n   * Progress is always being fetched for a single category, identified with a categoryId.\n   *\n   * @param {string} categoryId - Specify a Category identifier.\n   * @param {?string} groupId - Specify a Group identifier.\n   * @param {?Array} roles - Specify user roles as a filter to the result.\n   * @returns {Promise.<Progress[]>} Array of Progress.\n   * @throws {Promise.<Error>} categoryId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} groupId parameter of type \"string|null\" is required.\n   * @throws {Promise.<Error>} roles parameter of type \"Array|null\" is required.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  getProgress(categoryId, groupId = null, roles = null) {\n    let urlMod = '';\n\n    if (typeof categoryId !== 'string') {\n      return Promise.reject(new Error('categoryId parameter of type \"string\" is required'));\n    }\n\n    if (groupId !== null && typeof groupId !== 'string') {\n      return Promise.reject(new Error('groupId parameter of type \"string|null\" is required'));\n    }\n\n    if (roles !== null && !Array.isArray(roles)) {\n      return Promise.reject(new Error('roles parameter of type \"Array|null\" is required'));\n    }\n\n    if (groupId) {\n      urlMod = `?group=${groupId}`;\n    }\n\n    if (groupId && roles) {\n      roles.map(role => {\n        urlMod += `&role=${role}`;\n      });\n    }\n\n    const url = `${this._connection._settings.apiUrl}/categories/${categoryId}/progress${urlMod}`;\n\n    return this._connection._secureAjaxGet(url)\n      .then(data => data.map(({user, category, percentage, challenges}) =>\n        new Progress(user, category, String(percentage), challenges)\n      ));\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/progress/progress-controller.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 302,
    "kind": "class",
    "name": "ProgressController",
    "memberof": "src/administrative-sdk/progress/progress-controller.js",
    "static": true,
    "longname": "src/administrative-sdk/progress/progress-controller.js~ProgressController",
    "access": "private",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/progress/progress-controller.js",
    "importStyle": "ProgressController",
    "description": "Controller class for the Progress model.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 303,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/progress/progress-controller.js~ProgressController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/progress/progress-controller.js~ProgressController#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "Connection"
        ],
        "spread": false,
        "optional": false,
        "name": "connection",
        "description": "Object to use for making a connection to the REST API and Websocket server."
      }
    ]
  },
  {
    "__docId__": 304,
    "kind": "member",
    "name": "_connection",
    "memberof": "src/administrative-sdk/progress/progress-controller.js~ProgressController",
    "static": false,
    "longname": "src/administrative-sdk/progress/progress-controller.js~ProgressController#_connection",
    "access": "private",
    "description": "Object to use for making a connection to the REST API and Websocket server.",
    "lineNumber": 16,
    "type": {
      "nullable": null,
      "types": [
        "Connection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 305,
    "kind": "method",
    "name": "getProgress",
    "memberof": "src/administrative-sdk/progress/progress-controller.js~ProgressController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/progress/progress-controller.js~ProgressController#getProgress",
    "access": "public",
    "description": "Get Progress corresponding to a {@Link Category} for the current active {@Link User} derived from\nthe OAuth2 scope. If a user is allowed to see the progress of multiple users (depending of its\n{@Link Role} and permissions) then more Progress objects could be returned. This can be controlled\nwith the groupId parameter. This way, only users in a specific group will be returned as a result.\n\nProgress is always being fetched for a single category, identified with a categoryId.",
    "lineNumber": 36,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Progress[]>} Array of Progress."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "categoryId",
        "description": "Specify a Category identifier."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "groupId",
        "description": "Specify a Group identifier."
      },
      {
        "nullable": true,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "roles",
        "description": "Specify user roles as a filter to the result."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Progress[]>"
      ],
      "spread": false,
      "description": "Array of Progress."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "categoryId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "groupId parameter of type \"string|null\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "roles parameter of type \"Array|null\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 306,
    "kind": "file",
    "name": "src/administrative-sdk/progress/progress.js",
    "content": "/**\n * Progress object for challenges. Progress keeps track of the total challenges in a category and\n * the amount of SpeechChallenges that are completed.\n */\nexport default class Progress {\n  /**\n   * Create a Progress object.\n   *\n   * @param {Object} user - Some user information that belongs to the progress.\n   * @param {string} category - The category identifier to which this progress object refers.\n   * @param {?string} percentage - The percentage of completeness of all (underlying) challenges.\n   * @param {?Array.<Object>} challenges - Challenges belonging to the progress.\n   *\n   * @throws {Error} user parameter of type \"Object\" is required\n   * @throws {Error} category parameter of type \"string\" is required\n   * @throws {Error} percentage parameter of type \"string|null\" is required\n   * @throws {Error} challenges parameter of type \"Array.<Objects>|null\" is required\n   */\n  constructor(user, category, percentage = null, challenges = null) {\n    if (typeof user !== 'object') {\n      throw new Error('user parameter of type \"Object\" is required');\n    }\n\n    if (typeof category !== 'string') {\n      throw new Error('category parameter of type \"string\" is required');\n    }\n\n    if (percentage !== null && typeof percentage !== 'string') {\n      throw new Error('percentage parameter of type \"string|null\" is required');\n    }\n\n    if (challenges !== null && !Array.isArray(challenges)) {\n      throw new Error('challenges parameter of type \"Array.<Objects>|null\" is required');\n    }\n\n    /**\n     * @type {Object} Some user information that belongs to the progress.\n     */\n    this.user = user;\n\n    /**\n     * @type {string} The category identifier to which this progress object refers.\n     */\n    this.category = category;\n\n    /**\n     * @type {string|null} The percentage of completeness of all (underlying) challenges.\n     */\n    this.percentage = percentage;\n\n    /**\n     * @type {Object} Challenges belonging to the progress.\n     */\n    this.challenges = challenges;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/progress/progress.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 307,
    "kind": "class",
    "name": "Progress",
    "memberof": "src/administrative-sdk/progress/progress.js",
    "static": true,
    "longname": "src/administrative-sdk/progress/progress.js~Progress",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/progress/progress.js",
    "importStyle": "Progress",
    "description": "Progress object for challenges. Progress keeps track of the total challenges in a category and\nthe amount of SpeechChallenges that are completed.",
    "lineNumber": 5,
    "interface": false
  },
  {
    "__docId__": 308,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/progress/progress.js~Progress",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/progress/progress.js~Progress#constructor",
    "access": "public",
    "description": "Create a Progress object.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "Some user information that belongs to the progress."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "category",
        "description": "The category identifier to which this progress object refers."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "percentage",
        "description": "The percentage of completeness of all (underlying) challenges."
      },
      {
        "nullable": true,
        "types": [
          "Array.<Object>"
        ],
        "spread": false,
        "optional": false,
        "name": "challenges",
        "description": "Challenges belonging to the progress."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "user parameter of type \"Object\" is required"
      },
      {
        "types": [
          "Error"
        ],
        "description": "category parameter of type \"string\" is required"
      },
      {
        "types": [
          "Error"
        ],
        "description": "percentage parameter of type \"string|null\" is required"
      },
      {
        "types": [
          "Error"
        ],
        "description": "challenges parameter of type \"Array.<Objects>|null\" is required"
      }
    ]
  },
  {
    "__docId__": 309,
    "kind": "member",
    "name": "user",
    "memberof": "src/administrative-sdk/progress/progress.js~Progress",
    "static": false,
    "longname": "src/administrative-sdk/progress/progress.js~Progress#user",
    "access": "public",
    "description": "",
    "lineNumber": 39,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 310,
    "kind": "member",
    "name": "category",
    "memberof": "src/administrative-sdk/progress/progress.js~Progress",
    "static": false,
    "longname": "src/administrative-sdk/progress/progress.js~Progress#category",
    "access": "public",
    "description": "",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 311,
    "kind": "member",
    "name": "percentage",
    "memberof": "src/administrative-sdk/progress/progress.js~Progress",
    "static": false,
    "longname": "src/administrative-sdk/progress/progress.js~Progress#percentage",
    "access": "public",
    "description": "",
    "lineNumber": 49,
    "type": {
      "nullable": null,
      "types": [
        "string",
        "null"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 312,
    "kind": "member",
    "name": "challenges",
    "memberof": "src/administrative-sdk/progress/progress.js~Progress",
    "static": false,
    "longname": "src/administrative-sdk/progress/progress.js~Progress#challenges",
    "access": "public",
    "description": "",
    "lineNumber": 54,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 313,
    "kind": "file",
    "name": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js",
    "content": "/* eslint-disable\n camelcase\n */\nimport Base64Utils from '../utils/base64-utils';\nimport Connection from '../connection/connection-controller';\nimport Phoneme from '../phoneme/phoneme';\nimport PronunciationAnalysis from './pronunciation-analysis';\nimport PronunciationChallenge from '../pronunciation-challenge/pronunciation-challenge';\nimport Word from '../word/word';\nimport WordChunk from '../word-chunk/word-chunk';\nimport when from 'when';\n\n/**\n * Controller class for the PronunciationAnalysis model.\n * @private\n */\nexport default class PronunciationAnalysisController {\n  /**\n   * @param {Connection} connection - Object to use for making a connection to the REST API and Websocket server.\n   */\n  constructor(connection) {\n    /**\n     * Object to use for making a connection to the REST API and Websocket server.\n     * @type {Connection}\n     */\n    this._connection = connection;\n  }\n\n  /**\n   * Create a `its.Word` domain model from JSON data.\n   *\n   * @param {object[]} inWords - The words array from the PronunciationAnalysis API.\n   * @returns {Word[]} An array of {@link Word} domain models.\n   */\n  static _wordsToModels(inWords) {\n    return inWords.map(word => {\n      const chunks = word.chunks.map(chunk => {\n        const phonemes = (chunk.phonemes || []).map(phoneme => {\n          const newPhoneme = new Phoneme(\n            phoneme.ipa, phoneme.score, phoneme.confidenceScore,\n            phoneme.verdict);\n          // Copy all properties as API docs indicate there may be a\n          // variable amount of phoneme properties.\n          return Object.assign(newPhoneme, phoneme);\n        });\n        return new WordChunk(chunk.graphemes, chunk.score, chunk.verdict, phonemes);\n      });\n      return new Word(chunks);\n    });\n  }\n\n  /**\n   * Initialise the pronunciation analysis challenge through RPCs.\n   *\n   * @param {PronunciationChallenge} challenge - Challenge.\n   * @private\n   */\n  pronunciationAnalysisInitChallenge(challenge) {\n    return this._connection._session.call('nl.itslanguage.pronunciation.init_challenge',\n      [this._connection._analysisId, challenge.id])\n      .then(analysisId => {\n        console.log('Challenge initialised for analysisId: ' + this._connection._analysisId);\n        return analysisId;\n      })\n      .then(() => this._connection._session.call('nl.itslanguage.pronunciation.alignment',\n        [this._connection._analysisId]))\n      .then(alignment => {\n        this._referenceAlignment = alignment;\n        console.log('Reference alignment retrieved', alignment);\n      });\n  }\n\n  /**\n   * Initialise the pronunciation analysis audio specs through RPCs.\n   *\n   * @param {AudioRecorder} recorder - AudioRecorder.\n   * @param {Function} dataavailableCb - Callback.\n   * @private\n   */\n  pronunciationAnalysisInitAudio(recorder, dataavailableCb) {\n    // Indicate to the socket server that we're about to start recording a\n    // challenge. This allows the socket server some time to fetch the metadata\n    // and reference audio to start the analysis when audio is actually submitted.\n    const specs = recorder.getAudioSpecs();\n    return this._connection.call('pronunciation.init_audio',\n      [this._connection._analysisId, specs.audioFormat], specs.audioParameters)\n      .then(analysisId => {\n        console.log('Accepted audio parameters for analysisId after init_audio: ' + this._connection._analysisId);\n        // Start listening for streaming data.\n        recorder.addEventListener('dataavailable', dataavailableCb);\n        return analysisId;\n      });\n  }\n\n  /**\n   * Start a pronunciation analysis from streaming audio.\n   *\n   * @param {PronunciationChallenge} challenge - The pronunciation challenge to perform.\n   * @param {AudioRecorder} recorder - The audio recorder to extract audio from.\n   * @param {?boolean} trim - Whether to trim the start and end of recorded audio (default: true).\n   * @returns {Promise.<PronunciationAnalysis>} A {@link https://github.com/cujojs/when} Promise containing a {@link PronunciationAnalysis}.\n   * @emits {string} 'ReadyToReceive' when the call is made to receive audio. The recorder can now send audio.\n   * @emits {Object} When the sent audio has finished alignment. Aligning audio is the process of mapping the audio\n   * to spoken words and determining when what is said. An object is sent containing a property 'progress',\n   * which is the sent audio alignment, and a property 'referenceAlignment' which is the alignment of the\n   * reference audio.\n   * @throws {Promise.<Error>} challenge parameter of type \"PronunciationChallenge\" is required.\n   * @throws {Promise.<Error>} challenge.id field of type \"string\" is required.\n   * @throws {Promise.<Error>} If the connection is not open.\n   * @throws {Promise.<Error>} If the recorder is already recording.\n   * @throws {Promise.<Error>} If a session is already in progress.\n   * @throws {Promise.<Error>} If something went wrong during analysis.\n   */\n  startStreamingPronunciationAnalysis(challenge, recorder, trim) {\n    if (!(challenge instanceof PronunciationChallenge)) {\n      return Promise.reject(new Error('challenge parameter of type \"PronunciationChallenge\" is required'));\n    }\n    if (typeof challenge.id !== 'string') {\n      return Promise.reject(new Error('challenge.id field of type \"string\" is required'));\n    }\n    if (!this._connection._session) {\n      return Promise.reject(new Error('WebSocket connection was not open.'));\n    }\n    if (recorder.isRecording()) {\n      return Promise.reject(new Error('Recorder should not yet be recording.'));\n    }\n\n    if (this._connection._analysisId !== null) {\n      return Promise.reject(new Error('Session with analysisId ' + this._connection._analysisId +\n        ' still in progress.'));\n    }\n    const self = this;\n    this._connection._analyisId = null;\n    let trimAudioStart = 0.15;\n    const trimAudioEnd = 0.0;\n    if (trim === false) {\n      trimAudioStart = 0.0;\n    }\n    return new when.Promise((resolve, reject, notify) => {\n      function reportDone(data) {\n        const analysis = new PronunciationAnalysis(\n          challenge.id, data.userId, data.id,\n          new Date(data.created), new Date(data.updated),\n          self._connection.addAccessToken(data.audioUrl),\n          data.score, data.confidenceScore,\n          PronunciationAnalysisController._wordsToModels(data.words)\n        );\n        resolve({analysisId: self._connection._analysisId, analysis});\n      }\n\n      function reportProgress(progress) {\n        notify({progress, referenceAlignment: self._referenceAlignment});\n      }\n\n      function reportError(data) {\n        // Either there was an unexpected error, or the audio failed to\n        // align, in which case no analysis is provided, but just the\n        // basic metadata.\n        const {message} = data;\n\n        if (data.id) {\n          const analysis = new PronunciationAnalysis(\n            challenge.id, data.userId, data.id,\n            new Date(data.created), new Date(data.updated),\n            self._connection.addAccessToken(data.audioUrl));\n          reject({analysis, message});\n        } else {\n          reject({message});\n        }\n      }\n\n      // Start streaming the binary audio when the user instructs\n      // the audio recorder to start recording.\n      function startStreaming(chunk) {\n        const encoded = Base64Utils._arrayBufferToBase64(chunk);\n        console.log('Sending audio chunk to websocket for analysisId: ' +\n          self._connection._analysisId);\n        self._connection.call('pronunciation.write',\n          [self._connection._analysisId, encoded, 'base64'])\n          .catch(res => {\n            Connection.logRPCError(res);\n            reportError(res);\n          });\n      }\n\n      function initAnalysis(analysisId) {\n        self._connection._analysisId = analysisId;\n        console.log('Got analysisId after initialisation: ' + self._connection._analysisId);\n      }\n\n      // Stop listening when the audio recorder stopped.\n      function stopListening() {\n        recorder.removeEventListener('recorded', stopListening);\n        recorder.removeEventListener('dataavailable', startStreaming);\n\n        // When done, submit any plain text (non-JSON) to start analysing.\n        self._connection.call('pronunciation.analyse',\n          [self._connection._analysisId], {}, {receive_progress: true})\n          .progress(progress => {\n            reportProgress(progress);\n          })\n          .then(reportDone)\n          .catch(res => {\n            const {error, kwargs: {analysis = {}}} = res;\n\n            if (error === 'nl.itslanguage.ref_alignment_failed') {\n              analysis.message = 'Reference alignment failed';\n            } else if (error === 'nl.itslanguage.alignment_failed') {\n              analysis.message = 'Alignment failed';\n            } else if (error === 'nl.itslanguage.analysis_failed') {\n              analysis.message = 'Analysis failed';\n            } else {\n              analysis.message = 'Unhandled error';\n              Connection.logRPCError(res);\n            }\n            reportError(analysis);\n          });\n      }\n\n      recorder.addEventListener('recorded', stopListening);\n      self._connection.call('pronunciation.init_analysis', [],\n        {\n          trimStart: trimAudioStart,\n          trimEnd: trimAudioEnd\n        })\n        .then(initAnalysis)\n        .then(() => self.pronunciationAnalysisInitChallenge(challenge))\n        .then(() => notify('ReadyToReceive'))\n        .then(() => new Promise(resolve_ => {\n          if (recorder.hasUserMediaApproval()) {\n            resolve_();\n          } else {\n            recorder.addEventListener('ready', resolve_);\n          }\n        }))\n        .then(() => self.pronunciationAnalysisInitAudio(recorder, startStreaming))\n        .catch(reject);\n    })\n      .then(res => {\n        self._connection._analysisId = null;\n        return Promise.resolve(res);\n      })\n      .catch(error => {\n        self._connection._analysisId = null;\n        Connection.logRPCError(error);\n        return Promise.reject(error);\n      });\n  }\n\n  /**\n   * Get a pronunciation analysis in a pronunciation challenge from the current active {@link Organisation} derived\n   * from the OAuth2 scope.\n   *\n   * @param {string} challengeId - Specify a pronunciation challenge identifier.\n   * @param {string} analysisId - Specify a pronunciation analysis identifier.\n   * @returns {Promise.<PronunciationAnalysis>} Promise containing a PronunciationAnalysis.\n   * @throws {Promise.<Error>} {@link PronunciationChallenge#id} field is required.\n   * @throws {Promise.<Error>} {@link PronunciationAnalysis#id} field is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getPronunciationAnalysis(challengeId, analysisId) {\n    if (!challengeId) {\n      return Promise.reject(new Error('challengeId field is required'));\n    }\n    if (!analysisId) {\n      return Promise.reject(new Error('analysisId field is required'));\n    }\n    const url = this._connection._settings.apiUrl + '/challenges/pronunciation/' +\n      challengeId + '/analyses/' + analysisId;\n    return this._connection._secureAjaxGet(url)\n      .then(datum => {\n        const analysis = new PronunciationAnalysis(challengeId, datum.userId,\n          datum.id, new Date(datum.created), new Date(datum.updated),\n          datum.audioUrl, datum.score, datum.confidenceScore, null);\n        // Alignment may not be successful, in which case the analysis\n        // is not available, but it's still an attempt that is available,\n        // albeit without extended attributes like score and phonemes.\n        if (datum.words) {\n          analysis.words = PronunciationAnalysisController._wordsToModels(datum.words);\n        }\n        return analysis;\n      });\n  }\n\n  /**\n   * Get and return all pronunciation analyses in a specific pronunciation challenge from the current active\n   * {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {string} challengeId - Specify a pronunciation challenge identifier to list\n   * speech recordings for.\n   * @param {boolean} [detailed=false] - Returns extra analysis metadata when true.\n   * @returns {Promise.<PronunciationAnalysis[]>} Promise containing an array PronunciationAnalyses.\n   * @throws {Promise.<Error>} {@link PronunciationChallenge#id} field is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getPronunciationAnalyses(challengeId, detailed) {\n    if (!challengeId) {\n      return Promise.reject(new Error('challengeId field is required'));\n    }\n    let url = this._connection._settings.apiUrl + '/challenges/pronunciation/' +\n      challengeId + '/analyses';\n    if (detailed) {\n      url += '?detailed=true';\n    }\n    return this._connection._secureAjaxGet(url)\n      .then(data => data.map(datum => {\n        const analysis = new PronunciationAnalysis(challengeId, datum.userId,\n          datum.id, new Date(datum.created), new Date(datum.updated),\n          datum.audioUrl, datum.score, datum.confidenceScore, null);\n        // Alignment may not be successful, in which case the analysis\n        // is not available, but it's still an attempt that is available,\n        // albeit without extended attributes like score and phonemes.\n        if (datum.words) {\n          analysis.words = PronunciationAnalysisController._wordsToModels(datum.words);\n        }\n        return analysis;\n      }));\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 314,
    "kind": "class",
    "name": "PronunciationAnalysisController",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js",
    "static": true,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js~PronunciationAnalysisController",
    "access": "private",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js",
    "importStyle": "PronunciationAnalysisController",
    "description": "Controller class for the PronunciationAnalysis model.",
    "lineNumber": 17,
    "interface": false
  },
  {
    "__docId__": 315,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js~PronunciationAnalysisController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js~PronunciationAnalysisController#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "Connection"
        ],
        "spread": false,
        "optional": false,
        "name": "connection",
        "description": "Object to use for making a connection to the REST API and Websocket server."
      }
    ]
  },
  {
    "__docId__": 316,
    "kind": "member",
    "name": "_connection",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js~PronunciationAnalysisController",
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js~PronunciationAnalysisController#_connection",
    "access": "private",
    "description": "Object to use for making a connection to the REST API and Websocket server.",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "Connection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 317,
    "kind": "method",
    "name": "_wordsToModels",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js~PronunciationAnalysisController",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js~PronunciationAnalysisController._wordsToModels",
    "access": "private",
    "description": "Create a `its.Word` domain model from JSON data.",
    "lineNumber": 35,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Word[]} An array of {@link Word} domain models."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object[]"
        ],
        "spread": false,
        "optional": false,
        "name": "inWords",
        "description": "The words array from the PronunciationAnalysis API."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Word[]"
      ],
      "spread": false,
      "description": "An array of {@link Word} domain models."
    }
  },
  {
    "__docId__": 318,
    "kind": "method",
    "name": "pronunciationAnalysisInitChallenge",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js~PronunciationAnalysisController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js~PronunciationAnalysisController#pronunciationAnalysisInitChallenge",
    "access": "private",
    "description": "Initialise the pronunciation analysis challenge through RPCs.",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "PronunciationChallenge"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "Challenge."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 319,
    "kind": "member",
    "name": "_referenceAlignment",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js~PronunciationAnalysisController",
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js~PronunciationAnalysisController#_referenceAlignment",
    "access": "private",
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 320,
    "kind": "method",
    "name": "pronunciationAnalysisInitAudio",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js~PronunciationAnalysisController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js~PronunciationAnalysisController#pronunciationAnalysisInitAudio",
    "access": "private",
    "description": "Initialise the pronunciation analysis audio specs through RPCs.",
    "lineNumber": 80,
    "params": [
      {
        "nullable": null,
        "types": [
          "AudioRecorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "AudioRecorder."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "dataavailableCb",
        "description": "Callback."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 321,
    "kind": "method",
    "name": "startStreamingPronunciationAnalysis",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js~PronunciationAnalysisController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js~PronunciationAnalysisController#startStreamingPronunciationAnalysis",
    "access": "public",
    "description": "Start a pronunciation analysis from streaming audio.",
    "lineNumber": 114,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PronunciationAnalysis>} A {@link https://github.com/cujojs/when} Promise containing a {@link PronunciationAnalysis}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "PronunciationChallenge"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "The pronunciation challenge to perform."
      },
      {
        "nullable": null,
        "types": [
          "AudioRecorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "The audio recorder to extract audio from."
      },
      {
        "nullable": true,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "trim",
        "description": "Whether to trim the start and end of recorded audio (default: true)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PronunciationAnalysis>"
      ],
      "spread": false,
      "description": "A {@link https://github.com/cujojs/when} Promise containing a {@link PronunciationAnalysis}."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "challenge parameter of type \"PronunciationChallenge\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "challenge.id field of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the connection is not open."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the recorder is already recording."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If a session is already in progress."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If something went wrong during analysis."
      }
    ],
    "emits": [
      {
        "types": [
          "string"
        ],
        "description": "'ReadyToReceive' when the call is made to receive audio. The recorder can now send audio."
      },
      {
        "types": [
          "Object"
        ],
        "description": "When the sent audio has finished alignment. Aligning audio is the process of mapping the audio\nto spoken words and determining when what is said. An object is sent containing a property 'progress',\nwhich is the sent audio alignment, and a property 'referenceAlignment' which is the alignment of the\nreference audio."
      }
    ]
  },
  {
    "__docId__": 322,
    "kind": "method",
    "name": "getPronunciationAnalysis",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js~PronunciationAnalysisController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js~PronunciationAnalysisController#getPronunciationAnalysis",
    "access": "public",
    "description": "Get a pronunciation analysis in a pronunciation challenge from the current active {@link Organisation} derived\nfrom the OAuth2 scope.",
    "lineNumber": 261,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PronunciationAnalysis>} Promise containing a PronunciationAnalysis."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "Specify a pronunciation challenge identifier."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "analysisId",
        "description": "Specify a pronunciation analysis identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PronunciationAnalysis>"
      ],
      "spread": false,
      "description": "Promise containing a PronunciationAnalysis."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link PronunciationChallenge#id} field is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link PronunciationAnalysis#id} field is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 323,
    "kind": "method",
    "name": "getPronunciationAnalyses",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js~PronunciationAnalysisController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis-controller.js~PronunciationAnalysisController#getPronunciationAnalyses",
    "access": "public",
    "description": "Get and return all pronunciation analyses in a specific pronunciation challenge from the current active\n{@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 296,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PronunciationAnalysis[]>} Promise containing an array PronunciationAnalyses."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "Specify a pronunciation challenge identifier to list\nspeech recordings for."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "detailed",
        "description": "Returns extra analysis metadata when true."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PronunciationAnalysis[]>"
      ],
      "spread": false,
      "description": "Promise containing an array PronunciationAnalyses."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link PronunciationChallenge#id} field is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 324,
    "kind": "file",
    "name": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js",
    "content": "/**\n * @class PronunciationAnalysis\n */\nexport default class PronunciationAnalysis {\n  /**\n   * Create a pronunciation analysis domain model.\n   *\n   * @param {string} challengeId - The challenge identifier.\n   * @param {string} userId - The user identifier on whose behalf this audio is uploaded.\n   * @param {string} id - The pronunciation analysis identifier.\n   * @param {Date} created - The creation date of the entity.\n   * @param {Date} updated - The most recent update date of the entity.\n   * @param {string} audioUrl - The audio fragment as streaming audio link.\n   * @param {number} score - The average score of all phonemes grading the entire attempt.\n   * @param {float} confidenceScore - This value provides a reliable prediction that the pronounced phonemes are\n   * actually the phonemes that are supposed to be pronounced. There is no absolute scale defined yet.\n   * @param {Word[]} words - The spoken sentence, split in graphemes per word.\n   */\n  constructor(challengeId, userId, id, created, updated, audioUrl, score, confidenceScore, words) {\n    /**\n     * The pronunciation analysis identifier.\n     * @type {string}\n     */\n    this.id = id;\n\n    /**\n     * The {@link PronunciationChallenge} identifier.\n     * @type {string}\n     */\n    this.challengeId = challengeId;\n\n    /**\n     * The user identifier on whose behalf this audio is uploaded.\n     * @type {string}\n     */\n    this.userId = userId;\n\n    /**\n     * The creation date of the entity.\n     * @type {Date}\n     */\n    this.created = created;\n\n    /**\n     * The most recent update date of the entity.\n     * @type {Date}\n     */\n    this.updated = updated;\n\n    /**\n     * The audio fragment as streaming audio link.\n     * @type {string}\n     */\n    this.audioUrl = audioUrl;\n\n    /**\n     * The average score of all phonemes grading the entire attempt.\n     * @type {number}\n     */\n    this.score = score;\n\n    /**\n     * This value provides a reliable prediction that the pronounced phonemes are\n     * actually the phonemes that are supposed to be pronounced. There is no absolute scale defined yet.\n     * @type {float}\n     */\n    this.confidenceScore = confidenceScore;\n\n    /**\n     * The spoken sentence, split in graphemes per word.\n     * @type {Word[][]}\n     */\n    this.words = words;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 325,
    "kind": "class",
    "name": "PronunciationAnalysis",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js",
    "static": true,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js",
    "importStyle": "PronunciationAnalysis",
    "description": "",
    "lineNumber": 4,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "PronunciationAnalysis"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 326,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis#constructor",
    "access": "public",
    "description": "Create a pronunciation analysis domain model.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "The challenge identifier."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": "The user identifier on whose behalf this audio is uploaded."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The pronunciation analysis identifier."
      },
      {
        "nullable": null,
        "types": [
          "Date"
        ],
        "spread": false,
        "optional": false,
        "name": "created",
        "description": "The creation date of the entity."
      },
      {
        "nullable": null,
        "types": [
          "Date"
        ],
        "spread": false,
        "optional": false,
        "name": "updated",
        "description": "The most recent update date of the entity."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "audioUrl",
        "description": "The audio fragment as streaming audio link."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "score",
        "description": "The average score of all phonemes grading the entire attempt."
      },
      {
        "nullable": null,
        "types": [
          "float"
        ],
        "spread": false,
        "optional": false,
        "name": "confidenceScore",
        "description": "This value provides a reliable prediction that the pronounced phonemes are\nactually the phonemes that are supposed to be pronounced. There is no absolute scale defined yet."
      },
      {
        "nullable": null,
        "types": [
          "Word[]"
        ],
        "spread": false,
        "optional": false,
        "name": "words",
        "description": "The spoken sentence, split in graphemes per word."
      }
    ]
  },
  {
    "__docId__": 327,
    "kind": "member",
    "name": "id",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis",
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis#id",
    "access": "public",
    "description": "The pronunciation analysis identifier.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 328,
    "kind": "member",
    "name": "challengeId",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis",
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis#challengeId",
    "access": "public",
    "description": "The {@link PronunciationChallenge} identifier.",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 329,
    "kind": "member",
    "name": "userId",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis",
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis#userId",
    "access": "public",
    "description": "The user identifier on whose behalf this audio is uploaded.",
    "lineNumber": 36,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 330,
    "kind": "member",
    "name": "created",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis",
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis#created",
    "access": "public",
    "description": "The creation date of the entity.",
    "lineNumber": 42,
    "type": {
      "nullable": null,
      "types": [
        "Date"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 331,
    "kind": "member",
    "name": "updated",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis",
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis#updated",
    "access": "public",
    "description": "The most recent update date of the entity.",
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "Date"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 332,
    "kind": "member",
    "name": "audioUrl",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis",
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis#audioUrl",
    "access": "public",
    "description": "The audio fragment as streaming audio link.",
    "lineNumber": 54,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 333,
    "kind": "member",
    "name": "score",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis",
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis#score",
    "access": "public",
    "description": "The average score of all phonemes grading the entire attempt.",
    "lineNumber": 60,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 334,
    "kind": "member",
    "name": "confidenceScore",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis",
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis#confidenceScore",
    "access": "public",
    "description": "This value provides a reliable prediction that the pronounced phonemes are\nactually the phonemes that are supposed to be pronounced. There is no absolute scale defined yet.",
    "lineNumber": 67,
    "type": {
      "nullable": null,
      "types": [
        "float"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 335,
    "kind": "member",
    "name": "words",
    "memberof": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis",
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-analysis/pronunciation-analysis.js~PronunciationAnalysis#words",
    "access": "public",
    "description": "The spoken sentence, split in graphemes per word.",
    "lineNumber": 73,
    "type": {
      "nullable": null,
      "types": [
        "Word[][]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 336,
    "kind": "file",
    "name": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge-controller.js",
    "content": "import PronunciationChallenge from './pronunciation-challenge';\n\n/**\n * Controller class for the PronunciationChallenge model.\n * @private\n */\nexport default class PronunciationChallengeController {\n  /**\n   * @param {Connection} connection - Object to use for making a connection to the REST API and Websocket server.\n   */\n  constructor(connection) {\n    /**\n     * Object to use for making a connection to the REST API and Websocket server.\n     * @type {Connection}\n     */\n    this._connection = connection;\n  }\n\n  /**\n   * Create a pronunciation challenge. The created challenge will be part of the current active {@link Organisation}\n   * derived from the OAuth2 scope.\n   *\n   * @param {PronunciationChallenge} challenge - Object to create.\n   * @param {Blob} audioBlob - Audio fragment to link to the challenge.\n   * @returns {Promise.<PronunciationChallenge>} Promise containing the newly created PronunciationChallenge.\n   * @throws {Promise.<Error>} challenge parameter of type \"PronunciationChallenge\" is required.\n   * @throws {Promise.<Error>} audioBlob parameter of type \"Blob\" is required.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  createPronunciationChallenge(challenge, audioBlob) {\n    if (!(challenge instanceof PronunciationChallenge)) {\n      return Promise.reject(new Error('challenge parameter of type \"PronunciationChallenge\" is required'));\n    }\n\n    if (!(audioBlob instanceof Blob)) {\n      return Promise.reject(new Error(\n        'audioBlob parameter of type \"Blob\" is required'));\n    }\n\n    challenge.referenceAudio = audioBlob;\n    const url = this._connection._settings.apiUrl + '/challenges/pronunciation';\n    const fd = JSON.stringify(challenge);\n    return this._connection._secureAjaxPost(url, fd)\n      .then(data => {\n        const result = new PronunciationChallenge(data.id, data.transcription, data.referenceAudioUrl);\n        result.created = new Date(data.created);\n        result.updated = new Date(data.updated);\n        result.status = data.status;\n        return result;\n      });\n  }\n\n  /**\n   * Get a pronunciation challenge from the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {string} challengeId - Specify a pronunciation challenge identifier.\n   * @returns {Promise.<PronunciationChallenge>} Promise containing a PronunciationChallenge.\n   * @throws {Promise.<Error>} {@link PronunciationChallenge#id} field is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getPronunciationChallenge(challengeId) {\n    if (!challengeId) {\n      return Promise.reject(new Error('challengeId field is required'));\n    }\n    const url = this._connection._settings.apiUrl + '/challenges/pronunciation/' + challengeId;\n    return this._connection._secureAjaxGet(url)\n      .then(data => {\n        const challenge = new PronunciationChallenge(data.id, data.transcription, data.referenceAudioUrl);\n        challenge.created = new Date(data.created);\n        challenge.updated = new Date(data.updated);\n        challenge.status = data.status;\n        return challenge;\n      });\n  }\n\n  /**\n   * Get and return all pronunciation challenges in the current active {@link Organisation} derived from\n   * the OAuth2 scope.\n   *\n   * @returns {Promise.<PronunciationChallenge[]>} Promise containing a list of PronunciationChallenges.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getPronunciationChallenges() {\n    const url = this._connection._settings.apiUrl + '/challenges/pronunciation';\n    return this._connection._secureAjaxGet(url)\n      .then(data => data.map(datum => {\n        const challenge = new PronunciationChallenge(datum.id, datum.transcription, datum.referenceAudioUrl);\n        challenge.created = new Date(datum.created);\n        challenge.updated = new Date(datum.updated);\n        challenge.status = datum.status;\n        return challenge;\n      }));\n  }\n\n  /**\n   * Delete a pronunciation challenge from the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {string} challengeId - A pronunciation challenge identifier.\n   * @returns {Promise.<PronunciationChallenge>} Promise containing the given challenge ID.\n   * @throws {Promise.<Error>} {@link PronunciationChallenge#id} field is required.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  deletePronunciationChallenge(challengeId) {\n    if (!challengeId) {\n      return Promise.reject(new Error('challengeId field is required'));\n    }\n    const url = this._connection._settings.apiUrl + '/challenges/pronunciation/' +\n      challengeId;\n    return this._connection._secureAjaxDelete(url)\n      .then(() => challengeId);\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/pronunciation-challenge/pronunciation-challenge-controller.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 337,
    "kind": "class",
    "name": "PronunciationChallengeController",
    "memberof": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge-controller.js",
    "static": true,
    "longname": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge-controller.js~PronunciationChallengeController",
    "access": "private",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/pronunciation-challenge/pronunciation-challenge-controller.js",
    "importStyle": "PronunciationChallengeController",
    "description": "Controller class for the PronunciationChallenge model.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 338,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge-controller.js~PronunciationChallengeController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge-controller.js~PronunciationChallengeController#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "Connection"
        ],
        "spread": false,
        "optional": false,
        "name": "connection",
        "description": "Object to use for making a connection to the REST API and Websocket server."
      }
    ]
  },
  {
    "__docId__": 339,
    "kind": "member",
    "name": "_connection",
    "memberof": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge-controller.js~PronunciationChallengeController",
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge-controller.js~PronunciationChallengeController#_connection",
    "access": "private",
    "description": "Object to use for making a connection to the REST API and Websocket server.",
    "lineNumber": 16,
    "type": {
      "nullable": null,
      "types": [
        "Connection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 340,
    "kind": "method",
    "name": "createPronunciationChallenge",
    "memberof": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge-controller.js~PronunciationChallengeController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge-controller.js~PronunciationChallengeController#createPronunciationChallenge",
    "access": "public",
    "description": "Create a pronunciation challenge. The created challenge will be part of the current active {@link Organisation}\nderived from the OAuth2 scope.",
    "lineNumber": 30,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PronunciationChallenge>} Promise containing the newly created PronunciationChallenge."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "PronunciationChallenge"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "Object to create."
      },
      {
        "nullable": null,
        "types": [
          "Blob"
        ],
        "spread": false,
        "optional": false,
        "name": "audioBlob",
        "description": "Audio fragment to link to the challenge."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PronunciationChallenge>"
      ],
      "spread": false,
      "description": "Promise containing the newly created PronunciationChallenge."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "challenge parameter of type \"PronunciationChallenge\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "audioBlob parameter of type \"Blob\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 341,
    "kind": "method",
    "name": "getPronunciationChallenge",
    "memberof": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge-controller.js~PronunciationChallengeController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge-controller.js~PronunciationChallengeController#getPronunciationChallenge",
    "access": "public",
    "description": "Get a pronunciation challenge from the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 61,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PronunciationChallenge>} Promise containing a PronunciationChallenge."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "Specify a pronunciation challenge identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PronunciationChallenge>"
      ],
      "spread": false,
      "description": "Promise containing a PronunciationChallenge."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link PronunciationChallenge#id} field is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 342,
    "kind": "method",
    "name": "getPronunciationChallenges",
    "memberof": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge-controller.js~PronunciationChallengeController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge-controller.js~PronunciationChallengeController#getPronunciationChallenges",
    "access": "public",
    "description": "Get and return all pronunciation challenges in the current active {@link Organisation} derived from\nthe OAuth2 scope.",
    "lineNumber": 83,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PronunciationChallenge[]>} Promise containing a list of PronunciationChallenges."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PronunciationChallenge[]>"
      ],
      "spread": false,
      "description": "Promise containing a list of PronunciationChallenges."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ],
    "params": []
  },
  {
    "__docId__": 343,
    "kind": "method",
    "name": "deletePronunciationChallenge",
    "memberof": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge-controller.js~PronunciationChallengeController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge-controller.js~PronunciationChallengeController#deletePronunciationChallenge",
    "access": "public",
    "description": "Delete a pronunciation challenge from the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 103,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PronunciationChallenge>} Promise containing the given challenge ID."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "A pronunciation challenge identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PronunciationChallenge>"
      ],
      "spread": false,
      "description": "Promise containing the given challenge ID."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link PronunciationChallenge#id} field is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 344,
    "kind": "file",
    "name": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge.js",
    "content": "/**\n * @class PronunciationChallenge domain model\n */\nexport default class PronunciationChallenge {\n  /**\n   * Create a pronunciation challenge domain model.\n   *\n   * @param {?string} id - The pronunciation challenge identifier. If none is given, one is generated.\n   * @param {string} transcription - The spoken word or sentence as plain text.\n   * @param {?string} referenceAudioUrl - The reference audio fragment URL. If one is not yet available or audio is\n   * not yet registered to the challenge it can be set to 'null'.\n   * @throws {Error} id parameter of type \"string|null\" is required.\n   * @throws {Error} transcription parameter of type \"string\" is required.\n   * @throws {Error} referenceAudioUrl parameter of type \"string|null\" is required.\n   */\n  constructor(id = null, transcription, referenceAudioUrl = null) {\n    if (id !== null && typeof id !== 'string') {\n      throw new Error(\n        'id parameter of type \"string|null\" is required');\n    }\n\n    if (typeof transcription !== 'string') {\n      throw new Error(\n        'transcription parameter of type \"string\" is required');\n    }\n\n    if (referenceAudioUrl !== null && typeof referenceAudioUrl !== 'string') {\n      throw new Error('referenceAudioUrl parameter of type \"string|null\" is required');\n    }\n\n    /**\n     * The pronunciation challenge identifier. If none is given, one is generated.\n     * @type {string}\n     */\n    this.id = id;\n\n    /**\n     * The spoken word or sentence as plain text.\n     * @type {string}\n     */\n    this.transcription = transcription;\n\n    /**\n     * The status of the challenge's preparation. Either 'unprepared', 'preparing' or 'prepared'.\n     * @type {string}\n     */\n    this.status = null;\n\n    /**\n     * The reference audio fragment as streaming audio link.\n     * @type {string}\n     */\n    this.referenceAudioUrl = referenceAudioUrl;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/pronunciation-challenge/pronunciation-challenge.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 345,
    "kind": "class",
    "name": "PronunciationChallenge",
    "memberof": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge.js",
    "static": true,
    "longname": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge.js~PronunciationChallenge",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/pronunciation-challenge/pronunciation-challenge.js",
    "importStyle": "PronunciationChallenge",
    "description": "",
    "lineNumber": 4,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "PronunciationChallenge domain model"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 346,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge.js~PronunciationChallenge",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge.js~PronunciationChallenge#constructor",
    "access": "public",
    "description": "Create a pronunciation challenge domain model.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The pronunciation challenge identifier. If none is given, one is generated."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "transcription",
        "description": "The spoken word or sentence as plain text."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "referenceAudioUrl",
        "description": "The reference audio fragment URL. If one is not yet available or audio is\nnot yet registered to the challenge it can be set to 'null'."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "id parameter of type \"string|null\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "transcription parameter of type \"string\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "referenceAudioUrl parameter of type \"string|null\" is required."
      }
    ]
  },
  {
    "__docId__": 347,
    "kind": "member",
    "name": "id",
    "memberof": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge.js~PronunciationChallenge",
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge.js~PronunciationChallenge#id",
    "access": "public",
    "description": "The pronunciation challenge identifier. If none is given, one is generated.",
    "lineNumber": 35,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 348,
    "kind": "member",
    "name": "transcription",
    "memberof": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge.js~PronunciationChallenge",
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge.js~PronunciationChallenge#transcription",
    "access": "public",
    "description": "The spoken word or sentence as plain text.",
    "lineNumber": 41,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 349,
    "kind": "member",
    "name": "status",
    "memberof": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge.js~PronunciationChallenge",
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge.js~PronunciationChallenge#status",
    "access": "public",
    "description": "The status of the challenge's preparation. Either 'unprepared', 'preparing' or 'prepared'.",
    "lineNumber": 47,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 350,
    "kind": "member",
    "name": "referenceAudioUrl",
    "memberof": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge.js~PronunciationChallenge",
    "static": false,
    "longname": "src/administrative-sdk/pronunciation-challenge/pronunciation-challenge.js~PronunciationChallenge#referenceAudioUrl",
    "access": "public",
    "description": "The reference audio fragment as streaming audio link.",
    "lineNumber": 53,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 351,
    "kind": "file",
    "name": "src/administrative-sdk/role/role-controller.js",
    "content": "import Role from './role';\n\n/**\n * Controller class for the Role model.\n * @private\n */\nexport default class RoleController {\n  /**\n   * @param {Connection} connection - Object to use for making a connection to the REST API and Websocket server.\n   */\n  constructor(connection) {\n    /**\n     * Object to use for making a connection to the REST API and Websocket server.\n     * @type {Connection}\n     */\n    this._connection = connection;\n  }\n\n  /**\n   * Get and return all roles available in the API.\n   *\n   * @returns {Promise.<Role[]>} Promise containing an array of Roles.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  getRoles() {\n    const url = this._connection._settings.apiUrl + '/roles';\n    return this._connection._secureAjaxGet(url)\n      .then(data => data.map(datum => new Role(datum.name, datum.permissions)));\n  }\n\n  /**\n   * Get a single role.\n   *\n   * @param {string} roleId - Identifier of the role.\n   * @returns {Promise.<Role>} Promise containing a Role.\n   * @throws {Promise.<Error>} roleId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getRole(roleId) {\n    if (typeof roleId !== 'string') {\n      return Promise.reject(new Error('roleId parameter of type \"string\" is required'));\n    }\n    const url = this._connection._settings.apiUrl + '/roles/' + roleId;\n    return this._connection._secureAjaxGet(url)\n      .then(data => new Role(data.name, data.permissions));\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/role/role-controller.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 352,
    "kind": "class",
    "name": "RoleController",
    "memberof": "src/administrative-sdk/role/role-controller.js",
    "static": true,
    "longname": "src/administrative-sdk/role/role-controller.js~RoleController",
    "access": "private",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/role/role-controller.js",
    "importStyle": "RoleController",
    "description": "Controller class for the Role model.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 353,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/role/role-controller.js~RoleController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/role/role-controller.js~RoleController#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "Connection"
        ],
        "spread": false,
        "optional": false,
        "name": "connection",
        "description": "Object to use for making a connection to the REST API and Websocket server."
      }
    ]
  },
  {
    "__docId__": 354,
    "kind": "member",
    "name": "_connection",
    "memberof": "src/administrative-sdk/role/role-controller.js~RoleController",
    "static": false,
    "longname": "src/administrative-sdk/role/role-controller.js~RoleController#_connection",
    "access": "private",
    "description": "Object to use for making a connection to the REST API and Websocket server.",
    "lineNumber": 16,
    "type": {
      "nullable": null,
      "types": [
        "Connection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 355,
    "kind": "method",
    "name": "getRoles",
    "memberof": "src/administrative-sdk/role/role-controller.js~RoleController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/role/role-controller.js~RoleController#getRoles",
    "access": "public",
    "description": "Get and return all roles available in the API.",
    "lineNumber": 25,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Role[]>} Promise containing an array of Roles."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Role[]>"
      ],
      "spread": false,
      "description": "Promise containing an array of Roles."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ],
    "params": []
  },
  {
    "__docId__": 356,
    "kind": "method",
    "name": "getRole",
    "memberof": "src/administrative-sdk/role/role-controller.js~RoleController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/role/role-controller.js~RoleController#getRole",
    "access": "public",
    "description": "Get a single role.",
    "lineNumber": 39,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Role>} Promise containing a Role."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "roleId",
        "description": "Identifier of the role."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Role>"
      ],
      "spread": false,
      "description": "Promise containing a Role."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "roleId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 357,
    "kind": "file",
    "name": "src/administrative-sdk/role/role.js",
    "content": "/**\n * Role domain model. Represents a role a {@link User} can take on.\n */\nexport default class Role {\n  /**\n   * Create a Role.\n   *\n   * @param {string} name - Name of the role.\n   * @param {Array.<string>} permissions - Permissions this role can take on.\n   * @throws {Error} role parameter of type \"string\" is required.\n   * @throws {Error} permission parameter of type \"Array.<string>\" is required.\n   */\n  constructor(name, permissions) {\n    if (typeof name !== 'string') {\n      throw new Error('role parameter of type \"string\" is required');\n    }\n\n    if (!(permissions instanceof Array) || permissions.length === 0) {\n      throw new Error('permission parameter of type \"Array.<string>\" is required');\n    }\n\n    /**\n     * @type {string} Name of the role.\n     */\n    this.name = name;\n\n    /**\n     * @type {Array.<string>} Permissions this role can take on.\n     */\n    this.permissions = permissions;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/role/role.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 358,
    "kind": "class",
    "name": "Role",
    "memberof": "src/administrative-sdk/role/role.js",
    "static": true,
    "longname": "src/administrative-sdk/role/role.js~Role",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/role/role.js",
    "importStyle": "Role",
    "description": "Role domain model. Represents a role a {@link User} can take on.",
    "lineNumber": 4,
    "interface": false
  },
  {
    "__docId__": 359,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/role/role.js~Role",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/role/role.js~Role#constructor",
    "access": "public",
    "description": "Create a Role.",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of the role."
      },
      {
        "nullable": null,
        "types": [
          "Array.<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "permissions",
        "description": "Permissions this role can take on."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "role parameter of type \"string\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "permission parameter of type \"Array.<string>\" is required."
      }
    ]
  },
  {
    "__docId__": 360,
    "kind": "member",
    "name": "name",
    "memberof": "src/administrative-sdk/role/role.js~Role",
    "static": false,
    "longname": "src/administrative-sdk/role/role.js~Role#name",
    "access": "public",
    "description": "",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 361,
    "kind": "member",
    "name": "permissions",
    "memberof": "src/administrative-sdk/role/role.js~Role",
    "static": false,
    "longname": "src/administrative-sdk/role/role.js~Role#permissions",
    "access": "public",
    "description": "",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "Array.<string>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 362,
    "kind": "file",
    "name": "src/administrative-sdk/speech-challenge/speech-challenge-controller.js",
    "content": "import SpeechChallenge from './speech-challenge';\n\n/**\n * Controller class for the SpeechChallenge model.\n * @private\n */\nexport default class SpeechChallengeController {\n  /**\n   * @param {Connection} connection - Object to use for making a connection to the REST API and Websocket server.\n   */\n  constructor(connection) {\n    /**\n     * Object to use for making a connection to the REST API and Websocket server.\n     * @type {Connection}\n     */\n    this._connection = connection;\n  }\n\n  /**\n   * Create a speech challenge in the current active {@link Organisation} derived from the OAuth2 scope.\n   * The created speech challenge will not contain the submitted audio file, but instead a property\n   * `referenceAudioUrl` which is the URL to download the submitted audio file.\n   * Additional information like .srt files or images can also be added in HTML5 Blob format.\n   * The returned SpeechChallenge will contain links to download the given files.\n   *\n   * @param {SpeechChallenge} speechChallenge - Object to create.\n   * @param {?Blob} audioBlob - Audio fragment to link to the challenge.\n   * @param {?Blob} srtFile - SRT file in HTML5 Blob format to accompany the challenge.\n   * @param {?Blob} image - Image file in HTML5 Blob format to accompany the challenge.\n   * @param {?string} metadata - Metadata in String format to accompany the challenge.\n   * @returns {Promise.<PronunciationChallenge>} Promise containing the newly created SpeechChallenge.\n   * @throws {Promise.<Error>} speechChallenge field of type \"SpeechChallenge\" is required\n   * @throws {Promise.<Error>} audioBlob parameter of type \"Blob\" is required.\n   * @throws {Promise.<Error>} srtFile parameter of type \"Blob\" is required.\n   * @throws {Promise.<Error>} image parameter of type \"Blob\" is required.\n   * @throws {Promise.<Error>} metadata parameter of type \"String\" is required.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  createSpeechChallenge(speechChallenge, audioBlob = null, srtFile = null, image = null, metadata = null) {\n    if (!(speechChallenge instanceof SpeechChallenge)) {\n      return Promise.reject(new Error('speechChallenge field of type \"SpeechChallenge\" is required'));\n    }\n    if (audioBlob !== null && !(audioBlob instanceof Blob)) {\n      return Promise.reject(new Error('audioBlob parameter of type \"Blob|null\" is required'));\n    }\n    if (srtFile !== null && !(srtFile instanceof Blob)) {\n      return Promise.reject(new Error('srtFile parameter of type \"Blob|null\" is required'));\n    }\n    if (image !== null && !(image instanceof Blob)) {\n      return Promise.reject(new Error('image parameter of type \"Blob|null\" is required'));\n    }\n    if (metadata !== null && typeof metadata !== 'string') {\n      return Promise.reject(new Error('metadata parameter of type \"string|null\" is required'));\n    }\n    speechChallenge.referenceAudio = audioBlob;\n    speechChallenge.srt = srtFile;\n    speechChallenge.image = image;\n    speechChallenge.metadata = metadata;\n    const fd = JSON.stringify(speechChallenge);\n    const url = this._connection._settings.apiUrl + '/challenges/speech';\n\n    return this._connection._secureAjaxPost(url, fd)\n      .then(data => {\n        const result = new SpeechChallenge(data.id, data.topic, data.referenceAudioUrl,\n          data.srtUrl, data.imageUrl, data.metadata);\n        result.created = new Date(data.created);\n        result.updated = new Date(data.updated);\n        return result;\n      });\n  }\n\n  /**\n   * Get a speech challenge from the current active {@link Organisation} derived from the OAuth2 scope.\n   * The returned speech challenge will not contain an audio file, but instead a property\n   * `referenceAudioUrl` which is the URL to download the submitted audio file.\n   *\n   * @param {string} challengeId - Specify a speech challenge identifier.\n   * @returns {Promise.<PronunciationChallenge>} Promise containing a SpeechChallenge.\n   * @throws {Promise.<Error>} {@link SpeechChallenge#id} field of type \"string\" is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getSpeechChallenge(challengeId) {\n    if (typeof challengeId !== 'string') {\n      return Promise.reject(new Error('challengeId field of type \"string\" is required'));\n    }\n    const url = this._connection._settings.apiUrl + '/challenges/speech/' + challengeId;\n\n    return this._connection._secureAjaxGet(url)\n      .then(data => {\n        const challenge = new SpeechChallenge(data.id, data.topic, data.referenceAudioUrl,\n          data.srtUrl, data.imageUrl, data.metadata);\n        challenge.created = new Date(data.created);\n        challenge.updated = new Date(data.updated);\n        return challenge;\n      });\n  }\n\n  /**\n   * Get and return all speech challenges in the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @returns {Promise.<SpeechChallenge[]>} Promise containing an array of SpeechChallenges.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getSpeechChallenges() {\n    const url = this._connection._settings.apiUrl + '/challenges/speech';\n\n    return this._connection._secureAjaxGet(url)\n      .then(data => data.map(datum => {\n        const challenge = new SpeechChallenge(datum.id,\n          datum.topic, datum.referenceAudioUrl, data.srtUrl, data.imageUrl, data.metadata);\n        challenge.created = new Date(datum.created);\n        challenge.updated = new Date(datum.updated);\n        return challenge;\n      }));\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/speech-challenge/speech-challenge-controller.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 363,
    "kind": "class",
    "name": "SpeechChallengeController",
    "memberof": "src/administrative-sdk/speech-challenge/speech-challenge-controller.js",
    "static": true,
    "longname": "src/administrative-sdk/speech-challenge/speech-challenge-controller.js~SpeechChallengeController",
    "access": "private",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/speech-challenge/speech-challenge-controller.js",
    "importStyle": "SpeechChallengeController",
    "description": "Controller class for the SpeechChallenge model.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 364,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/speech-challenge/speech-challenge-controller.js~SpeechChallengeController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/speech-challenge/speech-challenge-controller.js~SpeechChallengeController#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "Connection"
        ],
        "spread": false,
        "optional": false,
        "name": "connection",
        "description": "Object to use for making a connection to the REST API and Websocket server."
      }
    ]
  },
  {
    "__docId__": 365,
    "kind": "member",
    "name": "_connection",
    "memberof": "src/administrative-sdk/speech-challenge/speech-challenge-controller.js~SpeechChallengeController",
    "static": false,
    "longname": "src/administrative-sdk/speech-challenge/speech-challenge-controller.js~SpeechChallengeController#_connection",
    "access": "private",
    "description": "Object to use for making a connection to the REST API and Websocket server.",
    "lineNumber": 16,
    "type": {
      "nullable": null,
      "types": [
        "Connection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 366,
    "kind": "method",
    "name": "createSpeechChallenge",
    "memberof": "src/administrative-sdk/speech-challenge/speech-challenge-controller.js~SpeechChallengeController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/speech-challenge/speech-challenge-controller.js~SpeechChallengeController#createSpeechChallenge",
    "access": "public",
    "description": "Create a speech challenge in the current active {@link Organisation} derived from the OAuth2 scope.\nThe created speech challenge will not contain the submitted audio file, but instead a property\n`referenceAudioUrl` which is the URL to download the submitted audio file.\nAdditional information like .srt files or images can also be added in HTML5 Blob format.\nThe returned SpeechChallenge will contain links to download the given files.",
    "lineNumber": 39,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PronunciationChallenge>} Promise containing the newly created SpeechChallenge."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "SpeechChallenge"
        ],
        "spread": false,
        "optional": false,
        "name": "speechChallenge",
        "description": "Object to create."
      },
      {
        "nullable": true,
        "types": [
          "Blob"
        ],
        "spread": false,
        "optional": false,
        "name": "audioBlob",
        "description": "Audio fragment to link to the challenge."
      },
      {
        "nullable": true,
        "types": [
          "Blob"
        ],
        "spread": false,
        "optional": false,
        "name": "srtFile",
        "description": "SRT file in HTML5 Blob format to accompany the challenge."
      },
      {
        "nullable": true,
        "types": [
          "Blob"
        ],
        "spread": false,
        "optional": false,
        "name": "image",
        "description": "Image file in HTML5 Blob format to accompany the challenge."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "metadata",
        "description": "Metadata in String format to accompany the challenge."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PronunciationChallenge>"
      ],
      "spread": false,
      "description": "Promise containing the newly created SpeechChallenge."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "speechChallenge field of type \"SpeechChallenge\" is required"
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "audioBlob parameter of type \"Blob\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "srtFile parameter of type \"Blob\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "image parameter of type \"Blob\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "metadata parameter of type \"String\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 367,
    "kind": "method",
    "name": "getSpeechChallenge",
    "memberof": "src/administrative-sdk/speech-challenge/speech-challenge-controller.js~SpeechChallengeController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/speech-challenge/speech-challenge-controller.js~SpeechChallengeController#getSpeechChallenge",
    "access": "public",
    "description": "Get a speech challenge from the current active {@link Organisation} derived from the OAuth2 scope.\nThe returned speech challenge will not contain an audio file, but instead a property\n`referenceAudioUrl` which is the URL to download the submitted audio file.",
    "lineNumber": 82,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<PronunciationChallenge>} Promise containing a SpeechChallenge."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "Specify a speech challenge identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<PronunciationChallenge>"
      ],
      "spread": false,
      "description": "Promise containing a SpeechChallenge."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link SpeechChallenge#id} field of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 368,
    "kind": "method",
    "name": "getSpeechChallenges",
    "memberof": "src/administrative-sdk/speech-challenge/speech-challenge-controller.js~SpeechChallengeController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/speech-challenge/speech-challenge-controller.js~SpeechChallengeController#getSpeechChallenges",
    "access": "public",
    "description": "Get and return all speech challenges in the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 104,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<SpeechChallenge[]>} Promise containing an array of SpeechChallenges."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<SpeechChallenge[]>"
      ],
      "spread": false,
      "description": "Promise containing an array of SpeechChallenges."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ],
    "params": []
  },
  {
    "__docId__": 369,
    "kind": "file",
    "name": "src/administrative-sdk/speech-challenge/speech-challenge.js",
    "content": "/**\n * @class SpeechChallenge domain model.\n */\nexport default class SpeechChallenge {\n  /**\n   * Create a speech SpeechChallenge domain model.\n   *\n   * @param {?string} id - The speech challenge identifier. If none is given, one is generated.\n   * @param {?string} topic - A question or topic serving as guidance.\n   * @param {?string} referenceAudioUrl - The reference audio fragment URL. If one is not yet available or audio is\n   * not yet registered to the challenge it can be set to 'null'.\n   * @param {?string} srtUrl - URL of a possible .srt file to accompany this challenge.\n   * @param {?string} imageUrl - URL of a possible image file to accompany this challenge.\n   * @param {?string} metadata - Metadata string. Can contain any kind of information that helps.\n   * @throws {Error} srtUrl parameter of type \"string|null\" is required.\n   * @throws {Error} imageUrl parameter of type \"string|null\" is required.\n   * @throws {Error} metadata parameter of type \"string|null\" is required.\n   */\n  constructor(id = null, topic = null, referenceAudioUrl = null, srtUrl = null, imageUrl = null, metadata = null) {\n    if (id !== null && typeof id !== 'string') {\n      throw new Error(\n        'id parameter of type \"string|null\" is required');\n    }\n\n    if (topic !== null && typeof topic !== 'string') {\n      throw new Error(\n        'topic parameter of type \"string|null\" is required');\n    }\n\n    if (referenceAudioUrl !== null && typeof referenceAudioUrl !== 'string') {\n      throw new Error(\n        'referenceAudioUrl parameter of type \"string|null\" is required');\n    }\n\n    if (srtUrl !== null && typeof srtUrl !== 'string') {\n      throw new Error('srtUrl parameter of type \"string|null\" is required');\n    }\n\n    if (imageUrl !== null && typeof imageUrl !== 'string') {\n      throw new Error('imageUrl parameter of type \"string|null\" is required');\n    }\n\n    if (metadata !== null && typeof metadata !== 'string') {\n      throw new Error('metadata parameter of type \"string|null\" is required');\n    }\n\n    /**\n     * The speech challenge identifier. If none is given, one is generated.\n     * @type {string}\n     */\n    this.id = id;\n\n    /**\n     * A question or topic serving as guidance.\n     * @type {string}\n     */\n    this.topic = topic;\n\n    /**\n     * The reference audio fragment as streaming audio link.\n     * @type {string}\n     */\n    this.referenceAudioUrl = referenceAudioUrl;\n\n    /**\n     * URL of a possible .srt file to accompany this challenge.\n     * @type {string}\n     */\n    this.srtUrl = srtUrl;\n\n    /**\n     * URL of a possible image file to accompany this challenge.\n     * @type {string}\n     */\n    this.imageUrl = imageUrl;\n\n    /**\n     * Metadata string. Can contain any kind of information that helps.\n     * @type {string}\n     */\n    this.metadata = metadata;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/speech-challenge/speech-challenge.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 370,
    "kind": "class",
    "name": "SpeechChallenge",
    "memberof": "src/administrative-sdk/speech-challenge/speech-challenge.js",
    "static": true,
    "longname": "src/administrative-sdk/speech-challenge/speech-challenge.js~SpeechChallenge",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/speech-challenge/speech-challenge.js",
    "importStyle": "SpeechChallenge",
    "description": "",
    "lineNumber": 4,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "SpeechChallenge domain model."
      }
    ],
    "interface": false
  },
  {
    "__docId__": 371,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/speech-challenge/speech-challenge.js~SpeechChallenge",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/speech-challenge/speech-challenge.js~SpeechChallenge#constructor",
    "access": "public",
    "description": "Create a speech SpeechChallenge domain model.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The speech challenge identifier. If none is given, one is generated."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "topic",
        "description": "A question or topic serving as guidance."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "referenceAudioUrl",
        "description": "The reference audio fragment URL. If one is not yet available or audio is\nnot yet registered to the challenge it can be set to 'null'."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "srtUrl",
        "description": "URL of a possible .srt file to accompany this challenge."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "imageUrl",
        "description": "URL of a possible image file to accompany this challenge."
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "metadata",
        "description": "Metadata string. Can contain any kind of information that helps."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "srtUrl parameter of type \"string|null\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "imageUrl parameter of type \"string|null\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "metadata parameter of type \"string|null\" is required."
      }
    ]
  },
  {
    "__docId__": 372,
    "kind": "member",
    "name": "id",
    "memberof": "src/administrative-sdk/speech-challenge/speech-challenge.js~SpeechChallenge",
    "static": false,
    "longname": "src/administrative-sdk/speech-challenge/speech-challenge.js~SpeechChallenge#id",
    "access": "public",
    "description": "The speech challenge identifier. If none is given, one is generated.",
    "lineNumber": 51,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 373,
    "kind": "member",
    "name": "topic",
    "memberof": "src/administrative-sdk/speech-challenge/speech-challenge.js~SpeechChallenge",
    "static": false,
    "longname": "src/administrative-sdk/speech-challenge/speech-challenge.js~SpeechChallenge#topic",
    "access": "public",
    "description": "A question or topic serving as guidance.",
    "lineNumber": 57,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 374,
    "kind": "member",
    "name": "referenceAudioUrl",
    "memberof": "src/administrative-sdk/speech-challenge/speech-challenge.js~SpeechChallenge",
    "static": false,
    "longname": "src/administrative-sdk/speech-challenge/speech-challenge.js~SpeechChallenge#referenceAudioUrl",
    "access": "public",
    "description": "The reference audio fragment as streaming audio link.",
    "lineNumber": 63,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 375,
    "kind": "member",
    "name": "srtUrl",
    "memberof": "src/administrative-sdk/speech-challenge/speech-challenge.js~SpeechChallenge",
    "static": false,
    "longname": "src/administrative-sdk/speech-challenge/speech-challenge.js~SpeechChallenge#srtUrl",
    "access": "public",
    "description": "URL of a possible .srt file to accompany this challenge.",
    "lineNumber": 69,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 376,
    "kind": "member",
    "name": "imageUrl",
    "memberof": "src/administrative-sdk/speech-challenge/speech-challenge.js~SpeechChallenge",
    "static": false,
    "longname": "src/administrative-sdk/speech-challenge/speech-challenge.js~SpeechChallenge#imageUrl",
    "access": "public",
    "description": "URL of a possible image file to accompany this challenge.",
    "lineNumber": 75,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 377,
    "kind": "member",
    "name": "metadata",
    "memberof": "src/administrative-sdk/speech-challenge/speech-challenge.js~SpeechChallenge",
    "static": false,
    "longname": "src/administrative-sdk/speech-challenge/speech-challenge.js~SpeechChallenge#metadata",
    "access": "public",
    "description": "Metadata string. Can contain any kind of information that helps.",
    "lineNumber": 81,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 378,
    "kind": "file",
    "name": "src/administrative-sdk/speech-recording/speech-recording-controller.js",
    "content": "import Base64Utils from '../utils/base64-utils';\nimport Connection from '../connection/connection-controller';\nimport SpeechRecording from './speech-recording';\nimport when from 'when';\n\n/**\n * Controller class for the SpeechRecording model.\n * @private\n */\nexport default class SpeechRecordingController {\n  /**\n   * @param {Connection} connection - Object to use for making a connection to the REST API and Websocket server.\n   */\n  constructor(connection) {\n    this._connection = connection;\n  }\n\n  /**\n   * Initialise the speech recording challenge through RPCs.\n   *\n   * @param {SpeechChallenge} challenge - SpeechChallenge.\n   * @private\n   */\n  speechRecordingInitChallenge(challenge) {\n    return this._connection.call('recording.init_challenge',\n      [this._connection._recordingId, challenge.id]).then(\n      // RPC success callback\n      recordingId => {\n        console.log('Challenge initialised for recordingId: ' + this._connection._recordingId);\n        return recordingId;\n      });\n  }\n\n  /**\n   * Initialise the speech recording audio specs through RPCs.\n   *\n   * @param {AudioRecorder} recorder - AudioRecorder.\n   * @param {Function} dataavailableCb - Callback.\n   * @private\n   */\n  speechRecordingInitAudio(recorder, dataavailableCb) {\n    // Indicate to the socket server that we're about to start recording a\n    // challenge. This allows the socket server some time to fetch the metadata\n    // and reference audio to start the recording when audio is actually submitted.\n    const specs = recorder.getAudioSpecs();\n    return this._connection.call('recording.init_audio',\n      [this._connection._recordingId, specs.audioFormat], specs.audioParameters)\n      .then(recordingId => {\n        console.log('Accepted audio parameters for recordingId after init_audio: ' + this._connection._recordingId);\n        // Start listening for streaming data.\n        recorder.addEventListener('dataavailable', dataavailableCb);\n        return recordingId;\n      });\n  }\n\n  /**\n   * Start a speech recording from streaming audio.\n   *\n   * @param {SpeechChallenge} challenge - The speech challenge to perform.\n   * @param {AudioRecorder} recorder - The audio recorder to extract audio from.\n   * @returns {Promise.<SpeechRecording>} A {@link https://github.com/cujojs/when} Promise containing a {@link SpeechRecording}.\n   * @emits {string} 'ReadyToReceive' when the call is made to receive audio. The recorder can now send audio.\n   * @throws {Promise.<Error>} If challenge is not an object or not defined.\n   * @throws {Promise.<Error>} If challenge has no id.\n   * @throws {Promise.<Error>} If the connection is not open.\n   * @throws {Promise.<Error>} If the recorder is already recording.\n   * @throws {Promise.<Error>} If a session is already in progress.\n   * @throws {Promise.<Error>} If something went wrong during recording.\n   */\n  startStreamingSpeechRecording(challenge, recorder) {\n    // Validate required domain model.\n    // Validate environment prerequisites.\n    if (typeof challenge !== 'object' || !challenge) {\n      return Promise.reject(new Error('\"challenge\" parameter is required or invalid'));\n    }\n    if (!challenge.id) {\n      return Promise.reject(new Error('challenge.id field is required'));\n    }\n    if (!this._connection._session) {\n      return Promise.reject(new Error('WebSocket connection was not open.'));\n    }\n    if (recorder.isRecording()) {\n      return Promise.reject(new Error('Recorder should not yet be recording.'));\n    }\n    if (this._connection._recordingId !== null) {\n      return Promise.reject(new Error('Session with recordingId ' + this._connection._recordingId +\n        ' still in progress.'));\n    }\n    const self = this;\n    return new when.Promise((resolve, reject, notify) => {\n      self._connection._recordingId = null;\n\n      function _cb(data) {\n        const recording = new SpeechRecording(\n          challenge.id, data.userId, data.id, new Date(data.created), new Date(data.updated),\n          self._connection.addAccessToken(data.audioUrl));\n        resolve({recordingId: self._connection._recordingId, recording});\n      }\n\n      function recordedCb(activeRecordingId, audioBlob, forcedStop) {\n        self._connection.call('recording.close',\n          [self._connection._recordingId]).then(\n          // RPC success callback\n          res => {\n            // Pass along details to the success callback\n            _cb(res, forcedStop);\n          },\n          // RPC error callback\n          res => {\n            Connection.logRPCError(res);\n            reject(res);\n          });\n        recorder.removeEventListener('recorded', recordedCb);\n        recorder.removeEventListener('dataavailable', startStreaming);\n      }\n\n      // Start streaming the binary audio when the user instructs\n      // the audio recorder to start recording.\n      function startStreaming(chunk) {\n        const encoded = Base64Utils._arrayBufferToBase64(chunk);\n        console.log('Sending audio chunk to websocket for recordingId: ' +\n          self._connection._recordingId);\n        self._connection.call('recording.write',\n          [self._connection._recordingId, encoded, 'base64']).then(\n          // RPC success callback\n          res => {\n            // Wrote data.\n            console.log('Wrote data');\n            return res;\n          },\n          // RPC error callback\n          res => {\n            Connection.logRPCError(res);\n            reject(res);\n          }\n        );\n      }\n\n      function startRecording(recordingId) {\n        self._connection._recordingId = recordingId;\n        console.log('Got recordingId after initialisation: ' + self._connection._recordingId);\n      }\n\n      recorder.addEventListener('recorded', recordedCb);\n      self._connection.call('recording.init_recording', [])\n        .then(startRecording)\n        .then(() =>\n          self.speechRecordingInitChallenge(challenge)\n            .then(() => {\n              const p = new Promise(resolve_ => {\n                if (recorder.hasUserMediaApproval()) {\n                  resolve_();\n                } else {\n                  recorder.addEventListener('ready', resolve_);\n                }\n              });\n              p.then(() => {\n                self.speechRecordingInitAudio(recorder, startStreaming)\n                  .catch(reject);\n              });\n            })\n            .then(() => notify('ReadyToReceive'))\n        )\n        .catch(reject);\n    })\n      .then(res => {\n        self._connection._recordingId = null;\n        return Promise.resolve(res);\n      })\n      .catch(error => {\n        self._connection._recordingId = null;\n        Connection.logRPCError(error);\n        return Promise.reject(error);\n      });\n  }\n\n  /**\n   * Get a speech recording in a speech challenge from the current active {@link Organisation} derived from the OAuth2\n   * scope.\n   *\n   * @param {string} challengeId - Specify a speech challenge identifier.\n   * @param {string} recordingId - Specify a speech recording identifier.\n   * @returns {Promise.<SpeechRecording>} Promise containing a SpeechRecording.\n   * @throws {Promise.<Error>} {@link SpeechChallenge#id} field is required.\n   * @throws {Promise.<Error>} {@link SpeechRecording#id} field is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getSpeechRecording(challengeId, recordingId) {\n    if (!challengeId) {\n      return Promise.reject(new Error('challengeId field is required'));\n    }\n    if (!recordingId) {\n      return Promise.reject(new Error('recordingId field is required'));\n    }\n    const url = this._connection._settings.apiUrl + '/challenges/speech/' + challengeId + '/recordings/' + recordingId;\n    return this._connection._secureAjaxGet(url)\n      .then(data => new SpeechRecording(challengeId, data.userId, data.id, new Date(data.created),\n        new Date(data.updated), this._connection.addAccessToken(data.audioUrl)));\n  }\n\n  /**\n   * Get and return all speech recordings in a specific speech challenge from the current active {@link Organisation}\n   * derived from the OAuth2 scope.\n   *\n   * @param {string} challengeId - Specify a speech challenge identifier to list speech recordings for.\n   * @returns {Promise.<SpeechRecording[]>} Promise containing an array of SpeechRecording.\n   * @throws {Promise.<Error>} {@link SpeechChallenge#id} is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getSpeechRecordings(challengeId) {\n    if (!challengeId) {\n      return Promise.reject(new Error('challengeId field is required'));\n    }\n    const url = this._connection._settings.apiUrl + '/challenges/speech/' + challengeId + '/recordings';\n    return this._connection._secureAjaxGet(url)\n      .then(data => data.map(datum => new SpeechRecording(challengeId, datum.userId, datum.id, new Date(datum.created),\n        new Date(datum.updated), this._connection.addAccessToken(datum.audioUrl))));\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/speech-recording/speech-recording-controller.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 379,
    "kind": "class",
    "name": "SpeechRecordingController",
    "memberof": "src/administrative-sdk/speech-recording/speech-recording-controller.js",
    "static": true,
    "longname": "src/administrative-sdk/speech-recording/speech-recording-controller.js~SpeechRecordingController",
    "access": "private",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/speech-recording/speech-recording-controller.js",
    "importStyle": "SpeechRecordingController",
    "description": "Controller class for the SpeechRecording model.",
    "lineNumber": 10,
    "interface": false
  },
  {
    "__docId__": 380,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/speech-recording/speech-recording-controller.js~SpeechRecordingController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/speech-recording/speech-recording-controller.js~SpeechRecordingController#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "Connection"
        ],
        "spread": false,
        "optional": false,
        "name": "connection",
        "description": "Object to use for making a connection to the REST API and Websocket server."
      }
    ]
  },
  {
    "__docId__": 381,
    "kind": "member",
    "name": "_connection",
    "memberof": "src/administrative-sdk/speech-recording/speech-recording-controller.js~SpeechRecordingController",
    "static": false,
    "longname": "src/administrative-sdk/speech-recording/speech-recording-controller.js~SpeechRecordingController#_connection",
    "access": "private",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 382,
    "kind": "method",
    "name": "speechRecordingInitChallenge",
    "memberof": "src/administrative-sdk/speech-recording/speech-recording-controller.js~SpeechRecordingController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/speech-recording/speech-recording-controller.js~SpeechRecordingController#speechRecordingInitChallenge",
    "access": "private",
    "description": "Initialise the speech recording challenge through RPCs.",
    "lineNumber": 24,
    "params": [
      {
        "nullable": null,
        "types": [
          "SpeechChallenge"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "SpeechChallenge."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 383,
    "kind": "method",
    "name": "speechRecordingInitAudio",
    "memberof": "src/administrative-sdk/speech-recording/speech-recording-controller.js~SpeechRecordingController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/speech-recording/speech-recording-controller.js~SpeechRecordingController#speechRecordingInitAudio",
    "access": "private",
    "description": "Initialise the speech recording audio specs through RPCs.",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "AudioRecorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "AudioRecorder."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "dataavailableCb",
        "description": "Callback."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 384,
    "kind": "method",
    "name": "startStreamingSpeechRecording",
    "memberof": "src/administrative-sdk/speech-recording/speech-recording-controller.js~SpeechRecordingController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/speech-recording/speech-recording-controller.js~SpeechRecordingController#startStreamingSpeechRecording",
    "access": "public",
    "description": "Start a speech recording from streaming audio.",
    "lineNumber": 70,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<SpeechRecording>} A {@link https://github.com/cujojs/when} Promise containing a {@link SpeechRecording}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "SpeechChallenge"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "The speech challenge to perform."
      },
      {
        "nullable": null,
        "types": [
          "AudioRecorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "The audio recorder to extract audio from."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<SpeechRecording>"
      ],
      "spread": false,
      "description": "A {@link https://github.com/cujojs/when} Promise containing a {@link SpeechRecording}."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If challenge is not an object or not defined."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If challenge has no id."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the connection is not open."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the recorder is already recording."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If a session is already in progress."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If something went wrong during recording."
      }
    ],
    "emits": [
      {
        "types": [
          "string"
        ],
        "description": "'ReadyToReceive' when the call is made to receive audio. The recorder can now send audio."
      }
    ]
  },
  {
    "__docId__": 385,
    "kind": "method",
    "name": "getSpeechRecording",
    "memberof": "src/administrative-sdk/speech-recording/speech-recording-controller.js~SpeechRecordingController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/speech-recording/speech-recording-controller.js~SpeechRecordingController#getSpeechRecording",
    "access": "public",
    "description": "Get a speech recording in a speech challenge from the current active {@link Organisation} derived from the OAuth2\nscope.",
    "lineNumber": 188,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<SpeechRecording>} Promise containing a SpeechRecording."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "Specify a speech challenge identifier."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "recordingId",
        "description": "Specify a speech recording identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<SpeechRecording>"
      ],
      "spread": false,
      "description": "Promise containing a SpeechRecording."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link SpeechChallenge#id} field is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link SpeechRecording#id} field is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 386,
    "kind": "method",
    "name": "getSpeechRecordings",
    "memberof": "src/administrative-sdk/speech-recording/speech-recording-controller.js~SpeechRecordingController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/speech-recording/speech-recording-controller.js~SpeechRecordingController#getSpeechRecordings",
    "access": "public",
    "description": "Get and return all speech recordings in a specific speech challenge from the current active {@link Organisation}\nderived from the OAuth2 scope.",
    "lineNumber": 210,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<SpeechRecording[]>} Promise containing an array of SpeechRecording."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "Specify a speech challenge identifier to list speech recordings for."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<SpeechRecording[]>"
      ],
      "spread": false,
      "description": "Promise containing an array of SpeechRecording."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "{@link SpeechChallenge#id} is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 387,
    "kind": "file",
    "name": "src/administrative-sdk/speech-recording/speech-recording.js",
    "content": "/**\n * @class SpeechRecording domain model\n */\nexport default class SpeechRecording {\n  /**\n   * Create a speech recording domain model.\n   *\n   * @param {string} challengeId - The SpeechChallenge identifier this speech is recorded for.\n   * @param {string} userId - The User identifier on whose behalf this audio is recorded.\n   * @param {string} id - The speech recording identifier.\n   * @param {Date} created - The creation date of the entity.\n   * @param {Date} updated - The most recent update date of the entity.\n   * @param {string} audioUrl - The audio fragment as streaming audio link.\n   */\n  constructor(challengeId, userId, id, created, updated, audioUrl) {\n    /**\n     * The speech recording identifier.\n     * @type {string}\n     */\n    this.id = id;\n\n    /**\n     * The SpeechChallenge identifier this speech is recorded for.\n     * @type {string}\n     */\n    this.challengeId = challengeId;\n\n    /**\n     * The User instance on whose behalf this audio is recorded.\n     * @type {string}\n     */\n    this.userId = userId;\n\n    /**\n     * The creation date of the entity.\n     * @type {Date}\n     */\n    this.created = created;\n\n    /**\n     * The most recent update date of the entity.\n     * @type {Date}\n     */\n    this.updated = updated;\n\n    /**\n     * The audio fragment as streaming audio link.\n     * @type {string}\n     */\n    this.audioUrl = audioUrl;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/speech-recording/speech-recording.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 388,
    "kind": "class",
    "name": "SpeechRecording",
    "memberof": "src/administrative-sdk/speech-recording/speech-recording.js",
    "static": true,
    "longname": "src/administrative-sdk/speech-recording/speech-recording.js~SpeechRecording",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/speech-recording/speech-recording.js",
    "importStyle": "SpeechRecording",
    "description": "",
    "lineNumber": 4,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "SpeechRecording domain model"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 389,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/speech-recording/speech-recording.js~SpeechRecording",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/speech-recording/speech-recording.js~SpeechRecording#constructor",
    "access": "public",
    "description": "Create a speech recording domain model.",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "The SpeechChallenge identifier this speech is recorded for."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": "The User identifier on whose behalf this audio is recorded."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The speech recording identifier."
      },
      {
        "nullable": null,
        "types": [
          "Date"
        ],
        "spread": false,
        "optional": false,
        "name": "created",
        "description": "The creation date of the entity."
      },
      {
        "nullable": null,
        "types": [
          "Date"
        ],
        "spread": false,
        "optional": false,
        "name": "updated",
        "description": "The most recent update date of the entity."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "audioUrl",
        "description": "The audio fragment as streaming audio link."
      }
    ]
  },
  {
    "__docId__": 390,
    "kind": "member",
    "name": "id",
    "memberof": "src/administrative-sdk/speech-recording/speech-recording.js~SpeechRecording",
    "static": false,
    "longname": "src/administrative-sdk/speech-recording/speech-recording.js~SpeechRecording#id",
    "access": "public",
    "description": "The speech recording identifier.",
    "lineNumber": 20,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 391,
    "kind": "member",
    "name": "challengeId",
    "memberof": "src/administrative-sdk/speech-recording/speech-recording.js~SpeechRecording",
    "static": false,
    "longname": "src/administrative-sdk/speech-recording/speech-recording.js~SpeechRecording#challengeId",
    "access": "public",
    "description": "The SpeechChallenge identifier this speech is recorded for.",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 392,
    "kind": "member",
    "name": "userId",
    "memberof": "src/administrative-sdk/speech-recording/speech-recording.js~SpeechRecording",
    "static": false,
    "longname": "src/administrative-sdk/speech-recording/speech-recording.js~SpeechRecording#userId",
    "access": "public",
    "description": "The User instance on whose behalf this audio is recorded.",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 393,
    "kind": "member",
    "name": "created",
    "memberof": "src/administrative-sdk/speech-recording/speech-recording.js~SpeechRecording",
    "static": false,
    "longname": "src/administrative-sdk/speech-recording/speech-recording.js~SpeechRecording#created",
    "access": "public",
    "description": "The creation date of the entity.",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "Date"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 394,
    "kind": "member",
    "name": "updated",
    "memberof": "src/administrative-sdk/speech-recording/speech-recording.js~SpeechRecording",
    "static": false,
    "longname": "src/administrative-sdk/speech-recording/speech-recording.js~SpeechRecording#updated",
    "access": "public",
    "description": "The most recent update date of the entity.",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "Date"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 395,
    "kind": "member",
    "name": "audioUrl",
    "memberof": "src/administrative-sdk/speech-recording/speech-recording.js~SpeechRecording",
    "static": false,
    "longname": "src/administrative-sdk/speech-recording/speech-recording.js~SpeechRecording#audioUrl",
    "access": "public",
    "description": "The audio fragment as streaming audio link.",
    "lineNumber": 50,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 396,
    "kind": "file",
    "name": "src/administrative-sdk/user/user-controller.js",
    "content": "import User from './user';\n\n/**\n * Controller class for the User model.\n * @private\n */\nexport default class UserController {\n  /**\n   * @param {Connection} connection - Object to use for making a connection to the REST API and Websocket server.\n   */\n  constructor(connection) {\n    /**\n     * Object to use for making a connection to the REST API and Websocket server.\n     * @type {Connection}\n     */\n    this._connection = connection;\n  }\n\n  /**\n   * Create a user. The user will be created in the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {User} user - User to create.\n   * @returns {Promise.<User>} Promise containing the newly created User.\n   * @throws {Promise.<Error>} user parameter of type \"User\" is required.\n   * @throws {Promise.<Error>} If the server returned an error.\n   */\n  createUser(user) {\n    if (!(user instanceof User)) {\n      return Promise.reject(new Error('user parameter of type \"User\" is required'));\n    }\n    const url = this._connection._settings.apiUrl + '/users';\n    const fd = JSON.stringify(user);\n    return this._connection._secureAjaxPost(url, fd)\n      .then(data => {\n        const result = new User(data.id, data.roles, data.profile, data.groups);\n        result.created = new Date(data.created);\n        result.updated = new Date(data.updated);\n        return result;\n      });\n  }\n\n  /**\n   * Get a user in the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @param {string} userId - Specify a user identifier.\n   * @returns {Promise.<User>} Promise containing a User.\n   * @throws {Promise.<Error>} userId parameter of type \"string\" is required.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getUser(userId) {\n    if (typeof userId !== 'string') {\n      return Promise.reject(new Error('userId parameter of type \"string\" is required'));\n    }\n    const url = this._connection._settings.apiUrl + '/users/' + userId;\n    return this._connection._secureAjaxGet(url)\n      .then(data => {\n        const user = new User(data.id, data.roles, data.profile, data.groups);\n        user.created = new Date(data.created);\n        user.updated = new Date(data.updated);\n        return user;\n      });\n  }\n\n  /**\n   * List all users in the current active {@link Organisation} derived from the OAuth2 scope.\n   *\n   * @returns {Promise.<User[]>} Promise containing an array of Users.\n   * @throws {Promise.<Error>} If no result could not be found.\n   */\n  getUsers() {\n    const url = this._connection._settings.apiUrl + '/users';\n    return this._connection._secureAjaxGet(url)\n      .then(data => data.map(datum => {\n        const user = new User(datum.id, datum.roles, datum.profile, datum.groups);\n        user.created = new Date(datum.created);\n        user.updated = new Date(datum.updated);\n        return user;\n      }));\n  }\n\n  /**\n   * Get the current authenticated user.\n   *\n   * @returns {Promise.<User>} The current authenticated user.\n   * @throws {Promise.<Error>} If something went wrong in the server.\n   */\n  getCurrentUser() {\n    const url = this._connection._settings.apiUrl + '/user';\n    return this._connection._secureAjaxGet(url)\n      .then(data => {\n        const user = new User(data.id, data.roles, data.profile, data.groups);\n        user.created = new Date(data.created);\n        user.updated = new Date(data.updated);\n        return user;\n      });\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/user/user-controller.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 397,
    "kind": "class",
    "name": "UserController",
    "memberof": "src/administrative-sdk/user/user-controller.js",
    "static": true,
    "longname": "src/administrative-sdk/user/user-controller.js~UserController",
    "access": "private",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/user/user-controller.js",
    "importStyle": "UserController",
    "description": "Controller class for the User model.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 398,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/user/user-controller.js~UserController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/user/user-controller.js~UserController#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "Connection"
        ],
        "spread": false,
        "optional": false,
        "name": "connection",
        "description": "Object to use for making a connection to the REST API and Websocket server."
      }
    ]
  },
  {
    "__docId__": 399,
    "kind": "member",
    "name": "_connection",
    "memberof": "src/administrative-sdk/user/user-controller.js~UserController",
    "static": false,
    "longname": "src/administrative-sdk/user/user-controller.js~UserController#_connection",
    "access": "private",
    "description": "Object to use for making a connection to the REST API and Websocket server.",
    "lineNumber": 16,
    "type": {
      "nullable": null,
      "types": [
        "Connection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 400,
    "kind": "method",
    "name": "createUser",
    "memberof": "src/administrative-sdk/user/user-controller.js~UserController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/user/user-controller.js~UserController#createUser",
    "access": "public",
    "description": "Create a user. The user will be created in the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<User>} Promise containing the newly created User."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "User"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "User to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<User>"
      ],
      "spread": false,
      "description": "Promise containing the newly created User."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "user parameter of type \"User\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If the server returned an error."
      }
    ]
  },
  {
    "__docId__": 401,
    "kind": "method",
    "name": "getUser",
    "memberof": "src/administrative-sdk/user/user-controller.js~UserController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/user/user-controller.js~UserController#getUser",
    "access": "public",
    "description": "Get a user in the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<User>} Promise containing a User."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": "Specify a user identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<User>"
      ],
      "spread": false,
      "description": "Promise containing a User."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "userId parameter of type \"string\" is required."
      },
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ]
  },
  {
    "__docId__": 402,
    "kind": "method",
    "name": "getUsers",
    "memberof": "src/administrative-sdk/user/user-controller.js~UserController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/user/user-controller.js~UserController#getUsers",
    "access": "public",
    "description": "List all users in the current active {@link Organisation} derived from the OAuth2 scope.",
    "lineNumber": 70,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<User[]>} Promise containing an array of Users."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<User[]>"
      ],
      "spread": false,
      "description": "Promise containing an array of Users."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If no result could not be found."
      }
    ],
    "params": []
  },
  {
    "__docId__": 403,
    "kind": "method",
    "name": "getCurrentUser",
    "memberof": "src/administrative-sdk/user/user-controller.js~UserController",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/user/user-controller.js~UserController#getCurrentUser",
    "access": "public",
    "description": "Get the current authenticated user.",
    "lineNumber": 87,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<User>} The current authenticated user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<User>"
      ],
      "spread": false,
      "description": "The current authenticated user."
    },
    "throws": [
      {
        "types": [
          "Promise.<Error>"
        ],
        "description": "If something went wrong in the server."
      }
    ],
    "params": []
  },
  {
    "__docId__": 404,
    "kind": "file",
    "name": "src/administrative-sdk/user/user.js",
    "content": "import Profile from '../profile/profile';\n\n/**\n * @class User domain model\n */\nexport default class User {\n  /**\n   * Create a User domain model.\n   *\n   * @param {?string} id - The user identifier. If none is given, one is generated.\n   * @param {Array<.string>} roles - Names of the {@link Role}s this user can take on.\n   * @param {?Profile} profile - Profile of the User.\n   * @param {?Array.<Group>} groups - Groups this User is part of.\n   * @throws {Error} id parameter of type \"string|null\" is required.\n   * @throws {Error} profile parameter of type \"Profile|null\" is required.\n   * @throws {Error} groups parameter of type \"Array.<Groups>|null\" is required.\n   * @throws {Error} non-empty roles parameter of type \"Array.<String>\" is required.\n   */\n  constructor(id, roles, profile = null, groups = null) {\n    if (id !== null && typeof id !== 'string') {\n      throw new Error('id parameter of type \"string|null\" is required');\n    }\n\n    if (!Array.isArray(roles) || roles.length === 0) {\n      throw new Error('non-empty roles parameter of type \"Array.<string>\" is required');\n    }\n\n    if (profile !== null && !(profile instanceof Profile)) {\n      throw new Error('profile parameter of type \"Profile|null\" is required');\n    }\n\n    if (groups !== null && !Array.isArray(groups)) {\n      throw new Error('groups parameter of type \"Array.<Groups>|null\" is required');\n    }\n\n    /**\n     * The user identifier. If none is given, one is generated.\n     * @type {string}\n     */\n    this.id = id;\n\n    /**\n     * Names of the {@link Role}s this user can take on.\n     * @type {Array.<.Role>}\n     */\n    this.roles = roles;\n\n    /**\n     * Profile of the User.\n     * @type {Profile}\n     */\n    this.profile = profile;\n\n    /**\n     * Groups this User is part of.\n     * @type {Array.<Group>}\n     */\n    this.groups = groups;\n\n    /**\n     * The creation date of the entity.\n     * @type {Date}\n     */\n    this.created = null;\n\n    /**\n     * The most recent update date of the entity.\n     * @type {Date}\n     */\n    this.updated = null;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/user/user.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 405,
    "kind": "class",
    "name": "User",
    "memberof": "src/administrative-sdk/user/user.js",
    "static": true,
    "longname": "src/administrative-sdk/user/user.js~User",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/user/user.js",
    "importStyle": "User",
    "description": "",
    "lineNumber": 6,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "User domain model"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 406,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/user/user.js~User",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/user/user.js~User#constructor",
    "access": "public",
    "description": "Create a User domain model.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The user identifier. If none is given, one is generated."
      },
      {
        "nullable": null,
        "types": [
          "Array<.string>"
        ],
        "spread": false,
        "optional": false,
        "name": "roles",
        "description": "Names of the {@link Role}s this user can take on."
      },
      {
        "nullable": true,
        "types": [
          "Profile"
        ],
        "spread": false,
        "optional": false,
        "name": "profile",
        "description": "Profile of the User."
      },
      {
        "nullable": true,
        "types": [
          "Array.<Group>"
        ],
        "spread": false,
        "optional": false,
        "name": "groups",
        "description": "Groups this User is part of."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "id parameter of type \"string|null\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "profile parameter of type \"Profile|null\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "groups parameter of type \"Array.<Groups>|null\" is required."
      },
      {
        "types": [
          "Error"
        ],
        "description": "non-empty roles parameter of type \"Array.<String>\" is required."
      }
    ]
  },
  {
    "__docId__": 407,
    "kind": "member",
    "name": "id",
    "memberof": "src/administrative-sdk/user/user.js~User",
    "static": false,
    "longname": "src/administrative-sdk/user/user.js~User#id",
    "access": "public",
    "description": "The user identifier. If none is given, one is generated.",
    "lineNumber": 40,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 408,
    "kind": "member",
    "name": "roles",
    "memberof": "src/administrative-sdk/user/user.js~User",
    "static": false,
    "longname": "src/administrative-sdk/user/user.js~User#roles",
    "access": "public",
    "description": "Names of the {@link Role}s this user can take on.",
    "lineNumber": 46,
    "type": {
      "nullable": null,
      "types": [
        "Array.<.Role>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 409,
    "kind": "member",
    "name": "profile",
    "memberof": "src/administrative-sdk/user/user.js~User",
    "static": false,
    "longname": "src/administrative-sdk/user/user.js~User#profile",
    "access": "public",
    "description": "Profile of the User.",
    "lineNumber": 52,
    "type": {
      "nullable": null,
      "types": [
        "Profile"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 410,
    "kind": "member",
    "name": "groups",
    "memberof": "src/administrative-sdk/user/user.js~User",
    "static": false,
    "longname": "src/administrative-sdk/user/user.js~User#groups",
    "access": "public",
    "description": "Groups this User is part of.",
    "lineNumber": 58,
    "type": {
      "nullable": null,
      "types": [
        "Array.<Group>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 411,
    "kind": "member",
    "name": "created",
    "memberof": "src/administrative-sdk/user/user.js~User",
    "static": false,
    "longname": "src/administrative-sdk/user/user.js~User#created",
    "access": "public",
    "description": "The creation date of the entity.",
    "lineNumber": 64,
    "type": {
      "nullable": null,
      "types": [
        "Date"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 412,
    "kind": "member",
    "name": "updated",
    "memberof": "src/administrative-sdk/user/user.js~User",
    "static": false,
    "longname": "src/administrative-sdk/user/user.js~User#updated",
    "access": "public",
    "description": "The most recent update date of the entity.",
    "lineNumber": 70,
    "type": {
      "nullable": null,
      "types": [
        "Date"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 413,
    "kind": "file",
    "name": "src/administrative-sdk/utils/base64-utils.js",
    "content": "/**\n * @private\n */\nexport default class Base64Utils {\n  /**\n   * Convert an array buffer to a base64 encoded binary string.\n   *\n   * @param {buffer} buffer - Buffer of data.\n   * @returns {string} Base64 encoded binary string.\n   */\n  static _arrayBufferToBase64(buffer) {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n    const len = bytes.byteLength;\n    for (let i = 0; i < len; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return window.btoa(binary);\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/utils/base64-utils.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 414,
    "kind": "class",
    "name": "Base64Utils",
    "memberof": "src/administrative-sdk/utils/base64-utils.js",
    "static": true,
    "longname": "src/administrative-sdk/utils/base64-utils.js~Base64Utils",
    "access": "private",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/utils/base64-utils.js",
    "importStyle": "Base64Utils",
    "description": "",
    "lineNumber": 4,
    "interface": false
  },
  {
    "__docId__": 415,
    "kind": "method",
    "name": "_arrayBufferToBase64",
    "memberof": "src/administrative-sdk/utils/base64-utils.js~Base64Utils",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/administrative-sdk/utils/base64-utils.js~Base64Utils._arrayBufferToBase64",
    "access": "private",
    "description": "Convert an array buffer to a base64 encoded binary string.",
    "lineNumber": 11,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} Base64 encoded binary string."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "buffer",
        "description": "Buffer of data."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Base64 encoded binary string."
    }
  },
  {
    "__docId__": 416,
    "kind": "file",
    "name": "src/administrative-sdk/word/word.js",
    "content": "/**\n * @class Word\n */\nexport default class Word {\n  /**\n   * Create a word domain model.\n   *\n   * @param {WordChunk[]} chunks - The spoken sentence, split in graphemes per word.\n   */\n  constructor(chunks) {\n    /**\n     * The spoken sentence, split in graphemes per word.\n     * @type {WordChunk[]}\n     */\n    this.chunks = chunks;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/word/word.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 417,
    "kind": "class",
    "name": "Word",
    "memberof": "src/administrative-sdk/word/word.js",
    "static": true,
    "longname": "src/administrative-sdk/word/word.js~Word",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/word/word.js",
    "importStyle": "Word",
    "description": "",
    "lineNumber": 4,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Word"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 418,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/word/word.js~Word",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/word/word.js~Word#constructor",
    "access": "public",
    "description": "Create a word domain model.",
    "lineNumber": 10,
    "params": [
      {
        "nullable": null,
        "types": [
          "WordChunk[]"
        ],
        "spread": false,
        "optional": false,
        "name": "chunks",
        "description": "The spoken sentence, split in graphemes per word."
      }
    ]
  },
  {
    "__docId__": 419,
    "kind": "member",
    "name": "chunks",
    "memberof": "src/administrative-sdk/word/word.js~Word",
    "static": false,
    "longname": "src/administrative-sdk/word/word.js~Word#chunks",
    "access": "public",
    "description": "The spoken sentence, split in graphemes per word.",
    "lineNumber": 15,
    "type": {
      "nullable": null,
      "types": [
        "WordChunk[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 420,
    "kind": "file",
    "name": "src/administrative-sdk/word-chunk/word-chunk.js",
    "content": "/**\n * @class WordChunk domain model\n */\nexport default class WordChunk {\n  /**\n   * Create a word chunk domain model.\n   *\n   * @param {string} graphemes - The graphemes this chunk consists of.\n   * @param {float} score - The audio is scored per grapheme and consists of several measurements. 0 would be bad,\n   * 1 the perfect score.\n   * @param {string} verdict - Bad when the score is below 0.4, moderate when equal to 0.4 or between 0.4 and 0.6.\n   * good when the score is 0.6 or above.\n   * @param {Phoneme[]} phonemes - The phonemes this chunk consists of.\n   */\n  constructor(graphemes, score, verdict, phonemes) {\n    /**\n     * The graphemes this chunk consists of.\n     * @type {string}\n     */\n    this.graphemes = graphemes;\n\n    /**\n     * The audio is scored per grapheme and consists of several measurements. 0 would be bad,\n     * 1 the perfect score.\n     * @type {float}\n     */\n    this.score = score;\n\n    /**\n     * Bad when the score is below 0.4, moderate when equal to 0.4 or between 0.4 and 0.6.\n     * good when the score is 0.6 or above.\n     * @type {string}\n     */\n    this.verdict = verdict;\n\n    /**\n     * The phonemes this chunk consists of.\n     * @type {any}\n     */\n    this.phonemes = phonemes || [];\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/administrative-sdk/word-chunk/word-chunk.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 421,
    "kind": "class",
    "name": "WordChunk",
    "memberof": "src/administrative-sdk/word-chunk/word-chunk.js",
    "static": true,
    "longname": "src/administrative-sdk/word-chunk/word-chunk.js~WordChunk",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/administrative-sdk/word-chunk/word-chunk.js",
    "importStyle": "WordChunk",
    "description": "",
    "lineNumber": 4,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "WordChunk domain model"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 422,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/administrative-sdk/word-chunk/word-chunk.js~WordChunk",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/administrative-sdk/word-chunk/word-chunk.js~WordChunk#constructor",
    "access": "public",
    "description": "Create a word chunk domain model.",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "graphemes",
        "description": "The graphemes this chunk consists of."
      },
      {
        "nullable": null,
        "types": [
          "float"
        ],
        "spread": false,
        "optional": false,
        "name": "score",
        "description": "The audio is scored per grapheme and consists of several measurements. 0 would be bad,\n1 the perfect score."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "verdict",
        "description": "Bad when the score is below 0.4, moderate when equal to 0.4 or between 0.4 and 0.6.\ngood when the score is 0.6 or above."
      },
      {
        "nullable": null,
        "types": [
          "Phoneme[]"
        ],
        "spread": false,
        "optional": false,
        "name": "phonemes",
        "description": "The phonemes this chunk consists of."
      }
    ]
  },
  {
    "__docId__": 423,
    "kind": "member",
    "name": "graphemes",
    "memberof": "src/administrative-sdk/word-chunk/word-chunk.js~WordChunk",
    "static": false,
    "longname": "src/administrative-sdk/word-chunk/word-chunk.js~WordChunk#graphemes",
    "access": "public",
    "description": "The graphemes this chunk consists of.",
    "lineNumber": 20,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 424,
    "kind": "member",
    "name": "score",
    "memberof": "src/administrative-sdk/word-chunk/word-chunk.js~WordChunk",
    "static": false,
    "longname": "src/administrative-sdk/word-chunk/word-chunk.js~WordChunk#score",
    "access": "public",
    "description": "The audio is scored per grapheme and consists of several measurements. 0 would be bad,\n1 the perfect score.",
    "lineNumber": 27,
    "type": {
      "nullable": null,
      "types": [
        "float"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 425,
    "kind": "member",
    "name": "verdict",
    "memberof": "src/administrative-sdk/word-chunk/word-chunk.js~WordChunk",
    "static": false,
    "longname": "src/administrative-sdk/word-chunk/word-chunk.js~WordChunk#verdict",
    "access": "public",
    "description": "Bad when the score is below 0.4, moderate when equal to 0.4 or between 0.4 and 0.6.\ngood when the score is 0.6 or above.",
    "lineNumber": 34,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 426,
    "kind": "member",
    "name": "phonemes",
    "memberof": "src/administrative-sdk/word-chunk/word-chunk.js~WordChunk",
    "static": false,
    "longname": "src/administrative-sdk/word-chunk/word-chunk.js~WordChunk#phonemes",
    "access": "public",
    "description": "The phonemes this chunk consists of.",
    "lineNumber": 40,
    "type": {
      "nullable": null,
      "types": [
        "any"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 427,
    "kind": "file",
    "name": "src/api/auth.js",
    "content": "/**\n * This file contains a set of functions which makes authentication easier.\n */\n\nimport {request, updateSettings} from './communication';\n\n\n/**\n * Assemble the scope form the given individual pieces.\n *\n * The scope is used to identify what the authenticated is allowed to do. It\n * can also be used by admin users to impersonate as an organisation or user.\n *\n * Keep in mind that in order to specify the user, the scope also needs to be\n * specified.\n *\n * @param {string} tenant - The ID of the tenant which is requesting this scope.\n * @param {string} [organisation] - The ID of the organisation which is\n *                                  requesting this scope.\n * @param {string} [user] - The ID of the user which is requesting this scope.\n *\n * @throws {Error} - When the required tenant is not set.\n *\n * @returns {string} - The assembled scope.\n */\nexport function assembleScope(tenant, organisation, user) {\n  if (!tenant) {\n    throw new Error('A tenant is always required.');\n  }\n\n  let scope = `tenant/${tenant}`;\n\n  if (organisation) {\n    scope += `/organisation/${organisation}`;\n\n    if (user) {\n      scope += `/user/${user}`;\n    }\n  }\n\n  return scope;\n}\n\n\n/**\n * Authenticate for the given credentials with the given scope.\n *\n * On a successful authentication, the settings are updated so every\n * follow-up API requests is authorized by the currently authenticated user.\n *\n * @param {string} username - The username to authenticate with.\n * @param {string} password - The password to authenticate with.\n * @param {string} [scope] - The scope of the authentication. Omitting this\n *                           value will cause the API to infer the scope.\n *\n * @returns {Promise} - A promise which will resolve if the authentication\n *                      concluded successfully, it'll reject in any other case.\n *                      It resolves with the response body of the token\n *                      request.\n */\nexport function authenticate(username, password, scope) {\n  const body = new URLSearchParams();\n\n  body.set('grant_type', 'password');\n  body.set('username', username);\n  body.set('password', password);\n\n  if (scope) {\n    body.set('scope', scope);\n  }\n\n  return request('POST', '/tokens', body)\n    .then(result => {\n      updateSettings({authorizationToken: result.access_token});\n      return result;\n    });\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/auth.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 428,
    "kind": "function",
    "name": "assembleScope",
    "memberof": "src/api/auth.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/auth.js~assembleScope",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/auth.js",
    "importStyle": "{assembleScope}",
    "description": "Assemble the scope form the given individual pieces.\n\nThe scope is used to identify what the authenticated is allowed to do. It\ncan also be used by admin users to impersonate as an organisation or user.\n\nKeep in mind that in order to specify the user, the scope also needs to be\nspecified.",
    "lineNumber": 26,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - The assembled scope."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "tenant",
        "description": "The ID of the tenant which is requesting this scope."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "organisation",
        "description": "The ID of the organisation which is\n                                 requesting this scope."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "user",
        "description": "The ID of the user which is requesting this scope."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The assembled scope."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "When the required tenant is not set."
      }
    ]
  },
  {
    "__docId__": 429,
    "kind": "function",
    "name": "authenticate",
    "memberof": "src/api/auth.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/auth.js~authenticate",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/auth.js",
    "importStyle": "{authenticate}",
    "description": "Authenticate for the given credentials with the given scope.\n\nOn a successful authentication, the settings are updated so every\nfollow-up API requests is authorized by the currently authenticated user.",
    "lineNumber": 61,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - A promise which will resolve if the authentication\n                     concluded successfully, it'll reject in any other case.\n                     It resolves with the response body of the token\n                     request."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": "The username to authenticate with."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "password",
        "description": "The password to authenticate with."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "scope",
        "description": "The scope of the authentication. Omitting this\n                          value will cause the API to infer the scope."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A promise which will resolve if the authentication\n                     concluded successfully, it'll reject in any other case.\n                     It resolves with the response body of the token\n                     request."
    }
  },
  {
    "__docId__": 430,
    "kind": "file",
    "name": "src/api/broadcaster.js",
    "content": "/**\n * This module exposes the single event emitter. All events are sent through\n * this emitter. For usage; see the docuemntation of\n * [event-emitter][GitHub event-emitter].\n *\n * [GitHub event-emitter]: https://github.com/medikoo/event-emitter\n */\n\nimport ee from 'event-emitter';\n\n\n/**\n * The single event channel used throughout the ITSLanguage SDK.\n *\n * @type {event-emitter.EventEmitter}\n */\nconst broadcaster = ee();\n\n\nexport default broadcaster;\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/broadcaster.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 431,
    "kind": "variable",
    "name": "broadcaster",
    "memberof": "src/api/broadcaster.js",
    "static": true,
    "longname": "src/api/broadcaster.js~broadcaster",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/broadcaster.js",
    "importStyle": "broadcaster",
    "description": "The single event channel used throughout the ITSLanguage SDK.",
    "lineNumber": 17,
    "type": {
      "nullable": null,
      "types": [
        "event-emitter.EventEmitter"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 432,
    "kind": "file",
    "name": "src/api/categories.js",
    "content": "/**\n * This file contains the readily availbile functions which interact with the\n * ITSLanguage categories API.\n */\n\nimport {authorisedRequest} from './communication';\n\n// The URL for the category handler(s).\nconst url = '/categories';\n\n\n/**\n * Create a new category.\n *\n * @param {Object} category - The category to create.\n *\n * @returns {Promise} - The category creation promise.\n */\nexport function createCategory(category) {\n  return authorisedRequest('POST', url, category);\n}\n\n\n/**\n * Get a single category by its ID.\n *\n * @param {string} id - The ID of the desired category.\n *\n * @returns {Promise} - The promise for the category.\n */\nexport function getCategoryByID(id) {\n  return authorisedRequest('GET', `${url}/${id}`);\n}\n\n\n/**\n * Get a all categories.\n *\n * By default all categories are fetched though it is allowed to pass filters.\n * as a `URLSearchParams` object.\n *\n * @param {URLSearchParams} [filters] - The filters to apply to the category\n *                                      list.\n *\n * @throws {Promise.<string>} - If the given optional filters are not an\n *                              instance of `URLSearchParams`.\n *\n * @returns {Promise} - The promise for the categories.\n */\nexport function getAllCategories(filters) {\n  let urlWithFilters = url;\n\n  if (filters) {\n    if (!(filters instanceof URLSearchParams)) {\n      return Promise.reject('The filters should be a `URLSearchParams` object.');\n    }\n\n    urlWithFilters += `?${filters.toString()}`;\n  }\n\n  return authorisedRequest('GET', urlWithFilters);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/categories.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 433,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/categories.js",
    "static": true,
    "longname": "src/api/categories.js~url",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/categories.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 434,
    "kind": "function",
    "name": "createCategory",
    "memberof": "src/api/categories.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/categories.js~createCategory",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/categories.js",
    "importStyle": "{createCategory}",
    "description": "Create a new category.",
    "lineNumber": 19,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The category creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "category",
        "description": "The category to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The category creation promise."
    }
  },
  {
    "__docId__": 435,
    "kind": "function",
    "name": "getCategoryByID",
    "memberof": "src/api/categories.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/categories.js~getCategoryByID",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/categories.js",
    "importStyle": "{getCategoryByID}",
    "description": "Get a single category by its ID.",
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the category."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the desired category."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the category."
    }
  },
  {
    "__docId__": 436,
    "kind": "function",
    "name": "getAllCategories",
    "memberof": "src/api/categories.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/categories.js~getAllCategories",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/categories.js",
    "importStyle": "{getAllCategories}",
    "description": "Get a all categories.\n\nBy default all categories are fetched though it is allowed to pass filters.\nas a `URLSearchParams` object.",
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the categories."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "URLSearchParams"
        ],
        "spread": false,
        "optional": true,
        "name": "filters",
        "description": "The filters to apply to the category\n                                     list."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the categories."
    },
    "throws": [
      {
        "types": [
          "Promise.<string>"
        ],
        "description": "If the given optional filters are not an\n                             instance of `URLSearchParams`."
      }
    ]
  },
  {
    "__docId__": 437,
    "kind": "file",
    "name": "src/api/challenges/choice/index.js",
    "content": "/**\n * This file contains the readily availbile functions which interact with the\n * ITSLanguage choice challenge API.\n */\n\nimport {authorisedRequest} from '../../communication';\n\n// The URL for the choice challenge handler(s).\nconst url = '/challenges/choice';\n\n\n/**\n * Create a new choice challenge.\n *\n * @param {Object} challenge - The challenge to create.\n *\n * @returns {Promise} - The challenge creation promise.\n */\nexport function createChoiceChallenge(challenge) {\n  return authorisedRequest('POST', url, challenge);\n}\n\n\n/**\n * Get a single choice challenge by its ID.\n *\n * @param {string} id - The ID of the desired choice challenge.\n *\n * @returns {Promise} - The promise for the choice challenge.\n */\nexport function getChoiceChallengeByID(id) {\n  return authorisedRequest('GET', `${url}/${id}`);\n}\n\n\n/**\n * Get a all choice challenges.\n *\n * By default all choice challenges are fetched though it is allowed to pass\n * filters as a `URLSearchParams` object.\n *\n * @param {URLSearchParams} [filters] - The filters to apply to the category\n *                                      list.\n *\n * @throws {Promise.<string>} - If the given optional filters are not an\n *                              instance of `URLSearchParams`.\n *\n * @returns {Promise} - The promise for the choice challenges.\n */\nexport function getAllChoiceChallenges(filters) {\n  let urlWithFilters = url;\n\n  if (filters) {\n    if (!(filters instanceof URLSearchParams)) {\n      return Promise.reject('The filters should be a `URLSearchParams` object.');\n    }\n\n    urlWithFilters += `?${filters.toString()}`;\n  }\n\n  return authorisedRequest('GET', urlWithFilters);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/challenges/choice/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 438,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/challenges/choice/index.js",
    "static": true,
    "longname": "src/api/challenges/choice/index.js~url",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/challenges/choice/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 439,
    "kind": "function",
    "name": "createChoiceChallenge",
    "memberof": "src/api/challenges/choice/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/index.js~createChoiceChallenge",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/choice/index.js",
    "importStyle": "{createChoiceChallenge}",
    "description": "Create a new choice challenge.",
    "lineNumber": 19,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The challenge creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "The challenge to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The challenge creation promise."
    }
  },
  {
    "__docId__": 440,
    "kind": "function",
    "name": "getChoiceChallengeByID",
    "memberof": "src/api/challenges/choice/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/index.js~getChoiceChallengeByID",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/choice/index.js",
    "importStyle": "{getChoiceChallengeByID}",
    "description": "Get a single choice challenge by its ID.",
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the choice challenge."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the desired choice challenge."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the choice challenge."
    }
  },
  {
    "__docId__": 441,
    "kind": "function",
    "name": "getAllChoiceChallenges",
    "memberof": "src/api/challenges/choice/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/index.js~getAllChoiceChallenges",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/choice/index.js",
    "importStyle": "{getAllChoiceChallenges}",
    "description": "Get a all choice challenges.\n\nBy default all choice challenges are fetched though it is allowed to pass\nfilters as a `URLSearchParams` object.",
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the choice challenges."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "URLSearchParams"
        ],
        "spread": false,
        "optional": true,
        "name": "filters",
        "description": "The filters to apply to the category\n                                     list."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the choice challenges."
    },
    "throws": [
      {
        "types": [
          "Promise.<string>"
        ],
        "description": "If the given optional filters are not an\n                             instance of `URLSearchParams`."
      }
    ]
  },
  {
    "__docId__": 442,
    "kind": "file",
    "name": "src/api/challenges/choice/recognition.js",
    "content": "/**\n * This file contains the readily available functions which interact with the\n * ITSLanguage choice recognition API.\n *\n * Speech recognitions can be stored and retrieved for user submitted audio using the ITSLanguage\n * Speech API. The actual recognitions are performed by the ITSLanguage websocket server.\n *\n * For streaming, note that this is one of the \"nested\" or \"composite\" APIs; You can only obtain the\n * data if you provide a reference to the challenge for which you want a recording.\n */\n\nimport {\n  registerStreamForRecorder,\n  waitForUserMediaApproval\n} from '../../utils/audio-over-socket';\nimport {authorisedRequest} from '../../communication';\nimport {makeWebsocketCall} from '../../communication/websocket';\n\nconst url = challengeId => `/challenges/choice/${challengeId}/recognitions`;\n\n/**\n * Get all Choice Recognitions for a specific Choice Challenge.\n *\n * @see https://itslanguage.github.io/itslanguage-docs/api/recognitions/index.html#list-choice-recognitions\n * @param {string} challengeId - ID of the Choice Challenge to get all the recognitions for.\n * @returns {Promise} - Promise with the Choice Recognitions as result if successful.\n */\nexport function getAllChoiceRecognitions(challengeId) {\n  return authorisedRequest('GET', `${url(challengeId)}`);\n}\n\n/**\n * Get a single ChoiceRecognition by its ID.\n *\n * @see https://itslanguage.github.io/itslanguage-docs/api/recognitions/index.html#get-a-single-choice-recognition\n * @param {string} challengeId - ID of the Choice Challenge to get all the recognitions for.\n * @param {string} id - ID of the choice recognition to get.\n * @returns {Promise} - Promise with the Choice Recognition as result if successful.\n */\nexport function getChoiceRecognitionByID(challengeId, id) {\n  return authorisedRequest('GET', `${url(challengeId)}/${id}`);\n}\n\n/**\n * Submit an audio fragment for recognition. The recognition is created for the current\n * authenticated user.\n *\n * @see https://itslanguage.github.io/itslanguage-docs/api/recognitions/index.html#create-a-choice-recognition\n * @param {string} challengeId - The ID of the challenge to relate the recognition to.\n * @param {Blob} audio - The actual audio.\n * @param {string} recognised - The recognised string.\n * @param {string} [recognitionId=null] - Unique identifier for the recognition. If none is given,\n *                                        one is generated.\n * @returns {Promise} - The created recognition with an url to download the audio if needed.\n */\nexport function createChoiceRecognition(challengeId, audio, recognised, recognitionId = null) {\n  return authorisedRequest(\n    'POST',\n    `${url(challengeId)}/${recognitionId && recognitionId}`,\n    {\n      audio,\n      recognised\n    }\n  );\n}\n\n/**\n * This is the starting point for a choice recognition. A unique recognition id is generated,\n * which serves a leading role in the recognition. Each other call requires the recognition id\n * as a parameter.\n *\n * If other RPCs are called without this RPC being called first, the error\n * `nl.itslanguage.session_not_initialised` will be returned.\n *\n * @see https://itslanguage.github.io/itslanguage-docs/websocket/choice_recognitions/index.html#initialising-a-choice-recognition\n * @returns {Promise} - Returns a promise. When successfully the ID of the recognition is returned.\n */\nexport function prepareChoiceRecognition() {\n  return makeWebsocketCall('choice.init_recognition');\n}\n\n/**\n * Before performing the recognition, a WFST needs to be prepared for the challenge. When the RPC is\n * called, the challenge is initialised asynchronously. When the challenge is to be used, the server\n * automatically waits for the challenge initialisation to finish. If the initialisation results in\n * an error, the error is relayed to the client.\n *\n * @see https://itslanguage.github.io/itslanguage-docs/websocket/choice_recognitions/index.html#initialise-choice-challenge\n * @param {string} recognitionId - The ID of the recognition to prepare the challenge for.\n * @param {string} challengeId - The ID of the challenge to prepare.\n * @returns {Promise} - If succesful the promise returns nothing. On error, there will be an error.\n */\nexport function prepareChoiceRecognitionChallenge(recognitionId, challengeId) {\n  return makeWebsocketCall('choice.init_challenge', {args: [recognitionId, challengeId]});\n}\n\n/**\n * Based on a recognitionId and a recorder register a RPC call that will be used to send the audio\n * across the line. The actual registration will not be done here, but we send the RPC that the\n * backend needs to call to the 'nl.itslanguage.choice.recognise' function.\n *\n * @param {string} recognitionId - The ID of the recognition to send audio for.\n * @param {Recorder} recorder - Audio recorder instance.\n * @returns {Promise} - When all good, the result will have the actual recognition.\n */\nexport function recogniseAudioStream(recognitionId, recorder) {\n  // Generate a somewhat unique RPC name\n  const rpcNameToRegister = `choice.stream.${Math.floor(Date.now() / 1000)}`;\n  return registerStreamForRecorder(recorder, rpcNameToRegister)\n    // We don't use rpcNameToRegister here because it lacks some namespacing info. The\n    // registration.procedure does have the needed information.\n    .then(registration => makeWebsocketCall('choice.recognise', {args: [recognitionId, registration.procedure]}));\n}\n\n/**\n * Easy function to do a recognition in one go. This is the \"dance of the RPC's\" that needs to be\n * done in order to get correct feedback from the backend.\n *\n * @param {string} challengeId - The ID of the challenge to take the recognition for.\n * @param {Recorder} recorder - Audio recorder instance.\n * @returns {Promise<*>} - If all good it returns the actual recognition. If not, any error can be\n *                         expected to be returned.\n */\nexport function recognise(challengeId, recorder) {\n  let recognitionId;\n  return prepareChoiceRecognition()\n    .then(rId => {\n      recognitionId = rId;\n      return waitForUserMediaApproval(recognitionId, recorder);\n    })\n    .then(() => prepareChoiceRecognitionChallenge(recognitionId, challengeId))\n    .then(() => recogniseAudioStream(recognitionId, recorder).then(result => result));\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/challenges/choice/recognition.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 443,
    "kind": "function",
    "name": "url",
    "memberof": "src/api/challenges/choice/recognition.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/recognition.js~url",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/challenges/choice/recognition.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "params": [
      {
        "name": "challengeId",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 444,
    "kind": "function",
    "name": "getAllChoiceRecognitions",
    "memberof": "src/api/challenges/choice/recognition.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/recognition.js~getAllChoiceRecognitions",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/choice/recognition.js",
    "importStyle": "{getAllChoiceRecognitions}",
    "description": "Get all Choice Recognitions for a specific Choice Challenge.",
    "see": [
      "https://itslanguage.github.io/itslanguage-docs/api/recognitions/index.html#list-choice-recognitions"
    ],
    "lineNumber": 28,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - Promise with the Choice Recognitions as result if successful."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "ID of the Choice Challenge to get all the recognitions for."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise with the Choice Recognitions as result if successful."
    }
  },
  {
    "__docId__": 445,
    "kind": "function",
    "name": "getChoiceRecognitionByID",
    "memberof": "src/api/challenges/choice/recognition.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/recognition.js~getChoiceRecognitionByID",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/choice/recognition.js",
    "importStyle": "{getChoiceRecognitionByID}",
    "description": "Get a single ChoiceRecognition by its ID.",
    "see": [
      "https://itslanguage.github.io/itslanguage-docs/api/recognitions/index.html#get-a-single-choice-recognition"
    ],
    "lineNumber": 40,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - Promise with the Choice Recognition as result if successful."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "ID of the Choice Challenge to get all the recognitions for."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "ID of the choice recognition to get."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise with the Choice Recognition as result if successful."
    }
  },
  {
    "__docId__": 446,
    "kind": "function",
    "name": "createChoiceRecognition",
    "memberof": "src/api/challenges/choice/recognition.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/recognition.js~createChoiceRecognition",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/choice/recognition.js",
    "importStyle": "{createChoiceRecognition}",
    "description": "Submit an audio fragment for recognition. The recognition is created for the current\nauthenticated user.",
    "see": [
      "https://itslanguage.github.io/itslanguage-docs/api/recognitions/index.html#create-a-choice-recognition"
    ],
    "lineNumber": 56,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The created recognition with an url to download the audio if needed."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "The ID of the challenge to relate the recognition to."
      },
      {
        "nullable": null,
        "types": [
          "Blob"
        ],
        "spread": false,
        "optional": false,
        "name": "audio",
        "description": "The actual audio."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "recognised",
        "description": "The recognised string."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "recognitionId",
        "description": "Unique identifier for the recognition. If none is given,\n                                       one is generated."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The created recognition with an url to download the audio if needed."
    }
  },
  {
    "__docId__": 447,
    "kind": "function",
    "name": "prepareChoiceRecognition",
    "memberof": "src/api/challenges/choice/recognition.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/recognition.js~prepareChoiceRecognition",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/choice/recognition.js",
    "importStyle": "{prepareChoiceRecognition}",
    "description": "This is the starting point for a choice recognition. A unique recognition id is generated,\nwhich serves a leading role in the recognition. Each other call requires the recognition id\nas a parameter.\n\nIf other RPCs are called without this RPC being called first, the error\n`nl.itslanguage.session_not_initialised` will be returned.",
    "see": [
      "https://itslanguage.github.io/itslanguage-docs/websocket/choice_recognitions/index.html#initialising-a-choice-recognition"
    ],
    "lineNumber": 78,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - Returns a promise. When successfully the ID of the recognition is returned."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Returns a promise. When successfully the ID of the recognition is returned."
    },
    "params": []
  },
  {
    "__docId__": 448,
    "kind": "function",
    "name": "prepareChoiceRecognitionChallenge",
    "memberof": "src/api/challenges/choice/recognition.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/recognition.js~prepareChoiceRecognitionChallenge",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/choice/recognition.js",
    "importStyle": "{prepareChoiceRecognitionChallenge}",
    "description": "Before performing the recognition, a WFST needs to be prepared for the challenge. When the RPC is\ncalled, the challenge is initialised asynchronously. When the challenge is to be used, the server\nautomatically waits for the challenge initialisation to finish. If the initialisation results in\nan error, the error is relayed to the client.",
    "see": [
      "https://itslanguage.github.io/itslanguage-docs/websocket/choice_recognitions/index.html#initialise-choice-challenge"
    ],
    "lineNumber": 93,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - If succesful the promise returns nothing. On error, there will be an error."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "recognitionId",
        "description": "The ID of the recognition to prepare the challenge for."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "The ID of the challenge to prepare."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "If succesful the promise returns nothing. On error, there will be an error."
    }
  },
  {
    "__docId__": 449,
    "kind": "function",
    "name": "recogniseAudioStream",
    "memberof": "src/api/challenges/choice/recognition.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/recognition.js~recogniseAudioStream",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/choice/recognition.js",
    "importStyle": "{recogniseAudioStream}",
    "description": "Based on a recognitionId and a recorder register a RPC call that will be used to send the audio\nacross the line. The actual registration will not be done here, but we send the RPC that the\nbackend needs to call to the 'nl.itslanguage.choice.recognise' function.",
    "lineNumber": 106,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - When all good, the result will have the actual recognition."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "recognitionId",
        "description": "The ID of the recognition to send audio for."
      },
      {
        "nullable": null,
        "types": [
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "Audio recorder instance."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "When all good, the result will have the actual recognition."
    }
  },
  {
    "__docId__": 450,
    "kind": "function",
    "name": "recognise",
    "memberof": "src/api/challenges/choice/recognition.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/recognition.js~recognise",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/choice/recognition.js",
    "importStyle": "{recognise}",
    "description": "Easy function to do a recognition in one go. This is the \"dance of the RPC's\" that needs to be\ndone in order to get correct feedback from the backend.",
    "lineNumber": 124,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<*>} - If all good it returns the actual recognition. If not, any error can be\n                        expected to be returned."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "The ID of the challenge to take the recognition for."
      },
      {
        "nullable": null,
        "types": [
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "Audio recorder instance."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "If all good it returns the actual recognition. If not, any error can be\n                        expected to be returned."
    }
  },
  {
    "__docId__": 451,
    "kind": "file",
    "name": "src/api/challenges/feedback/speech.js",
    "content": "/**\n * This file contains the functions that are needed to interact with the ITSLanguage Speech\n * Feedback API.\n *\n * It's possible to get feedback while recording. After every sentence feedback is provided\n * indicating whether or not the sentence was read well. This will be done through the\n * ITSLanguage WebSocket Server.\n *\n * The general approach for getting real-time feedback is:\n *  - Prepare the speech feedback\n *  - Register audio procedure for streaming\n *  - Start listening for audio\n *\n *  To read up on the Speech feedback:\n *  @see https://itslanguage.github.io/itslanguage-docs/websocket/feedback/index.html\n *\n *  To read more on Speech Challenges:\n *  @see https://itslanguage.github.io/itslanguage-docs/api/speech_challenges/index.html\n *\n *  @TODO: Backend API features are not implemented yet.\n *  @TODO: The feedback.pause and feedback.resume are not implemented yet.\n */\n\nimport {\n  registerStreamForRecorder,\n  waitForUserMediaApproval\n} from '../../utils/audio-over-socket';\nimport {makeWebsocketCall} from '../../communication/websocket';\n\n/**\n * Prepare a new Speech Feedback.\n * Should be called upon each new speech feedback.\n * The backend will generate an unique ID for the feedback and prepare a speech challenge.\n *\n * @param {string} challengeId - The ID of the challenge to prepare.\n * @returns {Promise} - The ID of the Speech Feedback.\n */\nexport function prepareFeedback(challengeId) {\n  return makeWebsocketCall('feedback.prepare', {args: [challengeId]});\n}\n\n/**\n * In order to receive feedback the server needs to listen for audio on a registered audio rpc.\n * While listening the server will reply using progressive results. The server will stop listening\n * when the audio rpc returns.\n *\n * If you call this function the SDK will register an RPC method to the realm on which audio will be\n * streamed to the backend.\n *\n * @param {string} feedbackId - The Id of the Feedback Challenge.\n * @param {Function} progressCb - A callback which will be used to receive progress on.\n * @param {Recorder} recorder - Audio recorder instance.\n * @returns {Promise} - After each sentence there will be real-time feedback on that sentence. This\n *                      feedback will be given through the progressiveResultsCb function. When the\n *                      rpc is done, the promise will return an recording with the appropriate\n *                      feedback per sentence.\n */\nexport function listenAndReply(feedbackId, progressCb, recorder) {\n  // Generate a somewhat unique RPC name\n  const rpcNameToRegister = `feedback.stream.${Math.floor(Date.now() / 1000)}`;\n\n  // Below we use registration.procedure instead of rpcNameToRegister. This is because the later\n  // lacks some namespacing information that we do need.\n  return registerStreamForRecorder(recorder, rpcNameToRegister)\n    .then(registration =>\n      makeWebsocketCall(\n        'feedback.listen_and_reply',\n        {\n          args: [feedbackId, registration.procedure],\n          progressCb\n        }\n      )\n    );\n}\n\n/**\n * Function for convenience. Using this function calls the corresponding functions so that the\n * required backend flow is backed up.\n *\n * It will call the following functions (and more important, in the correct order):\n *  - {@link prepareFeedback}.\n *  - {@link waitForUserMediaApproval}.\n *  - {@link listenAndReply}.\n *\n * @param {string} challengeId - The Id of the Challenge to get feedback on.\n * @param {Function} progressiveResultsCb - A callback which will be used to receive progress on.\n * @param {Recorder} recorder - Audio recorder instance.\n * @returns {Promise} - After each sentence there will be real-time feedback on that sentence. This\n *                      feedback will be given through the progressiveResultsCb function. When the\n *                      rpc is done, the promise will return an recording with the appropriate\n *                      feedback per sentence.\n */\nexport function feedback(challengeId, progressiveResultsCb, recorder) {\n  return prepareFeedback(challengeId)\n    .then(feedbackId => waitForUserMediaApproval(feedbackId, recorder))\n    .then(feedbackId => listenAndReply(feedbackId, progressiveResultsCb, recorder));\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/challenges/feedback/speech.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 452,
    "kind": "function",
    "name": "prepareFeedback",
    "memberof": "src/api/challenges/feedback/speech.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/feedback/speech.js~prepareFeedback",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/feedback/speech.js",
    "importStyle": "{prepareFeedback}",
    "description": "Prepare a new Speech Feedback.\nShould be called upon each new speech feedback.\nThe backend will generate an unique ID for the feedback and prepare a speech challenge.",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The ID of the Speech Feedback."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "The ID of the challenge to prepare."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The ID of the Speech Feedback."
    }
  },
  {
    "__docId__": 453,
    "kind": "function",
    "name": "listenAndReply",
    "memberof": "src/api/challenges/feedback/speech.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/feedback/speech.js~listenAndReply",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/feedback/speech.js",
    "importStyle": "{listenAndReply}",
    "description": "In order to receive feedback the server needs to listen for audio on a registered audio rpc.\nWhile listening the server will reply using progressive results. The server will stop listening\nwhen the audio rpc returns.\n\nIf you call this function the SDK will register an RPC method to the realm on which audio will be\nstreamed to the backend.",
    "lineNumber": 58,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - After each sentence there will be real-time feedback on that sentence. This\n                     feedback will be given through the progressiveResultsCb function. When the\n                     rpc is done, the promise will return an recording with the appropriate\n                     feedback per sentence."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "feedbackId",
        "description": "The Id of the Feedback Challenge."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "progressCb",
        "description": "A callback which will be used to receive progress on."
      },
      {
        "nullable": null,
        "types": [
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "Audio recorder instance."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "After each sentence there will be real-time feedback on that sentence. This\n                     feedback will be given through the progressiveResultsCb function. When the\n                     rpc is done, the promise will return an recording with the appropriate\n                     feedback per sentence."
    }
  },
  {
    "__docId__": 454,
    "kind": "function",
    "name": "feedback",
    "memberof": "src/api/challenges/feedback/speech.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/feedback/speech.js~feedback",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/feedback/speech.js",
    "importStyle": "{feedback}",
    "description": "Function for convenience. Using this function calls the corresponding functions so that the\nrequired backend flow is backed up.\n\nIt will call the following functions (and more important, in the correct order):\n - {@link prepareFeedback}.\n - {@link waitForUserMediaApproval}.\n - {@link listenAndReply}.",
    "lineNumber": 93,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - After each sentence there will be real-time feedback on that sentence. This\n                     feedback will be given through the progressiveResultsCb function. When the\n                     rpc is done, the promise will return an recording with the appropriate\n                     feedback per sentence."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "The Id of the Challenge to get feedback on."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "progressiveResultsCb",
        "description": "A callback which will be used to receive progress on."
      },
      {
        "nullable": null,
        "types": [
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "Audio recorder instance."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "After each sentence there will be real-time feedback on that sentence. This\n                     feedback will be given through the progressiveResultsCb function. When the\n                     rpc is done, the promise will return an recording with the appropriate\n                     feedback per sentence."
    }
  },
  {
    "__docId__": 455,
    "kind": "file",
    "name": "src/api/challenges/pronunciation/analysis.js",
    "content": "/**\n * This file contains the readily available functions which interact with the\n * ITSLanguage pronunciation analysis API.\n *\n * Note that this is one of the \"nested\" or \"composite\" APIs; You can only\n * obtain the data if you provide a reference to the challenge for which you\n * want a recording.\n */\n\nimport {\n  encodeAndSendAudioOnDataAvailible,\n  prepareServerForAudio\n} from '../../utils/audio-over-socket';\nimport {authorisedRequest} from '../../communication';\nimport {makeWebsocketCall} from '../../communication/websocket';\n\nconst url = challenge => `/challenges/pronunciation/${challenge}/analyses`;\n\n/**\n * Ask the backend for a Pronunciation Analysis.\n *\n * @param {string} challengeId - The ID of the corresponding challenge.\n * @param {string} analysisId - The ID of the analysis you want result for.\n * @returns {Promise.<Object>} - The Pronunciation Analysis.\n */\nexport function getPronunciationAnalysisById(challengeId, analysisId) {\n  return authorisedRequest('GET', `${url(challengeId)}/${analysisId}`);\n}\n\n/**\n * Create a new analysis and return the ID.\n *\n * @returns {Promise|Promise.<*>} - The result will hold the ID for the analysis.\n */\nexport function preparePronunciationAnalysis() {\n  return makeWebsocketCall('pronunciation.init_analysis');\n}\n\n/**\n * Prepare the backend by telling it which challenge it can expect by a new analysis.\n *\n * @param {string} analysisId - The ID of the analysis to attache the challenge to.\n * @param {string} challengeId - The ID of the challenge that belongs to a specific analysis.\n * @returns {Promise.<*>} - Promise with the result of the init_challenge call.\n */\nexport function prepareAnalysisChallenge(analysisId, challengeId) {\n  return makeWebsocketCall('pronunciation.init_challenge', {args: [analysisId, challengeId]});\n}\n\n/**\n * A Pronunciaion Challange could hold an alignment allready. If not so\n * this function will instruct the backend to create the alignment and\n * return it to the client.\n *\n * @param {string} analysisId - The ID of the analysis to create the alignment for.\n * @returns {Promise.<*>} - The alignment.\n */\nexport function performAlignmentOnChallenge(analysisId) {\n  return makeWebsocketCall('pronunciation.alignment', {args: [analysisId]});\n}\n\n/**\n * Prepare the backend for our audio.\n *\n * @param {string} analyseId - The Analysis that belongs to the audio.\n * @param {Recorder} recorder - The recorder to get specs from.\n * @returns {Promise} - Result of preparing the audio.\n */\nexport function prepareAudioForPronuncationAnalysis(analyseId, recorder) {\n  return prepareServerForAudio(analyseId, recorder, 'pronunciation.init_audio');\n}\n\n/**\n * Us the provided recorder to stream/send the recorded audio to the backend.\n *\n * @param {string} analyseId - The ID of the analysis we're receiving audio for.\n * @param {Recorder} recorder - Instance of an Recorder.\n * @returns {Promise} - Stream result.\n */\nexport function streamAudioForPronunciationAnalysis(analyseId, recorder) {\n  return encodeAndSendAudioOnDataAvailible(analyseId, recorder, 'pronunciation.write');\n}\n\n/**\n * Finishing the recording means we're ready to analyse! Smartest man in the entire universe.\n * We also accept a special callback that can be used to receive progress on.\n *\n * @param {string} analyseId - The ID of the Analysis to analyse on.\n * @param {Function} [progressCb] - A callback which will be used to receive progress on.\n * @returns {Promise.<*>} - The result will return the analysis.\n */\nexport function endStreamAudioForPronunciationAnalysis(analyseId, progressCb) {\n  return makeWebsocketCall('pronunciation.analyse', {args: [analyseId], progressCb});\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/challenges/pronunciation/analysis.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 456,
    "kind": "function",
    "name": "url",
    "memberof": "src/api/challenges/pronunciation/analysis.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/analysis.js~url",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/challenges/pronunciation/analysis.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "params": [
      {
        "name": "challenge",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 457,
    "kind": "function",
    "name": "getPronunciationAnalysisById",
    "memberof": "src/api/challenges/pronunciation/analysis.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/analysis.js~getPronunciationAnalysisById",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/pronunciation/analysis.js",
    "importStyle": "{getPronunciationAnalysisById}",
    "description": "Ask the backend for a Pronunciation Analysis.",
    "lineNumber": 26,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Object>} - The Pronunciation Analysis."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "The ID of the corresponding challenge."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "analysisId",
        "description": "The ID of the analysis you want result for."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Object>"
      ],
      "spread": false,
      "description": "The Pronunciation Analysis."
    }
  },
  {
    "__docId__": 458,
    "kind": "function",
    "name": "preparePronunciationAnalysis",
    "memberof": "src/api/challenges/pronunciation/analysis.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/analysis.js~preparePronunciationAnalysis",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/pronunciation/analysis.js",
    "importStyle": "{preparePronunciationAnalysis}",
    "description": "Create a new analysis and return the ID.",
    "lineNumber": 35,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise|Promise.<*>} - The result will hold the ID for the analysis."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise",
        "Promise.<*>"
      ],
      "spread": false,
      "description": "The result will hold the ID for the analysis."
    },
    "params": []
  },
  {
    "__docId__": 459,
    "kind": "function",
    "name": "prepareAnalysisChallenge",
    "memberof": "src/api/challenges/pronunciation/analysis.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/analysis.js~prepareAnalysisChallenge",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/pronunciation/analysis.js",
    "importStyle": "{prepareAnalysisChallenge}",
    "description": "Prepare the backend by telling it which challenge it can expect by a new analysis.",
    "lineNumber": 46,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<*>} - Promise with the result of the init_challenge call."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "analysisId",
        "description": "The ID of the analysis to attache the challenge to."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "The ID of the challenge that belongs to a specific analysis."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<*>"
      ],
      "spread": false,
      "description": "Promise with the result of the init_challenge call."
    }
  },
  {
    "__docId__": 460,
    "kind": "function",
    "name": "performAlignmentOnChallenge",
    "memberof": "src/api/challenges/pronunciation/analysis.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/analysis.js~performAlignmentOnChallenge",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/pronunciation/analysis.js",
    "importStyle": "{performAlignmentOnChallenge}",
    "description": "A Pronunciaion Challange could hold an alignment allready. If not so\nthis function will instruct the backend to create the alignment and\nreturn it to the client.",
    "lineNumber": 58,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<*>} - The alignment."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "analysisId",
        "description": "The ID of the analysis to create the alignment for."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<*>"
      ],
      "spread": false,
      "description": "The alignment."
    }
  },
  {
    "__docId__": 461,
    "kind": "function",
    "name": "prepareAudioForPronuncationAnalysis",
    "memberof": "src/api/challenges/pronunciation/analysis.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/analysis.js~prepareAudioForPronuncationAnalysis",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/pronunciation/analysis.js",
    "importStyle": "{prepareAudioForPronuncationAnalysis}",
    "description": "Prepare the backend for our audio.",
    "lineNumber": 69,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - Result of preparing the audio."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "analyseId",
        "description": "The Analysis that belongs to the audio."
      },
      {
        "nullable": null,
        "types": [
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "The recorder to get specs from."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Result of preparing the audio."
    }
  },
  {
    "__docId__": 462,
    "kind": "function",
    "name": "streamAudioForPronunciationAnalysis",
    "memberof": "src/api/challenges/pronunciation/analysis.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/analysis.js~streamAudioForPronunciationAnalysis",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/pronunciation/analysis.js",
    "importStyle": "{streamAudioForPronunciationAnalysis}",
    "description": "Us the provided recorder to stream/send the recorded audio to the backend.",
    "lineNumber": 80,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - Stream result."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "analyseId",
        "description": "The ID of the analysis we're receiving audio for."
      },
      {
        "nullable": null,
        "types": [
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "Instance of an Recorder."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Stream result."
    }
  },
  {
    "__docId__": 463,
    "kind": "function",
    "name": "endStreamAudioForPronunciationAnalysis",
    "memberof": "src/api/challenges/pronunciation/analysis.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/analysis.js~endStreamAudioForPronunciationAnalysis",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/pronunciation/analysis.js",
    "importStyle": "{endStreamAudioForPronunciationAnalysis}",
    "description": "Finishing the recording means we're ready to analyse! Smartest man in the entire universe.\nWe also accept a special callback that can be used to receive progress on.",
    "lineNumber": 92,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<*>} - The result will return the analysis."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "analyseId",
        "description": "The ID of the Analysis to analyse on."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "progressCb",
        "description": "A callback which will be used to receive progress on."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<*>"
      ],
      "spread": false,
      "description": "The result will return the analysis."
    }
  },
  {
    "__docId__": 464,
    "kind": "file",
    "name": "src/api/challenges/pronunciation/index.js",
    "content": "/**\n * This file contains the readily availbile functions which interact with the\n * ITSLanguage pronunciation challenge API.\n */\n\nimport {authorisedRequest} from '../../communication';\n\n// The URL for the pronunciation challenge handler(s).\nconst url = '/challenges/pronunciation';\n\n\n/**\n * Create a new pronunciation challenge.\n *\n * @param {Object} challenge - The pronunciation challenge to create.\n *\n * @returns {Promise} - The pronunciation challenge creation promise.\n */\nexport function createPronunciationChallenge(challenge) {\n  return authorisedRequest('POST', url, challenge);\n}\n\n\n/**\n * Get a single pronunciation challenge by its ID.\n *\n * @param {string} id - The ID of the desired pronunciation challenge.\n *\n * @returns {Promise} - The promise for the pronunciation challenge.\n */\nexport function getPronunciationChallengeByID(id) {\n  return authorisedRequest('GET', `${url}/${id}`);\n}\n\n\n/**\n * Get a all pronunciation challenges.\n *\n * By default all pronunciation challenges are fetched though it is allowed to pass\n * filters as a `URLSearchParams` object.\n *\n * @param {URLSearchParams} [filters] - The filters to apply to the category\n *                                      list.\n *\n * @throws {Promise.<string>} - If the given optional filters are not an\n *                              instance of `URLSearchParams`.\n *\n * @returns {Promise} - The promise for the pronunciation challenges.\n */\nexport function getAllPronunciationChallenges(filters) {\n  let urlWithFilters = url;\n\n  if (filters) {\n    if (!(filters instanceof URLSearchParams)) {\n      return Promise.reject('The filters should be a `URLSearchParams` object.');\n    }\n\n    urlWithFilters += `?${filters.toString()}`;\n  }\n\n  return authorisedRequest('GET', urlWithFilters);\n}\n\n\n/**\n * Delete the pronunciation challenge with the given ID.\n *\n * @param {string} id - The ID of the pronunciation challeng to delete.\n *\n * @returns {Promise} - The pronunciation delete promise.\n */\nexport function deletePronunciationChallenge(id) {\n  return authorisedRequest('DELETE', `${url}/${id}`);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/challenges/pronunciation/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 465,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/challenges/pronunciation/index.js",
    "static": true,
    "longname": "src/api/challenges/pronunciation/index.js~url",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/challenges/pronunciation/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 466,
    "kind": "function",
    "name": "createPronunciationChallenge",
    "memberof": "src/api/challenges/pronunciation/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/index.js~createPronunciationChallenge",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/pronunciation/index.js",
    "importStyle": "{createPronunciationChallenge}",
    "description": "Create a new pronunciation challenge.",
    "lineNumber": 19,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The pronunciation challenge creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "The pronunciation challenge to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The pronunciation challenge creation promise."
    }
  },
  {
    "__docId__": 467,
    "kind": "function",
    "name": "getPronunciationChallengeByID",
    "memberof": "src/api/challenges/pronunciation/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/index.js~getPronunciationChallengeByID",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/pronunciation/index.js",
    "importStyle": "{getPronunciationChallengeByID}",
    "description": "Get a single pronunciation challenge by its ID.",
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the pronunciation challenge."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the desired pronunciation challenge."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the pronunciation challenge."
    }
  },
  {
    "__docId__": 468,
    "kind": "function",
    "name": "getAllPronunciationChallenges",
    "memberof": "src/api/challenges/pronunciation/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/index.js~getAllPronunciationChallenges",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/pronunciation/index.js",
    "importStyle": "{getAllPronunciationChallenges}",
    "description": "Get a all pronunciation challenges.\n\nBy default all pronunciation challenges are fetched though it is allowed to pass\nfilters as a `URLSearchParams` object.",
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the pronunciation challenges."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "URLSearchParams"
        ],
        "spread": false,
        "optional": true,
        "name": "filters",
        "description": "The filters to apply to the category\n                                     list."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the pronunciation challenges."
    },
    "throws": [
      {
        "types": [
          "Promise.<string>"
        ],
        "description": "If the given optional filters are not an\n                             instance of `URLSearchParams`."
      }
    ]
  },
  {
    "__docId__": 469,
    "kind": "function",
    "name": "deletePronunciationChallenge",
    "memberof": "src/api/challenges/pronunciation/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/index.js~deletePronunciationChallenge",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/pronunciation/index.js",
    "importStyle": "{deletePronunciationChallenge}",
    "description": "Delete the pronunciation challenge with the given ID.",
    "lineNumber": 72,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The pronunciation delete promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the pronunciation challeng to delete."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The pronunciation delete promise."
    }
  },
  {
    "__docId__": 470,
    "kind": "file",
    "name": "src/api/challenges/speech/index.js",
    "content": "/**\n * This file contains the readily availbile functions which interact with the\n * ITSLanguage speech challenge API.\n */\n\nimport {authorisedRequest} from '../../communication';\n\n// The URL for the speech challenge handler(s).\nconst url = '/challenges/speech';\n\n\n/**\n * Create a new speech challenge.\n *\n * @param {Object} challenge - The challenge to create.\n *\n * @returns {Promise} - The challenge creation promise.\n */\nexport function createSpeechChallenge(challenge) {\n  return authorisedRequest('POST', url, challenge);\n}\n\n\n/**\n * Get a single speech challenge by its ID.\n *\n * @param {string} id - The ID of the desired speech challenge.\n *\n * @returns {Promise} - The promise for the speech challenge.\n */\nexport function getSpeechChallengeByID(id) {\n  return authorisedRequest('GET', `${url}/${id}`);\n}\n\n\n/**\n * Get a all speech challenges.\n *\n * By default all speech challenges are fetched though it is allowed to pass\n * filters as a `URLSearchParams` object.\n *\n * @param {URLSearchParams} [filters] - The filters to apply to the category\n *                                      list.\n *\n * @throws {Promise.<string>} - If the given optional filters are not an\n *                              instance of `URLSearchParams`.\n *\n * @returns {Promise} - The promise for the speech challenges.\n */\nexport function getAllSpeechChallenges(filters) {\n  let urlWithFilters = url;\n\n  if (filters) {\n    if (!(filters instanceof URLSearchParams)) {\n      return Promise.reject('The filters should be a `URLSearchParams` object.');\n    }\n\n    urlWithFilters += `?${filters.toString()}`;\n  }\n\n  return authorisedRequest('GET', urlWithFilters);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/challenges/speech/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 471,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/challenges/speech/index.js",
    "static": true,
    "longname": "src/api/challenges/speech/index.js~url",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/challenges/speech/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 472,
    "kind": "function",
    "name": "createSpeechChallenge",
    "memberof": "src/api/challenges/speech/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/speech/index.js~createSpeechChallenge",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/speech/index.js",
    "importStyle": "{createSpeechChallenge}",
    "description": "Create a new speech challenge.",
    "lineNumber": 19,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The challenge creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "The challenge to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The challenge creation promise."
    }
  },
  {
    "__docId__": 473,
    "kind": "function",
    "name": "getSpeechChallengeByID",
    "memberof": "src/api/challenges/speech/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/speech/index.js~getSpeechChallengeByID",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/speech/index.js",
    "importStyle": "{getSpeechChallengeByID}",
    "description": "Get a single speech challenge by its ID.",
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the speech challenge."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the desired speech challenge."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the speech challenge."
    }
  },
  {
    "__docId__": 474,
    "kind": "function",
    "name": "getAllSpeechChallenges",
    "memberof": "src/api/challenges/speech/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/speech/index.js~getAllSpeechChallenges",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/speech/index.js",
    "importStyle": "{getAllSpeechChallenges}",
    "description": "Get a all speech challenges.\n\nBy default all speech challenges are fetched though it is allowed to pass\nfilters as a `URLSearchParams` object.",
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the speech challenges."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "URLSearchParams"
        ],
        "spread": false,
        "optional": true,
        "name": "filters",
        "description": "The filters to apply to the category\n                                     list."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the speech challenges."
    },
    "throws": [
      {
        "types": [
          "Promise.<string>"
        ],
        "description": "If the given optional filters are not an\n                             instance of `URLSearchParams`."
      }
    ]
  },
  {
    "__docId__": 475,
    "kind": "file",
    "name": "src/api/challenges/speech/recordings.js",
    "content": "/**\n * This file contains the readily availbile functions which interact with the\n * ITSLanguage speech recordings API.\n *\n * Note that this is one of the \"nested\" or \"composite\" APIs; You can only\n * obtain the data if you provide a reference to the challenge for which you\n * want a recording.\n */\n\nimport {\n  encodeAndSendAudioOnDataAvailible,\n  prepareServerForAudio,\n  waitForUserMediaApproval\n} from '../../utils/audio-over-socket';\nimport {authorisedRequest} from '../../communication';\nimport {makeWebsocketCall} from '../../communication/websocket';\n\n// The URL for the speech recording handler(s).\nconst url = challenge => `/challenges/speech/${challenge}/recordings`;\n\n\n/**\n * Get a single speech recording by its ID.\n *\n * @param {string} challenge - The ID of the challenge for which the recording\n *                             was made.\n * @param {string} id - The ID of the desired speech recording.\n *\n * @returns {Promise} - The promise for the speech recording.\n */\nexport function getSpeechRecordingByID(challenge, id) {\n  return authorisedRequest('GET', `${url(challenge)}/${id}`);\n}\n\n\n/**\n * Get a all speech recordings.\n *\n * By default all speech recordings are fetched though it is allowed to pass\n * filters as a `URLSearchParams` object.\n *\n * @param {string} challenge - The ID of the challenge for which the recording\n *                             was made.\n * @param {URLSearchParams} [filters] - The filters to apply to the category\n *                                      list.\n *\n * @throws {Promise.<string>} - If the given optional filters are not an\n *                              instance of `URLSearchParams`.\n *\n * @returns {Promise} - The promise for the speech recordings.\n */\nexport function getAllSpeechRecordings(challenge, filters) {\n  let urlWithFilters = url(challenge);\n\n  if (filters) {\n    if (!(filters instanceof URLSearchParams)) {\n      return Promise.reject('The filters should be a `URLSearchParams` object.');\n    }\n\n    urlWithFilters += `?${filters.toString()}`;\n  }\n\n  return authorisedRequest('GET', urlWithFilters);\n}\n\n\n/**\n * Create a new recording for the given challenge with the data from the given\n * recorder.\n *\n * @param {string} challenge - The ID of the challenge for which a recording\n *                             is made.\n * @param {MediaRecorder} recorder - The recorder to use to get the recording.\n *\n * @emits {websocketserverreadyforaudio} - When the websocket server has been\n *                                         prepared for and is ready to receive\n *                                         the audio.\n *\n * @returns {Promise} - The promise which resolves once the speech recording\n *                      has successfully been stored.\n */\nexport function createSpeechRecording(challenge, recorder) {\n  return makeWebsocketCall('recording.init_recording')\n    // Initializeing the recording ought to give us an ID for the recording we\n    // are creating right now.\n    .then(recording => makeWebsocketCall('recording.init_challenge', {args: [recording, challenge]}))\n    // We've linked it to the speech challenge now. We also should have\n    // received the recording ID once again.\n    .then(recording => waitForUserMediaApproval(recording, recorder))\n    // Alright, we should have permission to record the user. Time to prep the\n    // websocket server.\n    .then(recording => prepareServerForAudio(recording, recorder, 'recording.init_audio'))\n    // We've preped the websocket server so it knows what audio format we are\n    // using and all the extra floof that comes with it.\n    .then(recording => encodeAndSendAudioOnDataAvailible(recording, recorder, 'recording.write'))\n    // When we are done; close the connection.\n    .then(recording => makeWebsocketCall('recording.close', {args: [recording]}));\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/challenges/speech/recordings.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 476,
    "kind": "function",
    "name": "url",
    "memberof": "src/api/challenges/speech/recordings.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/speech/recordings.js~url",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/challenges/speech/recordings.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "params": [
      {
        "name": "challenge",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 477,
    "kind": "function",
    "name": "getSpeechRecordingByID",
    "memberof": "src/api/challenges/speech/recordings.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/speech/recordings.js~getSpeechRecordingByID",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/speech/recordings.js",
    "importStyle": "{getSpeechRecordingByID}",
    "description": "Get a single speech recording by its ID.",
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the speech recording."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "The ID of the challenge for which the recording\n                            was made."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the desired speech recording."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the speech recording."
    }
  },
  {
    "__docId__": 478,
    "kind": "function",
    "name": "getAllSpeechRecordings",
    "memberof": "src/api/challenges/speech/recordings.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/speech/recordings.js~getAllSpeechRecordings",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/speech/recordings.js",
    "importStyle": "{getAllSpeechRecordings}",
    "description": "Get a all speech recordings.\n\nBy default all speech recordings are fetched though it is allowed to pass\nfilters as a `URLSearchParams` object.",
    "lineNumber": 52,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the speech recordings."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "The ID of the challenge for which the recording\n                            was made."
      },
      {
        "nullable": null,
        "types": [
          "URLSearchParams"
        ],
        "spread": false,
        "optional": true,
        "name": "filters",
        "description": "The filters to apply to the category\n                                     list."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the speech recordings."
    },
    "throws": [
      {
        "types": [
          "Promise.<string>"
        ],
        "description": "If the given optional filters are not an\n                             instance of `URLSearchParams`."
      }
    ]
  },
  {
    "__docId__": 479,
    "kind": "function",
    "name": "createSpeechRecording",
    "memberof": "src/api/challenges/speech/recordings.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/speech/recordings.js~createSpeechRecording",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/challenges/speech/recordings.js",
    "importStyle": "{createSpeechRecording}",
    "description": "Create a new recording for the given challenge with the data from the given\nrecorder.",
    "lineNumber": 82,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise which resolves once the speech recording\n                     has successfully been stored."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "The ID of the challenge for which a recording\n                            is made."
      },
      {
        "nullable": null,
        "types": [
          "MediaRecorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "The recorder to use to get the recording."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise which resolves once the speech recording\n                     has successfully been stored."
    },
    "emits": [
      {
        "types": [
          "websocketserverreadyforaudio"
        ],
        "description": "When the websocket server has been\n                                        prepared for and is ready to receive\n                                        the audio."
      }
    ]
  },
  {
    "__docId__": 480,
    "kind": "file",
    "name": "src/api/communication/index.js",
    "content": "/**\n * This file contains the settings and the communication mechanism for the\n * ITSLanguage REST API.\n */\n\n// Headers\nconst CONTENT_TYPE = 'Content-Type';\nconst AUTHORIZATION = 'Authorization';\n\n// Content-Types\nconst APPLICATION_JSON = 'application/json';\n\n\n/**\n * The settings to use for the communication with the ITSLanguage API.\n */\nexport const settings = {\n  apiUrl: 'https://api.itslanguage.nl',\n  wsUrl: null,\n  authorizationToken: null\n};\n\n\n/**\n * Update the settings with the `newSettings`.\n *\n * @param {Object} newSettings - The settings to inject/update.\n *\n * @throws {Error} - When the given `newSettings` is something other than a\n *                   object.\n */\nexport function updateSettings(newSettings) {\n  if (!newSettings || !(newSettings instanceof Object)) {\n    throw new Error('Please, only provide objects as settings.');\n  }\n\n  Object.assign(settings, newSettings);\n}\n\n\n/**\n * Parse the response of a fetch request.\n *\n * Try to parse the given response body as JSON, if it isn't Leave the\n * response as is.\n *\n * @param {Response} response - The response to parse.\n *\n * @throws {Promise.<String>} - When the requets was not okay and the contents\n *                              of the response isn't json.\n * @throws {Promise.<Object>} - When the requets was not okay and the contents\n *                              of the response is json.\n *\n * @returns {Promise.<Object>} - The contents of a JSON response or the\n *                               response itself if the body is something other\n *                               than JSON.\n */\nfunction handleResponse(response) {\n  const responseContentType = response.headers.get(CONTENT_TYPE);\n\n  // The ITSLanguage API should return JSON. If t\n  if (responseContentType && responseContentType.includes(APPLICATION_JSON)) {\n    return response.json().then(json => {\n      if (response.ok) {\n        return json;\n      }\n\n      return Promise.reject(json);\n    });\n  }\n\n  if (!response.ok) {\n    return Promise.reject(`${response.status}: ${response.statusText}`);\n  }\n\n  return response;\n}\n\n\n/**\n * Perform an HTTP request for the given method, url, body, and headers.\n *\n * In case the given url is a partial url, meaning it starts with a `/`, the\n * base URL to the ITSLanguage API is prepended.\n *\n * When a Object instance is provided as body, it'll be transformed into JSON.\n * Unless it is either a `URLSearchParams` or a `FormData` object. Anything\n * else is sent as plain text.\n *\n * @param {string} method - The request METHOD ('GET', 'POST', 'PUT', 'DELETE').\n * @param {string} url - The location to send the request to.\n * @param {*} [body] - Anything which needs to be sent somewhere.\n * @param {Headers} [headers] - Extra headers to send with the request.\n *\n * @returns {Promise.<Object>} The response of the made request.\n */\nexport function request(method, url, body, headers) {\n  const requestHeaders = headers || new Headers();\n\n  let requestBody = body;\n  if (!(body instanceof URLSearchParams || body instanceof FormData) && body instanceof Object) {\n    requestHeaders.set('Content-Type', 'application/json');\n    requestBody = JSON.stringify(body);\n  }\n\n  let requestURL = url;\n  // XXX remove the URL truthy check when all tests are properly written. Now\n  // it happens way to often that the URL is omitted without any good reason.\n  if (url && url.startsWith('/')) {\n    requestURL = `${settings.apiUrl}${url}`;\n  }\n\n  const requestOptions = {\n    method,\n    headers: requestHeaders,\n    body: requestBody\n  };\n\n  return fetch(requestURL, requestOptions).then(handleResponse);\n}\n\n\n/**\n * Build a bearer token from the `authorizationToken` in the settings object.\n *\n * @throws {Error} When no authorizationToken is set.\n *\n * @returns {string} The generated bearer token.\n */\nfunction getBearerToken() {\n  if (!settings.authorizationToken) {\n    throw new Error('Please authenticate first.');\n  }\n\n  return `Bearer ${settings.authorizationToken}`;\n}\n\n\n/**\n * Perform an HTTP request with the desired method, body, and headers to the\n * given partial ITSLanguage API URL.\n *\n * This request will add the ``Authorization`` header to the request.\n *\n * This function only allows to make calls to the ITSLanguage API.\n *\n * @param {string} method - The request METHOD ('GET', 'POST', 'PUT', 'DELETE').\n * @param {string} url - The location to send the request to.\n * @param {*} [body] - Anything which needs to be sent somewhere.\n * @param {Headers} [headers] - Extra headers to send with the request.\n *\n * @throws {Promise.<string>} - When the given `url` param is not a partial\n *                              URL, or when there is no authorisation token\n *                              availible.\n *\n * @returns {Promise.<Object>} - The response from the ITSLanguage API.\n */\nexport function authorisedRequest(method, url, body, headers) {\n  // XXX remove the URL truthy check when all parts of the SDK no longer build\n  // a complete url by themselves using the \"private\" settings object of their\n  // connection reference.\n  if (url && (!url.startsWith('/') && !url.startsWith(settings.apiUrl))) {\n    return Promise.reject('Only relative ITSLanguage API URLs are allowed.');\n  }\n\n  try {\n    const requestHeaders = headers || new Headers();\n    requestHeaders.set(AUTHORIZATION, getBearerToken());\n\n    return request(method, url, body, requestHeaders);\n  } catch (unauthorised) {\n    return Promise.reject(unauthorised.message);\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/communication/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 481,
    "kind": "variable",
    "name": "CONTENT_TYPE",
    "memberof": "src/api/communication/index.js",
    "static": true,
    "longname": "src/api/communication/index.js~CONTENT_TYPE",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/communication/index.js",
    "importStyle": null,
    "description": "This file contains the settings and the communication mechanism for the\nITSLanguage REST API.",
    "lineNumber": 7,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 482,
    "kind": "variable",
    "name": "AUTHORIZATION",
    "memberof": "src/api/communication/index.js",
    "static": true,
    "longname": "src/api/communication/index.js~AUTHORIZATION",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/communication/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 483,
    "kind": "variable",
    "name": "APPLICATION_JSON",
    "memberof": "src/api/communication/index.js",
    "static": true,
    "longname": "src/api/communication/index.js~APPLICATION_JSON",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/communication/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 484,
    "kind": "variable",
    "name": "settings",
    "memberof": "src/api/communication/index.js",
    "static": true,
    "longname": "src/api/communication/index.js~settings",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/communication/index.js",
    "importStyle": "{settings}",
    "description": "The settings to use for the communication with the ITSLanguage API.",
    "lineNumber": 17,
    "type": {
      "types": [
        "{\"apiUrl\": string, \"wsUrl\": *, \"authorizationToken\": *}"
      ]
    }
  },
  {
    "__docId__": 485,
    "kind": "function",
    "name": "updateSettings",
    "memberof": "src/api/communication/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/index.js~updateSettings",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/communication/index.js",
    "importStyle": "{updateSettings}",
    "description": "Update the settings with the `newSettings`.",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "newSettings",
        "description": "The settings to inject/update."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "When the given `newSettings` is something other than a\n                  object."
      }
    ],
    "return": null
  },
  {
    "__docId__": 486,
    "kind": "function",
    "name": "handleResponse",
    "memberof": "src/api/communication/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/index.js~handleResponse",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/communication/index.js",
    "importStyle": null,
    "description": "Parse the response of a fetch request.\n\nTry to parse the given response body as JSON, if it isn't Leave the\nresponse as is.",
    "lineNumber": 58,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Object>} - The contents of a JSON response or the\n                              response itself if the body is something other\n                              than JSON."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Response"
        ],
        "spread": false,
        "optional": false,
        "name": "response",
        "description": "The response to parse."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Object>"
      ],
      "spread": false,
      "description": "The contents of a JSON response or the\n                              response itself if the body is something other\n                              than JSON."
    },
    "throws": [
      {
        "types": [
          "Promise.<String>"
        ],
        "description": "When the requets was not okay and the contents\n                             of the response isn't json."
      },
      {
        "types": [
          "Promise.<Object>"
        ],
        "description": "When the requets was not okay and the contents\n                             of the response is json."
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 487,
    "kind": "function",
    "name": "request",
    "memberof": "src/api/communication/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/index.js~request",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/communication/index.js",
    "importStyle": "{request}",
    "description": "Perform an HTTP request for the given method, url, body, and headers.\n\nIn case the given url is a partial url, meaning it starts with a `/`, the\nbase URL to the ITSLanguage API is prepended.\n\nWhen a Object instance is provided as body, it'll be transformed into JSON.\nUnless it is either a `URLSearchParams` or a `FormData` object. Anything\nelse is sent as plain text.",
    "lineNumber": 97,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Object>} The response of the made request."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": "The request METHOD ('GET', 'POST', 'PUT', 'DELETE')."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "The location to send the request to."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "body",
        "description": "Anything which needs to be sent somewhere."
      },
      {
        "nullable": null,
        "types": [
          "Headers"
        ],
        "spread": false,
        "optional": true,
        "name": "headers",
        "description": "Extra headers to send with the request."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Object>"
      ],
      "spread": false,
      "description": "The response of the made request."
    }
  },
  {
    "__docId__": 488,
    "kind": "function",
    "name": "getBearerToken",
    "memberof": "src/api/communication/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/index.js~getBearerToken",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/communication/index.js",
    "importStyle": null,
    "description": "Build a bearer token from the `authorizationToken` in the settings object.",
    "lineNumber": 130,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} The generated bearer token."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The generated bearer token."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "When no authorizationToken is set."
      }
    ],
    "params": [],
    "ignore": true
  },
  {
    "__docId__": 489,
    "kind": "function",
    "name": "authorisedRequest",
    "memberof": "src/api/communication/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/index.js~authorisedRequest",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/communication/index.js",
    "importStyle": "{authorisedRequest}",
    "description": "Perform an HTTP request with the desired method, body, and headers to the\ngiven partial ITSLanguage API URL.\n\nThis request will add the ``Authorization`` header to the request.\n\nThis function only allows to make calls to the ITSLanguage API.",
    "lineNumber": 158,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<Object>} - The response from the ITSLanguage API."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": "The request METHOD ('GET', 'POST', 'PUT', 'DELETE')."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "The location to send the request to."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "body",
        "description": "Anything which needs to be sent somewhere."
      },
      {
        "nullable": null,
        "types": [
          "Headers"
        ],
        "spread": false,
        "optional": true,
        "name": "headers",
        "description": "Extra headers to send with the request."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<Object>"
      ],
      "spread": false,
      "description": "The response from the ITSLanguage API."
    },
    "throws": [
      {
        "types": [
          "Promise.<string>"
        ],
        "description": "When the given `url` param is not a partial\n                             URL, or when there is no authorisation token\n                             availible."
      }
    ]
  },
  {
    "__docId__": 490,
    "kind": "file",
    "name": "src/api/communication/websocket.js",
    "content": "/**\n *\n */\n\nimport autobahn from 'autobahn';\nimport debug from 'debug';\nimport {settings} from './index';\n\nconst log = debug('its-sdk:WebSocket');\nconst error = debug('its-sdk:WebSocket');\nlog.log = console.log.bind(console);\n\n/**\n * Keep hold of the currently open autobahn connection.\n *\n * @type {Promise.<autobahn.Connection>}\n */\nlet bundesautobahn;\n\n\n/**\n * Allow the `autobahn.Connection` to challenge the provided authentication.\n *\n * @param {autobahn.Session} session - The session of the current\n *                                     {@link autobahn.Connection}.\n * @param {string} method - The authentication method it tries to use.\n *\n * @throws {Error} - When the given `method` is unknown to the SDK.\n */\nfunction handleWebsocketAuthorisationChallenge(session, method) {\n  switch (method) {\n    case 'ticket':\n      return settings.authorizationToken;\n    default:\n      throw new Error('The websocket server tried to use the unknown ' +\n                      `authentication challenge: \"${method}\"`);\n  }\n}\n\n\n/**\n * Set {@link bundesautobahn} to a new Promise which resolves into a\n * `autobahn.Connection` object when a connection was successfully established.\n *\n * @returns {Promise.<autobahn.Connection>} - A promise which resolves when the\n *                                            connection was successfully\n *                                            created and opened.\n */\nfunction establishNewBundesbahn() {\n  bundesautobahn = new Promise((resolve, reject) => {\n    const bahn = new autobahn.Connection({\n      url: settings.wsUrl,\n      realm: 'default',\n      // Of course we want to use es6 promises if they are availbile.\n      // But, the backend sometimes spits out progress. For that we need\n      // a When.JS promise..\n      use_es6_promises: false, // eslint-disable-line camelcase\n      // The following options are required in order to authorise the\n      // connection.\n      authmethods: ['ticket'],\n      authid: 'oauth2',\n      details: {\n        ticket: settings.authorizationToken\n      },\n      onchallenge: handleWebsocketAuthorisationChallenge\n    });\n\n    // `autobahn.Connection` calls its `onclose` method, if it exists, when it\n    // was not able to open a connection.\n    bahn.onclose = (/* reason, details */) => {\n      // When the connection faild to open a reason is given with some details.\n      // Sadly these are very undescriptive. Therefore hint/warn the developer\n      // about potential erroneous settings or to contact us.\n      const message = 'The connection is erroneous; check if all required ' +\n                      'settings have been injected using the ' +\n                      '`updateSettings()` function. If the problem persists ' +\n                      'please post a issue on our GitHub repository.';\n      reject(message);\n    };\n\n    // Connection got established; lets us it.\n    bahn.onopen = () => {\n      log('Successfully established a websocket connection.');\n      // Remove the `onclose` handler as it is no longer of interest to us.\n      delete bahn.onclose;\n      resolve(bahn);\n    };\n\n    bahn.open();\n  });\n\n  // Return the promise to make it this function chainable. In case the\n  // `bundesautobahn` is rejected; remove the reference so we can use simple\n  // falsy checks to detemine if there is a connection.\n  return bundesautobahn.catch(reason => {\n    bundesautobahn = null;\n    return Promise.reject(reason);\n  });\n}\n\n\n/**\n * Open a new websocket connection.\n *\n * There there currently is a open connection, close it and open a new\n * connection.\n *\n * @returns {Promise.<string>} - A resolved promise which resolves when the\n *                               connection was successfully created and opened.\n */\nexport function openWebsocketConnection() {\n  return closeWebsocketConnection()\n    .then(() => establishNewBundesbahn())\n    // `bundesautobahn` actually resolved with the `autobahn.Connection`\n    // object. This is only meant for internal usage and therefore should not\n    // be exposed to the users of the SDK.\n    .then(() => 'Successfully established a websocket connection.');\n}\n\n\n/**\n * Get the current websocket connection, or open a new one.\n *\n * If there is no current connection, open one and return that in stead.\n *\n * @returns {Promise.<autobahn.Connection>} - The current websocket connection.\n */\nexport function getWebsocketConnection() {\n  if (!bundesautobahn) {\n    return establishNewBundesbahn();\n  }\n\n  return bundesautobahn;\n}\n\n\n/**\n * Close the current websocket connection.\n *\n * @returns {Promise.<string>} - A promise which will resolve as soon as the\n *                               connection was successfully closed.\n */\nexport function closeWebsocketConnection() {\n  if (!bundesautobahn) {\n    return Promise.resolve('There is no websocket connection to close.');\n  }\n\n  return bundesautobahn\n    .then(bahn => {\n      try {\n        bahn.close();\n        bundesautobahn = null;\n        const message = 'The websocket connection has been closed successfully.';\n        log(message);\n        return message;\n      } catch (reason) {\n        // `autobahn.Connection.close()` throws a string when the connection is\n        // already closed. The connection is not exposed and therefore cannot be\n        // closed by anyone using the SDK. Regardless, when it happens just\n        // return a resolved promise.\n        bundesautobahn = null;\n        const message = 'The websocket connection has already been closed.';\n        error(message);\n        return message;\n      }\n    });\n}\n\n\n/**\n * Make a rpc call to the ITSLanguage websocket server.\n *\n * This method will try to establish a websocket connection if there isn't one\n * already.\n *\n * @param {string} rpc - The RPC to make. This be prepended by `nl.itslanguage`\n *                       as the websocket server only handles websocket calls\n *                       when the RPC starts with that prefix.\n * @param {Object} [options] - Destructured object with options to pass to the websocket server.\n * @param {Array} [options.args] - An array with arguments to pass to the RPC.\n * @param {Object} [options.kwargs] - An object (dictionary) with arguments to pass to the RPC.\n * @param {Object} [options.options] - The options to pass to the RPC.\n * @param {Function} [options.progressCb] - Optional callback to receive progressed results.\n *\n * @returns {Promise.<*>} - The response of the websocket call.\n */\nexport function makeWebsocketCall(rpc, {args, kwargs, options, progressCb} = {}) {\n  let mergedOptions = options;\n  if (progressCb) {\n    mergedOptions = {\n      ...options,\n      receive_progress: true // eslint-disable-line camelcase\n    };\n  }\n  return getWebsocketConnection()\n    .then(connection =>\n      connection.session.call(`nl.itslanguage.${rpc}`, args, kwargs, mergedOptions)\n        .progress(progressCb)\n    )\n    .catch(result => {\n      const {error: wssError, kwargs: wssKwargs, args: wssArgs} = result;\n\n      // Log the error to stderr\n      error(result);\n\n      // Return a slightly simplistic version of the error that occurred\n      return Promise.reject({\n        error: wssError,\n        ...wssKwargs,\n        args: [...wssArgs]\n      });\n    });\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/communication/websocket.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 491,
    "kind": "variable",
    "name": "log",
    "memberof": "src/api/communication/websocket.js",
    "static": true,
    "longname": "src/api/communication/websocket.js~log",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/communication/websocket.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 492,
    "kind": "variable",
    "name": "error",
    "memberof": "src/api/communication/websocket.js",
    "static": true,
    "longname": "src/api/communication/websocket.js~error",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/communication/websocket.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 493,
    "kind": "function",
    "name": "handleWebsocketAuthorisationChallenge",
    "memberof": "src/api/communication/websocket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/websocket.js~handleWebsocketAuthorisationChallenge",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/communication/websocket.js",
    "importStyle": null,
    "description": "Allow the `autobahn.Connection` to challenge the provided authentication.",
    "lineNumber": 30,
    "params": [
      {
        "nullable": null,
        "types": [
          "autobahn.Session"
        ],
        "spread": false,
        "optional": false,
        "name": "session",
        "description": "The session of the current\n                                    {@link autobahn.Connection}."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": "The authentication method it tries to use."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "When the given `method` is unknown to the SDK."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 494,
    "kind": "function",
    "name": "establishNewBundesbahn",
    "memberof": "src/api/communication/websocket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/websocket.js~establishNewBundesbahn",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/communication/websocket.js",
    "importStyle": null,
    "description": "Set {@link bundesautobahn} to a new Promise which resolves into a\n`autobahn.Connection` object when a connection was successfully established.",
    "lineNumber": 49,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<autobahn.Connection>} - A promise which resolves when the\n                                           connection was successfully\n                                           created and opened."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<autobahn.Connection>"
      ],
      "spread": false,
      "description": "A promise which resolves when the\n                                           connection was successfully\n                                           created and opened."
    },
    "params": [],
    "ignore": true
  },
  {
    "__docId__": 495,
    "kind": "function",
    "name": "openWebsocketConnection",
    "memberof": "src/api/communication/websocket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/websocket.js~openWebsocketConnection",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/communication/websocket.js",
    "importStyle": "{openWebsocketConnection}",
    "description": "Open a new websocket connection.\n\nThere there currently is a open connection, close it and open a new\nconnection.",
    "lineNumber": 111,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<string>} - A resolved promise which resolves when the\n                              connection was successfully created and opened."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<string>"
      ],
      "spread": false,
      "description": "A resolved promise which resolves when the\n                              connection was successfully created and opened."
    },
    "params": []
  },
  {
    "__docId__": 496,
    "kind": "function",
    "name": "getWebsocketConnection",
    "memberof": "src/api/communication/websocket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/websocket.js~getWebsocketConnection",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/communication/websocket.js",
    "importStyle": "{getWebsocketConnection}",
    "description": "Get the current websocket connection, or open a new one.\n\nIf there is no current connection, open one and return that in stead.",
    "lineNumber": 128,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<autobahn.Connection>} - The current websocket connection."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<autobahn.Connection>"
      ],
      "spread": false,
      "description": "The current websocket connection."
    },
    "params": []
  },
  {
    "__docId__": 497,
    "kind": "function",
    "name": "closeWebsocketConnection",
    "memberof": "src/api/communication/websocket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/websocket.js~closeWebsocketConnection",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/communication/websocket.js",
    "importStyle": "{closeWebsocketConnection}",
    "description": "Close the current websocket connection.",
    "lineNumber": 143,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<string>} - A promise which will resolve as soon as the\n                              connection was successfully closed."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<string>"
      ],
      "spread": false,
      "description": "A promise which will resolve as soon as the\n                              connection was successfully closed."
    },
    "params": []
  },
  {
    "__docId__": 498,
    "kind": "function",
    "name": "makeWebsocketCall",
    "memberof": "src/api/communication/websocket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/websocket.js~makeWebsocketCall",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/communication/websocket.js",
    "importStyle": "{makeWebsocketCall}",
    "description": "Make a rpc call to the ITSLanguage websocket server.\n\nThis method will try to establish a websocket connection if there isn't one\nalready.",
    "lineNumber": 187,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<*>} - The response of the websocket call."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rpc",
        "description": "The RPC to make. This be prepended by `nl.itslanguage`\n                      as the websocket server only handles websocket calls\n                      when the RPC starts with that prefix."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Destructured object with options to pass to the websocket server."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "options.args",
        "description": "An array with arguments to pass to the RPC."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.kwargs",
        "description": "An object (dictionary) with arguments to pass to the RPC."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.options",
        "description": "The options to pass to the RPC."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "options.progressCb",
        "description": "Optional callback to receive progressed results."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<*>"
      ],
      "spread": false,
      "description": "The response of the websocket call."
    }
  },
  {
    "__docId__": 499,
    "kind": "file",
    "name": "src/api/groups.js",
    "content": "/**\n * This file contains the readily availbile functions which interact with the\n * ITSLanguage group API.\n */\n\nimport {authorisedRequest} from './communication';\n\n// The URL for the group handler(s).\nconst url = '/groups';\n\n\n/**\n * Create a new group.\n *\n * @param {Object} group - The group to create.\n *\n * @returns {Promise} - The group creation promise.\n */\nexport function createGroup(group) {\n  return authorisedRequest('POST', url, group);\n}\n\n\n/**\n * Get a single group by its ID.\n *\n * @param {string} id - The ID of the desired group.\n *\n * @returns {Promise} - The promise for the group.\n */\nexport function getGroupByID(id) {\n  return authorisedRequest('GET', `${url}/${id}`);\n}\n\n\n/**\n * Get a all groups.\n *\n * By default all groups are fetched though it is allowed to pass\n * filters as a `URLSearchParams` object.\n *\n * @param {URLSearchParams} [filters] - The filters to apply to the category\n *                                      list.\n *\n * @throws {Promise.<string>} - If the given optional filters are not an\n *                              instance of `URLSearchParams`.\n *\n * @returns {Promise} - The promise for the groups.\n */\nexport function getAllGroups(filters) {\n  let urlWithFilters = url;\n\n  if (filters) {\n    if (!(filters instanceof URLSearchParams)) {\n      return Promise.reject('The filters should be a `URLSearchParams` object.');\n    }\n\n    urlWithFilters += `?${filters.toString()}`;\n  }\n\n  return authorisedRequest('GET', urlWithFilters);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/groups.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 500,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/groups.js",
    "static": true,
    "longname": "src/api/groups.js~url",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/groups.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 501,
    "kind": "function",
    "name": "createGroup",
    "memberof": "src/api/groups.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/groups.js~createGroup",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/groups.js",
    "importStyle": "{createGroup}",
    "description": "Create a new group.",
    "lineNumber": 19,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The group creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "group",
        "description": "The group to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The group creation promise."
    }
  },
  {
    "__docId__": 502,
    "kind": "function",
    "name": "getGroupByID",
    "memberof": "src/api/groups.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/groups.js~getGroupByID",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/groups.js",
    "importStyle": "{getGroupByID}",
    "description": "Get a single group by its ID.",
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the group."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the desired group."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the group."
    }
  },
  {
    "__docId__": 503,
    "kind": "function",
    "name": "getAllGroups",
    "memberof": "src/api/groups.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/groups.js~getAllGroups",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/groups.js",
    "importStyle": "{getAllGroups}",
    "description": "Get a all groups.\n\nBy default all groups are fetched though it is allowed to pass\nfilters as a `URLSearchParams` object.",
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the groups."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "URLSearchParams"
        ],
        "spread": false,
        "optional": true,
        "name": "filters",
        "description": "The filters to apply to the category\n                                     list."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the groups."
    },
    "throws": [
      {
        "types": [
          "Promise.<string>"
        ],
        "description": "If the given optional filters are not an\n                             instance of `URLSearchParams`."
      }
    ]
  },
  {
    "__docId__": 504,
    "kind": "file",
    "name": "src/api/organisations.js",
    "content": "/**\n * This file contains the readily availbile functions which interact with the\n * ITSLanguage organisation API.\n */\n\nimport {authorisedRequest} from './communication';\n\n// The URL for the organisation handler(s).\nconst url = '/organisations';\n\n\n/**\n * Create a new organisation.\n *\n * @param {Object} organisation - The organisation to create.\n *\n * @returns {Promise} - The organisation creation promise.\n */\nexport function createOrganisation(organisation) {\n  return authorisedRequest('POST', url, organisation);\n}\n\n\n/**\n * Get a single organisation by its ID.\n *\n * @param {string} id - The ID of the desired organisation.\n *\n * @returns {Promise} - The promise for the organisation.\n */\nexport function getOrganisationByID(id) {\n  return authorisedRequest('GET', `${url}/${id}`);\n}\n\n\n/**\n * Get a all organisations.\n *\n * By default all organisations are fetched though it is allowed to pass\n * filters as a `URLSearchParams` object.\n *\n * @param {URLSearchParams} [filters] - The filters to apply to the category\n *                                      list.\n *\n * @throws {Promise.<string>} - If the given optional filters are not an\n *                              instance of `URLSearchParams`.\n *\n * @returns {Promise} - The promise for the organisations.\n */\nexport function getAllOrganisations(filters) {\n  let urlWithFilters = url;\n\n  if (filters) {\n    if (!(filters instanceof URLSearchParams)) {\n      return Promise.reject('The filters should be a `URLSearchParams` object.');\n    }\n\n    urlWithFilters += `?${filters.toString()}`;\n  }\n\n  return authorisedRequest('GET', urlWithFilters);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/organisations.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 505,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/organisations.js",
    "static": true,
    "longname": "src/api/organisations.js~url",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/organisations.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 506,
    "kind": "function",
    "name": "createOrganisation",
    "memberof": "src/api/organisations.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/organisations.js~createOrganisation",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/organisations.js",
    "importStyle": "{createOrganisation}",
    "description": "Create a new organisation.",
    "lineNumber": 19,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The organisation creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "organisation",
        "description": "The organisation to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The organisation creation promise."
    }
  },
  {
    "__docId__": 507,
    "kind": "function",
    "name": "getOrganisationByID",
    "memberof": "src/api/organisations.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/organisations.js~getOrganisationByID",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/organisations.js",
    "importStyle": "{getOrganisationByID}",
    "description": "Get a single organisation by its ID.",
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the organisation."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the desired organisation."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the organisation."
    }
  },
  {
    "__docId__": 508,
    "kind": "function",
    "name": "getAllOrganisations",
    "memberof": "src/api/organisations.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/organisations.js~getAllOrganisations",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/organisations.js",
    "importStyle": "{getAllOrganisations}",
    "description": "Get a all organisations.\n\nBy default all organisations are fetched though it is allowed to pass\nfilters as a `URLSearchParams` object.",
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the organisations."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "URLSearchParams"
        ],
        "spread": false,
        "optional": true,
        "name": "filters",
        "description": "The filters to apply to the category\n                                     list."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the organisations."
    },
    "throws": [
      {
        "types": [
          "Promise.<string>"
        ],
        "description": "If the given optional filters are not an\n                             instance of `URLSearchParams`."
      }
    ]
  },
  {
    "__docId__": 509,
    "kind": "file",
    "name": "src/api/roles.js",
    "content": "/**\n * This file contains the readily availbile functions which interact with the\n * ITSLanguage role API.\n */\n\nimport {authorisedRequest} from './communication';\n\n// The URL for the role handler(s).\nconst url = '/roles';\n\n\n/**\n * Get a single role by its ID.\n *\n * @param {string} id - The ID of the desired role.\n *\n * @returns {Promise} - The promise for the role.\n */\nexport function getRoleByID(id) {\n  return authorisedRequest('GET', `${url}/${id}`);\n}\n\n\n/**\n * Get a all roles.\n *\n * By default all roles are fetched though it is allowed to pass\n * filters as a `URLSearchParams` object.\n *\n * @param {URLSearchParams} [filters] - The filters to apply to the category\n *                                      list.\n *\n * @throws {Promise.<string>} - If the given optional filters are not an\n *                              instance of `URLSearchParams`.\n *\n * @returns {Promise} - The promise for the roles.\n */\nexport function getAllRoles(filters) {\n  let urlWithFilters = url;\n\n  if (filters) {\n    if (!(filters instanceof URLSearchParams)) {\n      return Promise.reject('The filters should be a `URLSearchParams` object.');\n    }\n\n    urlWithFilters += `?${filters.toString()}`;\n  }\n\n  return authorisedRequest('GET', urlWithFilters);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/roles.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 510,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/roles.js",
    "static": true,
    "longname": "src/api/roles.js~url",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/roles.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 511,
    "kind": "function",
    "name": "getRoleByID",
    "memberof": "src/api/roles.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/roles.js~getRoleByID",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/roles.js",
    "importStyle": "{getRoleByID}",
    "description": "Get a single role by its ID.",
    "lineNumber": 19,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the role."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the desired role."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the role."
    }
  },
  {
    "__docId__": 512,
    "kind": "function",
    "name": "getAllRoles",
    "memberof": "src/api/roles.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/roles.js~getAllRoles",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/roles.js",
    "importStyle": "{getAllRoles}",
    "description": "Get a all roles.\n\nBy default all roles are fetched though it is allowed to pass\nfilters as a `URLSearchParams` object.",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the roles."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "URLSearchParams"
        ],
        "spread": false,
        "optional": true,
        "name": "filters",
        "description": "The filters to apply to the category\n                                     list."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the roles."
    },
    "throws": [
      {
        "types": [
          "Promise.<string>"
        ],
        "description": "If the given optional filters are not an\n                             instance of `URLSearchParams`."
      }
    ]
  },
  {
    "__docId__": 513,
    "kind": "file",
    "name": "src/api/users.js",
    "content": "/**\n * This file contains the readily availbile functions which interact with the\n * ITSLanguage user API.\n */\n\nimport {authorisedRequest} from './communication';\n\n// The URL for the user handler(s).\nconst url = '/users';\n\n\n/**\n * Create a new user.\n *\n * @param {Object} user - The user to create.\n *\n * @returns {Promise} - The user creation promise.\n */\nexport function createUser(user) {\n  return authorisedRequest('POST', url, user);\n}\n\n\n/**\n * Get a single user by its ID.\n *\n * @param {string} id - The ID of the desired user.\n *\n * @returns {Promise} - The promise for the user.\n */\nexport function getUserByID(id) {\n  return authorisedRequest('GET', `${url}/${id}`);\n}\n\n\n/**\n * Get a all users.\n *\n * By default all users are fetched though it is allowed to pass\n * filters as a `URLSearchParams` object.\n *\n * @param {URLSearchParams} [filters] - The filters to apply to the category\n *                                      list.\n *\n * @throws {Promise.<string>} - If the given optional filters are not an\n *                              instance of `URLSearchParams`.\n *\n * @returns {Promise} - The promise for the users.\n */\nexport function getAllUsers(filters) {\n  let urlWithFilters = url;\n\n  if (filters) {\n    if (!(filters instanceof URLSearchParams)) {\n      return Promise.reject('The filters should be a `URLSearchParams` object.');\n    }\n\n    urlWithFilters += `?${filters.toString()}`;\n  }\n\n  return authorisedRequest('GET', urlWithFilters);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/users.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 514,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/users.js",
    "static": true,
    "longname": "src/api/users.js~url",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/api/users.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 515,
    "kind": "function",
    "name": "createUser",
    "memberof": "src/api/users.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/users.js~createUser",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/users.js",
    "importStyle": "{createUser}",
    "description": "Create a new user.",
    "lineNumber": 19,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The user creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "The user to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The user creation promise."
    }
  },
  {
    "__docId__": 516,
    "kind": "function",
    "name": "getUserByID",
    "memberof": "src/api/users.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/users.js~getUserByID",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/users.js",
    "importStyle": "{getUserByID}",
    "description": "Get a single user by its ID.",
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the user."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the desired user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the user."
    }
  },
  {
    "__docId__": 517,
    "kind": "function",
    "name": "getAllUsers",
    "memberof": "src/api/users.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/users.js~getAllUsers",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/users.js",
    "importStyle": "{getAllUsers}",
    "description": "Get a all users.\n\nBy default all users are fetched though it is allowed to pass\nfilters as a `URLSearchParams` object.",
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the users."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "URLSearchParams"
        ],
        "spread": false,
        "optional": true,
        "name": "filters",
        "description": "The filters to apply to the category\n                                     list."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the users."
    },
    "throws": [
      {
        "types": [
          "Promise.<string>"
        ],
        "description": "If the given optional filters are not an\n                             instance of `URLSearchParams`."
      }
    ]
  },
  {
    "__docId__": 518,
    "kind": "file",
    "name": "src/api/utils/audio-over-socket.js",
    "content": "/**\n * This file contains some re-usable parts for websocket audio communication.\n */\n\nimport {getWebsocketConnection, makeWebsocketCall} from '../communication/websocket';\nimport autobahn from 'autobahn';\nimport broadcaster from '../broadcaster';\nimport {createWAVEHeader} from '../../audio/wave-packer';\nimport {dataToBase64} from './index';\n\n\n/**\n * Encode the audio as base64 and send it to the websocket server.\n *\n * @param {string} id - The reserved ID for the audio.\n * @param {MediaRecorder|Recorder} recorder - The recorder to use to get the recording.\n * @param {string} rpc - The RPC to use to store the data.\n *\n * @returns {Promise.<*>} - The response of the given RPC.\n */\nexport function encodeAndSendAudioOnDataAvailible(id, recorder, rpc) {\n  return new Promise((resolve, reject) => {\n    // When the audio is done recording: encode the data, send it to the\n    // websocket server and continue with the chain.\n    recorder.addEventListener('dataavailable', chunk => {\n      const encoded = dataToBase64(chunk);\n      makeWebsocketCall(rpc, {args: [id, encoded, 'base64']})\n        .then(resolve, reject);\n    });\n  });\n}\n\n/**\n * Register a RPC call to the current websocket connection. The backend will call this registered\n * function once, an then we can send progressive results (the details.progress call) to send audio\n * chunks to the backend. We will send those chunks as soon as we got audio from the recorder.\n *\n * When the recording ends we un-register the rpc.\n *\n * @todo make the unregistering more solid. It can break way to easy now. One way could be, for\n *       example, to keep a list of registered RPC's and set a timer to unregister them.\n *\n * @param {Recorder} recorder - Audio recorder instance.\n * @param {string} rpcName - Name of the RPC to register. This name will be prepended with\n *                           nl.itslanguage for better consistency.\n * @returns {Promise<any>} - It returns a promise with the service registration as result.\n */\nexport function registerStreamForRecorder(recorder, rpcName) {\n  const rpc = `nl.itslanguage.${rpcName}`;\n  let rpcRegistration = null;\n\n  /**\n   * This is the actual RPC function that the backend will call. We need to make use of the\n   * autobahn deferred object (based on When.js, an older version) to be able to use progressive\n   * calls. Native promises don't support progressive result (it is not in the Promise A+ spec).\n   *\n   * For the audio chunks we assume to send audio according to the WAVE format. For this to happen\n   * we need to prepend our raw data with a WAVE file header. We do this as first step if data\n   * becomes available.\n   *\n   * @see https://github.com/crossbario/autobahn-js/blob/master/doc/reference.md#register\n   * @see https://github.com/crossbario/autobahn-js/blob/master/doc/reference.md#progressive-results\n   *\n   * @param {Array} args - Argument list.\n   * @param {Object} kwargs - Key-valued argument list.\n   * @param {Object} details - Details, just as the progress function.\n   * @returns {Promise} - A promise that can be resolved to end the asynchronous behaviour of this\n   *                      registered RCP.\n   */\n  function sendAudioChunks(args, kwargs, details) {\n    // eslint-disable-next-line new-cap\n    const defer = new autobahn.when.defer();\n    const {audioParameters: {channels, sampleRate}} = recorder.getAudioSpecs();\n    const headerArrBuff = createWAVEHeader(channels, sampleRate);\n    const header = Array.from(new Uint8Array(headerArrBuff));\n    let headerSent = false;\n\n    if (details.progress) {\n      // Listen for recording events.\n      recorder.addEventListener('dataavailable', chuck => {\n        if (!headerSent) {\n          // Sent the empty wave header first, this is needed\n          // for containerized WAVE files.\n          details.progress([header]);\n          headerSent = true;\n        }\n\n        // Send the data chunks to the backend! Whoop whoop!\n        const dataToSend = Array.from(new Uint8Array(chuck));\n        details.progress([dataToSend]);\n      });\n\n      // Recording is done. Resolve and unregister now please!\n      recorder.addEventListener('recorded', () => {\n        defer.resolve();\n        if (rpcRegistration) {\n          getWebsocketConnection().then(connection => connection.session.unregister(rpcRegistration));\n        }\n      });\n    }\n\n    return defer.promise;\n  }\n\n  // Start registering a RPC call. As a result, this function will return a promise with the\n  // registration of the RPC as result.\n  return new Promise(resolve => {\n    getWebsocketConnection().then(connection => {\n      connection.session.register(rpc, sendAudioChunks).then(registration => {\n        // Registering done. Save it so we can un-register later on.\n        rpcRegistration = registration;\n        // We've prepped the websocket server, now it can receive audio. Broadcast\n        // that it is allowed to record.\n        broadcaster.emit('websocketserverreadyforaudio');\n        resolve(registration);\n      });\n    });\n  });\n}\n\n/**\n * Send the recorder settings to the websocket server to initialize it.\n *\n * The reserved ID (passed in the parameters) is returned once the promise is\n * resolved.\n *\n * @param {string} id - The reserved ID for the audio.\n * @param {MediaRecorder|Recorder} recorder - The recorder which has been set up to\n *                                   record.\n * @param {string} rpc - The RPC to use to initialize the websocket server.\n *\n * @emits {websocketserverreadyforaudio} - When the websocket server has been\n *                                         prepared for and is ready to receive\n *                                         the audio.\n *\n * @returns {Promise} - The promise which resolves when the websocket server\n *                      is ready for the audio.\n */\nexport function prepareServerForAudio(id, recorder, rpc) {\n  const {audioFormat, audioParameters} = recorder.getAudioSpecs();\n  return makeWebsocketCall(rpc, {args: [id, audioFormat], kwargs: audioParameters})\n    .then(() => {\n      // We've prepped the websocket server, now it can receive audio. Broadcast\n      // that it is allowed to record.\n      broadcaster.emit('websocketserverreadyforaudio');\n      return id;\n    });\n}\n\n\n/**\n * Wait for the recorder to get the permission for user media.\n *\n * The reserved ID (passed in the parameters) is returned once the promise is\n * resolved.\n *\n * @param {string} id - The reserved ID for the audio.\n * @param {MediaRecorder|Recorder} recorder - The recorder for which to wait.\n *\n * @returns {Promise} - The promise which resolves if the user has allowed us\n *                      to record them.\n */\nexport function waitForUserMediaApproval(id, recorder) {\n  return new Promise(resolve => {\n    // We need the user's permission in order to record the audio. Wait for\n    // it if we don't have it already.\n    if (recorder.hasUserMediaApproval()) {\n      resolve();\n    } else {\n      recorder.addEventListener('ready', resolve);\n    }\n  }).then(() => id);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/utils/audio-over-socket.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 519,
    "kind": "function",
    "name": "encodeAndSendAudioOnDataAvailible",
    "memberof": "src/api/utils/audio-over-socket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/utils/audio-over-socket.js~encodeAndSendAudioOnDataAvailible",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/utils/audio-over-socket.js",
    "importStyle": "{encodeAndSendAudioOnDataAvailible}",
    "description": "Encode the audio as base64 and send it to the websocket server.",
    "lineNumber": 21,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise.<*>} - The response of the given RPC."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The reserved ID for the audio."
      },
      {
        "nullable": null,
        "types": [
          "MediaRecorder",
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "The recorder to use to get the recording."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rpc",
        "description": "The RPC to use to store the data."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise.<*>"
      ],
      "spread": false,
      "description": "The response of the given RPC."
    }
  },
  {
    "__docId__": 520,
    "kind": "function",
    "name": "registerStreamForRecorder",
    "memberof": "src/api/utils/audio-over-socket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/utils/audio-over-socket.js~registerStreamForRecorder",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/utils/audio-over-socket.js",
    "importStyle": "{registerStreamForRecorder}",
    "description": "Register a RPC call to the current websocket connection. The backend will call this registered\nfunction once, an then we can send progressive results (the details.progress call) to send audio\nchunks to the backend. We will send those chunks as soon as we got audio from the recorder.\n\nWhen the recording ends we un-register the rpc.",
    "lineNumber": 48,
    "todo": [
      "make the unregistering more solid. It can break way to easy now. One way could be, for\n      example, to keep a list of registered RPC's and set a timer to unregister them."
    ],
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<any>} - It returns a promise with the service registration as result."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "Audio recorder instance."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rpcName",
        "description": "Name of the RPC to register. This name will be prepended with\n                          nl.itslanguage for better consistency."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<any>"
      ],
      "spread": false,
      "description": "It returns a promise with the service registration as result."
    }
  },
  {
    "__docId__": 521,
    "kind": "function",
    "name": "prepareServerForAudio",
    "memberof": "src/api/utils/audio-over-socket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/utils/audio-over-socket.js~prepareServerForAudio",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/utils/audio-over-socket.js",
    "importStyle": "{prepareServerForAudio}",
    "description": "Send the recorder settings to the websocket server to initialize it.\n\nThe reserved ID (passed in the parameters) is returned once the promise is\nresolved.",
    "lineNumber": 139,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise which resolves when the websocket server\n                     is ready for the audio."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The reserved ID for the audio."
      },
      {
        "nullable": null,
        "types": [
          "MediaRecorder",
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "The recorder which has been set up to\n                                  record."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rpc",
        "description": "The RPC to use to initialize the websocket server."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise which resolves when the websocket server\n                     is ready for the audio."
    },
    "emits": [
      {
        "types": [
          "websocketserverreadyforaudio"
        ],
        "description": "When the websocket server has been\n                                        prepared for and is ready to receive\n                                        the audio."
      }
    ]
  },
  {
    "__docId__": 522,
    "kind": "function",
    "name": "waitForUserMediaApproval",
    "memberof": "src/api/utils/audio-over-socket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/utils/audio-over-socket.js~waitForUserMediaApproval",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/utils/audio-over-socket.js",
    "importStyle": "{waitForUserMediaApproval}",
    "description": "Wait for the recorder to get the permission for user media.\n\nThe reserved ID (passed in the parameters) is returned once the promise is\nresolved.",
    "lineNumber": 163,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise which resolves if the user has allowed us\n                     to record them."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The reserved ID for the audio."
      },
      {
        "nullable": null,
        "types": [
          "MediaRecorder",
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "The recorder for which to wait."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise which resolves if the user has allowed us\n                     to record them."
    }
  },
  {
    "__docId__": 523,
    "kind": "file",
    "name": "src/api/utils/index.js",
    "content": "/**\n * Some allround re-usable utilities.\n */\n\n/**\n * Convert the given ArrayBuffer to a base64 encoded string.\n *\n * @param {ArrayBuffer} data - The data to transform to base64.\n *\n * @returns {string} - The base64 encoded data.\n */\nexport function dataToBase64(data) {\n  let binary = '';\n  const bytes = new Uint8Array(data);\n  const len = bytes.byteLength;\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return window.btoa(binary);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/utils/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 524,
    "kind": "function",
    "name": "dataToBase64",
    "memberof": "src/api/utils/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/utils/index.js~dataToBase64",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/api/utils/index.js",
    "importStyle": "{dataToBase64}",
    "description": "Convert the given ArrayBuffer to a base64 encoded string.",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - The base64 encoded data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayBuffer"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The data to transform to base64."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The base64 encoded data."
    }
  },
  {
    "__docId__": 525,
    "kind": "file",
    "name": "src/audio/audio-player.js",
    "content": "import Stopwatch from './tools';\nimport WebAudioPlayer from './web-audio-player';\nimport allOff from 'event-emitter/all-off';\nimport ee from 'event-emitter';\n/**\n * ITSLanguage AudioPlayer non-graphical component.\n */\nexport default class AudioPlayer {\n  /**\n   * Construct an AudioPlayer for playing .wav or .mp3 files.\n   *\n   * @param {?Object} options - Override any of the default settings.\n   * @emits {Event} 'playbackstopped' When playback has ended, been stopped or been paused.\n   * @emits {Event} All events the HTML5 Audio also fires. {@link http://www.w3schools.com/tags/ref_av_dom.asp}\n   */\n  constructor(options) {\n    this._settings = Object.assign({}, options);\n\n    this._playbackCompatibility();\n    const self = this;\n    const callbacks = {\n      playingCb() {\n        self._emitter.emit('playing', []);\n      },\n      timeupdateCb() {\n        self._emitter.emit('timeupdate', []);\n      },\n      durationchangeCb() {\n        self._emitter.emit('durationchange', []);\n      },\n      canplayCb() {\n        self._emitter.emit('canplay', []);\n      },\n      endedCb() {\n        self._emitter.emit('ended', []);\n      },\n      pauseCb() {\n        self._emitter.emit('pause', []);\n      },\n      stoppedCb() {\n        self._emitter.emit('stopped', []);\n      },\n      playbackStoppedCb() {\n        self._emitter.emit('playbackstopped', []);\n        if (self._stopwatch) {\n          self._stopwatch.stop();\n        }\n      },\n      progressCb() {\n        self._emitter.emit('progress', []);\n      },\n      errorCb() {\n        self._emitter.emit('error', []);\n      }\n    };\n    /**\n     * @type {WebAudioPlayer} player - Specific audio player.\n     */\n    this._player = this._getPlayer(callbacks);\n    this._emitter = ee({});\n    this._stopwatch = null;\n    this._audioLevel = 1;\n    this._audioMuted = false;\n  }\n\n  /**\n   * Turn off all event listeners for this player.\n   */\n  resetEventListeners() {\n    allOff(this._emitter);\n  }\n\n  /**\n   * Add an event listener. Listens to events emitted from the player.\n   *\n   * @param {string} name - Name of the event.\n   * @param {Function} handler - Handler function to add.\n   */\n  addEventListener(name, handler) {\n    this._emitter.on(name, handler);\n  }\n\n  /**\n   * Remove an event listener of the player.\n   *\n   * @param {string} name - Name of the event.\n   * @param {Function} handler - Handler function to remove.\n   */\n  removeEventListener(name, handler) {\n    this._emitter.off(name, handler);\n  }\n\n  /**\n   * Check for mandatory browser compatibility.\n   * Logs detailed browser compatibilities related to for audio playback.\n   *\n   * @throws {Error} If no native wave or MP3 playback is available.\n   */\n  _playbackCompatibility() {\n    // Detect audio playback capabilities.\n\n    // Detect HTML5 Audio playback.\n    // http://caniuse.com/#feat=audio\n    this.canUseAudio = Boolean(Audio);\n    console.log('Native HTML5 Audio playback capability:', this.canUseAudio);\n\n    if (!this.canUseAudio) {\n      throw new Error(\n        'Some form of audio playback capability is required');\n    }\n    if (this.canUseAudio) {\n      const _audio = new Audio();\n      if (!(_audio.canPlayType && _audio.canPlayType instanceof Function)) {\n        throw new Error(\n          'Unable to detect audio playback capabilities');\n      }\n      const canPlayOggVorbis = _audio.canPlayType(\n        'audio/ogg; codecs=\"vorbis\"') !== '';\n      const canPlayOggOpus = _audio.canPlayType(\n        'audio/ogg; codecs=\"opus\"') !== '';\n      const canPlayWave = _audio.canPlayType('audio/wav') !== '';\n      const canPlayMP3 = _audio.canPlayType('audio/mpeg; codecs=\"mp3\"') !== '';\n      const canPlayAAC = _audio.canPlayType(\n        'audio/mp4; codecs=\"mp4a.40.2\"') !== '';\n      const canPlay3GPP = _audio.canPlayType(\n        'audio/3gpp; codecs=\"samr\"') !== '';\n\n      console.log('Native Vorbis audio in Ogg container playback capability:', canPlayOggVorbis);\n      console.log('Native Opus audio in Ogg container playback capability:', canPlayOggOpus);\n      console.log('Native PCM audio in Waveform Audio File Format (WAVE) playback capability:', canPlayWave);\n      console.log('Native MPEG Audio Layer 3 (MP3) playback capability:', canPlayMP3);\n      console.log('Native Low-Complexity AAC audio in MP4 container playback capability:', canPlayAAC);\n      console.log('Native AMR audio in 3GPP container playback capability:', canPlay3GPP);\n\n      if (!(canPlayWave || canPlayMP3)) {\n        throw new Error(\n          'Native Wave or MP3 playback is required');\n      }\n    }\n  }\n\n  /**\n   * Get a player object that performs audio compression, when available.\n   *\n   * Using the Media Stream Recording API for recording is the preferred\n   * solution. It allows recording compressed audio which makes it quicker to\n   * submit. If not available, use a default createScriptProcessor is used.\n   *\n   * @param {Function} callbacks - Callbacks to add to the chosen player.\n   * @private\n   */\n  _getPlayer(callbacks) {\n    let player = null;\n\n    if (this.canUseAudio) {\n      // Use the recorder with MediaRecorder implementation.\n      player = new WebAudioPlayer(callbacks);\n    } else {\n      throw new Error('Unable to find a proper player.');\n    }\n    console.log('Player initialised.');\n    return player;\n  }\n\n  /**\n   * Preload audio from an URL.\n   *\n   * @param {string} url - The URL that contains the audio.\n   * @param {boolean} [preload=true] - Try preloading metadata and possible some audio. Set to false to not download\n   * anything until playing.\n   * @param {?Function} loadedCb - The callback that is invoked when the duration of the audio file\n   * is first known.\n   * @emits {Event} 'canplay' When the player is ready to play.\n   */\n  load(url, preload, loadedCb) {\n    this.reset();\n    this._player.load(url, preload, loadedCb);\n    this._audioLevel = 1;\n\n    // If preloading is disabled, the 'canplay' event won't be triggered.\n    // In that case, fire it manually.\n    if (!preload) {\n      this._emitter.emit('canplay', []);\n    }\n  }\n\n  /**\n   * Unload previously loaded audio. Stops the player and any stopwatch.\n   *\n   * @emits {Event} 'unloaded'\n   */\n  reset() {\n    this.stop();\n    this._player.reset();\n    this._emitter.emit('unloaded', []);\n  }\n\n  /**\n   * Start or continue playback of audio. Also starts the stopwatch at the given position.\n   *\n   * @param {?number} position - When position is given, start playing from this position (seconds).\n   */\n  play(position) {\n    if (this._player.isPlaying()) {\n      return;\n    }\n    this._player.play(position);\n    if (this._stopwatch) {\n      const time = Math.round(this._player.getCurrentTime() * 10);\n      this._stopwatch._value = time;\n      this._stopwatch.start();\n    }\n  }\n\n  /**\n   * Stop playback of audio. Stops and resets the stopwatch.\n   */\n  stop() {\n    if (this._stopwatch) {\n      this._stopwatch.reset();\n      this._stopwatch.stop();\n    }\n    this._player.stop();\n  }\n\n  /**\n   * Pause playback of audio. Stops the stopwatch.\n   */\n  pause() {\n    if (this._stopwatch) {\n      this._stopwatch.stop();\n    }\n    this._player.pause();\n  }\n\n  /**\n   * Toggle audio playback. Switch from playing to paused state and back.\n   */\n  togglePlayback() {\n    if (this._player.isPlaying()) {\n      this.pause();\n    } else {\n      this.play();\n    }\n  }\n\n  /**\n   * Start preloading audio.\n   */\n  preload() {\n    this._player.preload();\n  }\n\n  /**\n   * Start playing audio at the given offset. Corrects a percentage under 0 or above 100 to the respective values.\n   *\n   * @param {number} percentage - Start at this percentage (0..100) of the audio stream.\n   */\n  scrub(percentage) {\n    if (percentage < 0) {\n      this._player.scrub(0);\n    } else if (percentage > 100) {\n      this._player.scrub(100);\n    } else {\n      this._player.scrub(percentage);\n    }\n    if (this._stopwatch) {\n      this._stopwatch._value = Math.round(this._player.getCurrentTime() * 10);\n    }\n  }\n\n  /**\n   * Returns the percentage of which the buffer is filled.\n   *\n   * @returns {number} Percentage of buffer fill.\n   */\n  getBufferFill() {\n    return this._player.getBufferFill();\n  }\n\n  /**\n   * Returns the current playing time as offset in seconds from the start.\n   *\n   * @returns {number} Time in seconds as offset from the start.\n   */\n  getCurrentTime() {\n    return this._player.getCurrentTime();\n  }\n\n  /**\n   * Returns the total duration in seconds.\n   *\n   * @returns {number} Time in seconds of fragment duration.\n   */\n  getDuration() {\n    return this._player.getDuration();\n  }\n\n  /**\n   * Check if there is playback in progress.\n   *\n   * @returns {boolean} True if user is currently playing audio. False otherwise.\n   */\n  isPlaying() {\n    return this._player.isPlaying();\n  }\n\n  /**\n   * Returns ready state of the player.\n   *\n   * @returns {boolean} True when player is ready to start loading data or play. False when no audio is loaded\n   * or the player is preparing.\n   */\n  canPlay() {\n    return this._player.canPlay();\n  }\n\n  /**\n   * Set the playback rate of the audio. Values are used according to HTML5 Audio.\n   * Example values:\n   * *1.0 is normal speed.\n   * *0.5 is half speed (slower).\n   * *2.0 is double speed (faster).\n   * *-1.0 is backwards, normal speed.\n   * *-0.5 is backwards, half speed.\n   *\n   * @param {number} rate - Rate at which to change the audio playback.\n   */\n  setPlaybackRate(rate) {\n    this._player.setPlaybackRate(rate);\n  }\n\n  /**\n   * Get the playback rate of the current loaded audio.\n   *\n   * @returns {number} Playback rate of the audio.\n   */\n  getPlaybackRate() {\n    return this._player.getPlaybackRate();\n  }\n\n  /**\n   * Bind a stopwatch to sync with the playing and stopping functionality of the player.\n   *\n   * @param {Function} tickCb - Callback to invoke on every tick. A tick occurs once every 100 ms.\n   * @throws {Error} If _tickCb is null.\n   * @returns {Stopwatch} New Stopwatch object.\n   */\n  bindStopwatch(tickCb) {\n    this._stopwatch = new Stopwatch(time => {\n      const duration = this.getDuration() * 10 / this._player.sound.playbackRate;\n      if (time > duration) {\n        tickCb(duration);\n      } else {\n        tickCb(time);\n      }\n    });\n    return this._stopwatch;\n  }\n\n  /**\n   * Sets the audio level of the current loaded audio. Valid values are from 0 (0%) to 1 (100%).\n   *\n   * @param {number} volume - Volume value from 0 to 1.\n   */\n  setAudioVolume(volume) {\n    if (volume !== 0) {\n      this._audioMuted = false;\n    }\n    if (volume === 0) {\n      this._audioMuted = true;\n    }\n    this._player.setAudioVolume(volume);\n  }\n\n  /**\n   * Gets the audio level of the current loaded audio. Valid values are from 0 (0%) to 1 (100%).\n   *\n   * @returns {number} Volume level of the current loaded audio.\n   */\n  getAudioVolume() {\n    return this._player.getAudioVolume();\n  }\n\n  /**\n   * Toggle the current playing audio to be muted or not. If the audio will be muted, the current audio level\n   * is remembered and can be unmuted to continue at this same audio level.\n   */\n  toggleAudioMute() {\n    this.setAudioMute(!this._audioMuted);\n  }\n\n  /**\n   * Manually set the muted state of the current loaded audio.\n   *\n   * @param {boolean} shouldMute - Whether the audio should be muted or unmuted.\n   */\n  setAudioMute(shouldMute) {\n    if (shouldMute) {\n      this._audioLevel = this.getAudioVolume();\n      this.setAudioVolume(0);\n    } else {\n      this.setAudioVolume(this._audioLevel);\n    }\n  }\n\n  /**\n   * Return the muted state of the current loaded audio.\n   *\n   * @returns {boolean} The muted state of the current loaded audio.\n   */\n  isAudioMuted() {\n    return this._audioMuted;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/audio/audio-player.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 526,
    "kind": "class",
    "name": "AudioPlayer",
    "memberof": "src/audio/audio-player.js",
    "static": true,
    "longname": "src/audio/audio-player.js~AudioPlayer",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/audio/audio-player.js",
    "importStyle": "AudioPlayer",
    "description": "ITSLanguage AudioPlayer non-graphical component.",
    "lineNumber": 8,
    "interface": false
  },
  {
    "__docId__": 527,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#constructor",
    "access": "public",
    "description": "Construct an AudioPlayer for playing .wav or .mp3 files.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": true,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Override any of the default settings."
      }
    ],
    "emits": [
      {
        "types": [
          "Event"
        ],
        "description": "'playbackstopped' When playback has ended, been stopped or been paused."
      },
      {
        "types": [
          "Event"
        ],
        "description": "All events the HTML5 Audio also fires. {@link http://www.w3schools.com/tags/ref_av_dom.asp}"
      }
    ]
  },
  {
    "__docId__": 528,
    "kind": "member",
    "name": "_settings",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#_settings",
    "access": "private",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 529,
    "kind": "member",
    "name": "_player",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#_player",
    "access": "private",
    "description": "",
    "lineNumber": 59,
    "type": {
      "nullable": null,
      "types": [
        "WebAudioPlayer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 530,
    "kind": "member",
    "name": "_emitter",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#_emitter",
    "access": "private",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 531,
    "kind": "member",
    "name": "_stopwatch",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#_stopwatch",
    "access": "private",
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 532,
    "kind": "member",
    "name": "_audioLevel",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#_audioLevel",
    "access": "private",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 533,
    "kind": "member",
    "name": "_audioMuted",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#_audioMuted",
    "access": "private",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 534,
    "kind": "method",
    "name": "resetEventListeners",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#resetEventListeners",
    "access": "public",
    "description": "Turn off all event listeners for this player.",
    "lineNumber": 69,
    "params": [],
    "return": null
  },
  {
    "__docId__": 535,
    "kind": "method",
    "name": "addEventListener",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#addEventListener",
    "access": "public",
    "description": "Add an event listener. Listens to events emitted from the player.",
    "lineNumber": 79,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of the event."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "handler",
        "description": "Handler function to add."
      }
    ],
    "return": null
  },
  {
    "__docId__": 536,
    "kind": "method",
    "name": "removeEventListener",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#removeEventListener",
    "access": "public",
    "description": "Remove an event listener of the player.",
    "lineNumber": 89,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of the event."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "handler",
        "description": "Handler function to remove."
      }
    ],
    "return": null
  },
  {
    "__docId__": 537,
    "kind": "method",
    "name": "_playbackCompatibility",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#_playbackCompatibility",
    "access": "private",
    "description": "Check for mandatory browser compatibility.\nLogs detailed browser compatibilities related to for audio playback.",
    "lineNumber": 99,
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If no native wave or MP3 playback is available."
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 538,
    "kind": "member",
    "name": "canUseAudio",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#canUseAudio",
    "access": "public",
    "description": null,
    "lineNumber": 104,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 539,
    "kind": "method",
    "name": "_getPlayer",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#_getPlayer",
    "access": "private",
    "description": "Get a player object that performs audio compression, when available.\n\nUsing the Media Stream Recording API for recording is the preferred\nsolution. It allows recording compressed audio which makes it quicker to\nsubmit. If not available, use a default createScriptProcessor is used.",
    "lineNumber": 152,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "callbacks",
        "description": "Callbacks to add to the chosen player."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 540,
    "kind": "method",
    "name": "load",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#load",
    "access": "public",
    "description": "Preload audio from an URL.",
    "lineNumber": 175,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "The URL that contains the audio."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "preload",
        "description": "Try preloading metadata and possible some audio. Set to false to not download\nanything until playing."
      },
      {
        "nullable": true,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "loadedCb",
        "description": "The callback that is invoked when the duration of the audio file\nis first known."
      }
    ],
    "emits": [
      {
        "types": [
          "Event"
        ],
        "description": "'canplay' When the player is ready to play."
      }
    ],
    "return": null
  },
  {
    "__docId__": 542,
    "kind": "method",
    "name": "reset",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#reset",
    "access": "public",
    "description": "Unload previously loaded audio. Stops the player and any stopwatch.",
    "lineNumber": 192,
    "emits": [
      {
        "types": [
          "Event"
        ],
        "description": "'unloaded'"
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 543,
    "kind": "method",
    "name": "play",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#play",
    "access": "public",
    "description": "Start or continue playback of audio. Also starts the stopwatch at the given position.",
    "lineNumber": 203,
    "params": [
      {
        "nullable": true,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "position",
        "description": "When position is given, start playing from this position (seconds)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 544,
    "kind": "method",
    "name": "stop",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#stop",
    "access": "public",
    "description": "Stop playback of audio. Stops and resets the stopwatch.",
    "lineNumber": 218,
    "params": [],
    "return": null
  },
  {
    "__docId__": 545,
    "kind": "method",
    "name": "pause",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#pause",
    "access": "public",
    "description": "Pause playback of audio. Stops the stopwatch.",
    "lineNumber": 229,
    "params": [],
    "return": null
  },
  {
    "__docId__": 546,
    "kind": "method",
    "name": "togglePlayback",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#togglePlayback",
    "access": "public",
    "description": "Toggle audio playback. Switch from playing to paused state and back.",
    "lineNumber": 239,
    "params": [],
    "return": null
  },
  {
    "__docId__": 547,
    "kind": "method",
    "name": "preload",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#preload",
    "access": "public",
    "description": "Start preloading audio.",
    "lineNumber": 250,
    "params": [],
    "return": null
  },
  {
    "__docId__": 548,
    "kind": "method",
    "name": "scrub",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#scrub",
    "access": "public",
    "description": "Start playing audio at the given offset. Corrects a percentage under 0 or above 100 to the respective values.",
    "lineNumber": 259,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "percentage",
        "description": "Start at this percentage (0..100) of the audio stream."
      }
    ],
    "return": null
  },
  {
    "__docId__": 549,
    "kind": "method",
    "name": "getBufferFill",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#getBufferFill",
    "access": "public",
    "description": "Returns the percentage of which the buffer is filled.",
    "lineNumber": 277,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Percentage of buffer fill."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Percentage of buffer fill."
    },
    "params": []
  },
  {
    "__docId__": 550,
    "kind": "method",
    "name": "getCurrentTime",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#getCurrentTime",
    "access": "public",
    "description": "Returns the current playing time as offset in seconds from the start.",
    "lineNumber": 286,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Time in seconds as offset from the start."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Time in seconds as offset from the start."
    },
    "params": []
  },
  {
    "__docId__": 551,
    "kind": "method",
    "name": "getDuration",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#getDuration",
    "access": "public",
    "description": "Returns the total duration in seconds.",
    "lineNumber": 295,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Time in seconds of fragment duration."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Time in seconds of fragment duration."
    },
    "params": []
  },
  {
    "__docId__": 552,
    "kind": "method",
    "name": "isPlaying",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#isPlaying",
    "access": "public",
    "description": "Check if there is playback in progress.",
    "lineNumber": 304,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if user is currently playing audio. False otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if user is currently playing audio. False otherwise."
    },
    "params": []
  },
  {
    "__docId__": 553,
    "kind": "method",
    "name": "canPlay",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#canPlay",
    "access": "public",
    "description": "Returns ready state of the player.",
    "lineNumber": 314,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True when player is ready to start loading data or play. False when no audio is loaded\nor the player is preparing."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True when player is ready to start loading data or play. False when no audio is loaded\nor the player is preparing."
    },
    "params": []
  },
  {
    "__docId__": 554,
    "kind": "method",
    "name": "setPlaybackRate",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#setPlaybackRate",
    "access": "public",
    "description": "Set the playback rate of the audio. Values are used according to HTML5 Audio.\nExample values:\n*1.0 is normal speed.\n*0.5 is half speed (slower).\n*2.0 is double speed (faster).\n*-1.0 is backwards, normal speed.\n*-0.5 is backwards, half speed.",
    "lineNumber": 329,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "rate",
        "description": "Rate at which to change the audio playback."
      }
    ],
    "return": null
  },
  {
    "__docId__": 555,
    "kind": "method",
    "name": "getPlaybackRate",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#getPlaybackRate",
    "access": "public",
    "description": "Get the playback rate of the current loaded audio.",
    "lineNumber": 338,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Playback rate of the audio."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Playback rate of the audio."
    },
    "params": []
  },
  {
    "__docId__": 556,
    "kind": "method",
    "name": "bindStopwatch",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#bindStopwatch",
    "access": "public",
    "description": "Bind a stopwatch to sync with the playing and stopping functionality of the player.",
    "lineNumber": 349,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Stopwatch} New Stopwatch object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "tickCb",
        "description": "Callback to invoke on every tick. A tick occurs once every 100 ms."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Stopwatch"
      ],
      "spread": false,
      "description": "New Stopwatch object."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If _tickCb is null."
      }
    ]
  },
  {
    "__docId__": 558,
    "kind": "method",
    "name": "setAudioVolume",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#setAudioVolume",
    "access": "public",
    "description": "Sets the audio level of the current loaded audio. Valid values are from 0 (0%) to 1 (100%).",
    "lineNumber": 366,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "volume",
        "description": "Volume value from 0 to 1."
      }
    ],
    "return": null
  },
  {
    "__docId__": 561,
    "kind": "method",
    "name": "getAudioVolume",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#getAudioVolume",
    "access": "public",
    "description": "Gets the audio level of the current loaded audio. Valid values are from 0 (0%) to 1 (100%).",
    "lineNumber": 381,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Volume level of the current loaded audio."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Volume level of the current loaded audio."
    },
    "params": []
  },
  {
    "__docId__": 562,
    "kind": "method",
    "name": "toggleAudioMute",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#toggleAudioMute",
    "access": "public",
    "description": "Toggle the current playing audio to be muted or not. If the audio will be muted, the current audio level\nis remembered and can be unmuted to continue at this same audio level.",
    "lineNumber": 389,
    "params": [],
    "return": null
  },
  {
    "__docId__": 563,
    "kind": "method",
    "name": "setAudioMute",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#setAudioMute",
    "access": "public",
    "description": "Manually set the muted state of the current loaded audio.",
    "lineNumber": 398,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "shouldMute",
        "description": "Whether the audio should be muted or unmuted."
      }
    ],
    "return": null
  },
  {
    "__docId__": 565,
    "kind": "method",
    "name": "isAudioMuted",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#isAudioMuted",
    "access": "public",
    "description": "Return the muted state of the current loaded audio.",
    "lineNumber": 412,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} The muted state of the current loaded audio."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "The muted state of the current loaded audio."
    },
    "params": []
  },
  {
    "__docId__": 566,
    "kind": "file",
    "name": "src/audio/audio-recorder.js",
    "content": "import Stopwatch from './tools';\nimport WavePacker from './wave-packer';\nimport WebAudioRecorder from './web-audio-recorder';\nimport allOff from 'event-emitter/all-off';\nimport ee from 'event-emitter';\nimport uuid from 'uuid';\n\n/**\n * Audio recording component.\n*/\n\nexport default class AudioRecorder {\n  /**\n   * ITSLanguage AudioRecorder.\n   *\n   * @param {?Object} options - Override any of the default settings.\n   *\n   */\n  constructor(options = {}) {\n    this._settings = Object.assign({}, options);\n\n    this._recordingCompatibility();\n\n    this.userMediaApproval = false;\n\n    /**\n     *\n     * @type {WebAudioRecorder|MediaRecorder} The specific recorder type.\n     */\n    this._recorder = null;\n\n    this._emitter = ee({});\n\n    this._stopwatch = null;\n\n    if (options.audioContext) {\n      this.audioContext = options.audioContext;\n    } else {\n      this.audioContext = this.createAudioContext();\n    }\n  }\n\n\n  /**\n   * Get the audio context or create one.\n   *\n   * @return {AudioContext} The AudioContext created will be returned\n   */\n  createAudioContext() {\n    if (!window.ItslAudioContext) {\n      window.AudioContext =\n        window.AudioContext || window.webkitAudioContext;\n      window.ItslAudioContext = new window.AudioContext();\n    }\n    return window.ItslAudioContext;\n  }\n\n  /**\n   * Turn off all event listeners for this recorder.\n   */\n  removeAllEventListeners() {\n    allOff(this._emitter);\n  }\n\n  /**\n   * Add an event listener. Listens to events emitted from the recorder.\n   *\n   * @param {string} name - Name of the event.\n   * @param {Function} handler - Handler function to add.\n   */\n  addEventListener(name, handler) {\n    this._emitter.on(name, handler);\n  }\n\n  /**\n   * Remove an event listener of the recorder.\n   *\n   * @param {string} name - Name of the event.\n   * @param {Function} handler - Handler function to remove.\n   */\n  removeEventListener(name, handler) {\n    this._emitter.off(name, handler);\n  }\n\n  /**\n   * Fire an event.\n   *\n   * @param {string} name - Name of the event.\n   * @param {Object[]} args - Arguments.\n   * @private\n   */\n  fireEvent(name, args = []) {\n    this._emitter.emit(name, ...args);\n  }\n\n  /**\n   * Check if the user has already given permission to access the microphone.\n   *\n   * @returns {boolean} True if user has granted access to the microphone. False otherwise.\n   */\n  hasUserMediaApproval() {\n    return this.userMediaApproval || false;\n  }\n\n  /**\n   * Logs browser compatibility for audio recording.\n   * In case of compatibility issues, an error is thrown.\n   *\n   * @private\n   */\n  _recordingCompatibility/* istanbul ignore next */() {\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/mediaDevices.getUserMedia\n    this.canMediaDevicesGetUserMedia = false;\n    if (navigator.mediaDevices) {\n      navigator.mediaDevices.getUserMedia = navigator.mediaDevices.getUserMedia ||\n        navigator.mediaDevices.webkitGetUserMedia ||\n        navigator.mediaDevices.mozGetUserMedia;\n      this.canMediaDevicesGetUserMedia = Boolean(navigator.mediaDevices.getUserMedia);\n    }\n    console.log('Native navigator.mediaDevices.getUserMedia API capability:', this.canMediaDevicesGetUserMedia);\n\n    if (!this.canGetUserMedia && !this.canMediaDevicesGetUserMedia) {\n      throw new Error(\n        'Some form of audio recording capability is required');\n    }\n\n    window.URL = window.URL || window.webkitURL;\n    const hasWindowURL = Boolean(window.URL);\n    console.log('Native window.URL capability:', hasWindowURL);\n    if (!hasWindowURL) {\n      throw new Error(\n        'No window.URL blob conversion capabilities');\n    }\n  }\n\n  /**\n   * Request microphone access.\n   *\n   * Calling this function may result in thrown exceptions when browser\n   * doesn't support provide live audio input.\n   *\n   * @throws {Error} If no live audio input is available or permitted.\n   * @returns {Promise} - A promise that resolves a MediaStream object.\n   *  If the user denies permission, or matching media is not available, then the\n   *  promise is rejected with PermissionDeniedError or NotFoundError respectively.\n   */\n  requestUserMedia() {\n    const readyForStream = stream => {\n      // Modify state of userMediaApproval now access is granted.\n      this.userMediaApproval = true;\n\n      const micInputGain = this._startUserMedia(stream);\n      this.fireEvent('ready', [this.audioContext, micInputGain]);\n    };\n\n    const userCanceled = error => {\n      console.error(error);\n      throw new Error('No live audio input available or permitted');\n    };\n\n    return navigator.mediaDevices.getUserMedia({audio: true})\n      .then(readyForStream)\n      .catch(userCanceled);\n  }\n\n  /**\n   * Audio access was granted, start analysing.\n   *\n   * @param {MediaStream} stream - Media Stream.\n   * @private\n   */\n  _startUserMedia(stream) {\n    // Creates an audio node from the microphone incoming stream.\n    const micInput = this.audioContext.createMediaStreamSource(stream);\n\n    // This is a workaround for a bug in Firefox that would otherwise lead to\n    // the sound input stopping after ~5 seconds.\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=934512\n    // the important thing is to save a reference to the MediaStreamAudioSourceNode\n    this.micInput = micInput;\n\n    // Create a gain node\n    const micInputGain = this.audioContext.createGain();\n    // Connect the microphone source to a gain node.\n    micInput.connect(micInputGain);\n\n    this._recorder = this._getBestRecorder(micInputGain);\n\n    return micInputGain;\n  }\n\n  /**\n   * Get a recorder object that performs audio compression, when available.\n   *\n   * Using the Media Stream Recording API for recording is the prefered\n   * solution. It allows recording compressed audio which makes it quicker to\n   * submit. If not available, use a default createScriptProcessor is used.\n   *\n   * @param {GainNode} micInputGain - The GainNode to analyze.\n   * @private\n   */\n  _getBestRecorder(micInputGain) {\n    return new WebAudioRecorder(micInputGain, this.audioContext, data => {\n      this.streamCallback(data);\n    }, new WavePacker(), false);\n  }\n\n  /**\n   * Called when a chunk of audio becomes available.\n   *\n   * @param {ArrayBuffer} chunk - A chunk of audio (Int16 formatted).\n   */\n  streamCallback(chunk) {\n    this.fireEvent('dataavailable', [chunk]);\n  }\n\n  /**\n   * Throw an error if the user is not yet logged in.\n   *\n   * @returns {boolean} True when permission was already granted. False otherwise.\n   */\n  _requireGetUserMedia() {\n    if (this._recorder) {\n      return true;\n    }\n    console.log('Requesting getUserMedia permission first.');\n    this.requestUserMedia();\n    return false;\n  }\n\n  /**\n   * Set a new recording session id.\n   *\n   * @param {number} id - When defined, stick this id to the recorded blob.\n   *\n   * @returns {number} The id that was given or a unique generated one.\n   */\n  startRecordingSession(id) {\n    // Generate a uuid to remember this recording by (locally).\n    const uuid_ = id === undefined ? uuid.v4() : id;\n    this.activeRecordingId = uuid_;\n    return uuid_;\n  }\n\n  /**\n   * Start recording microphone input until stopped.\n   *\n   * @param {?Function} cb - The callback that provides a piece of raw audio when\n   * it becomes available. It may be used for streaming.\n   * @emits {Event} 'recording' With arguments: [recording ID].\n   */\n  record(cb) {\n    if (!this._requireGetUserMedia()) {\n      return;\n    }\n\n    if (this.isRecording()) {\n      throw new Error('Already recording, stop recording first.');\n    }\n\n    this.audioContext.resume();\n\n    this._recorder.record();\n    if (this._stopwatch) {\n      this._stopwatch._value = 0;\n      this._stopwatch.start();\n    }\n\n    if (!this.activeRecordingId) {\n      this.startRecordingSession();\n    }\n    console.log('Recording as id: ' + this.activeRecordingId);\n\n    this.fireEvent('recording', [this.activeRecordingId]);\n    return cb;\n  }\n\n  /**\n   * Stop recording microphone input.\n   *\n   * @param {boolean} [forced=false] - Set whether to force the microphone to stop recording or let it end normally.\n   * @emits {Event} 'recorded' With arguments: [recording ID, audio Blob, forced].\n   */\n  stop(forced) {\n    if (!this._recorder.isRecording()) {\n      return;\n    }\n    this._recorder.stop();\n    if (this._stopwatch) {\n      this._stopwatch.stop();\n    }\n    console.log('Stopped recording for id: ' + this.activeRecordingId);\n\n    const self = this;\n    this._recorder.getEncodedAudio(blob => {\n      console.log('Received encoded audio of type: ' + blob.type);\n      // Allow direct playback from local blob.\n      self.fireEvent('recorded', [self.activeRecordingId, blob, Boolean(forced)]);\n    });\n  }\n\n  /**\n   * Check if there is a recording in progress.\n   *\n   * @returns {boolean} True if user is currently recording audio. False` otherwise.\n   */\n  isRecording() {\n    if (!this._recorder) {\n      return false;\n    }\n    return this._recorder.isRecording();\n  }\n\n  /**\n   * Toggle audio playback. Switch from playing to paused state and back.\n   */\n  toggleRecording() {\n    if (this.isRecording()) {\n      this.stop();\n    } else {\n      this.record();\n    }\n  }\n\n  /**\n   * Get the recorded audio specifications.\n   *\n   * @returns {Object} Containing audioFormat and audioParameters describing the format.\n   */\n  getAudioSpecs() {\n    return this._recorder.getAudioSpecs();\n  }\n\n  /**\n   * Bind a stopwatch to sync with the playing and stopping functionality of the recorder.\n   *\n   * @param {Function} tickCb - Callback to invoke on every tick. A tick occurs once every 100 ms.\n   * @throws {Error} If _tickCb is null.\n   * @returns {Stopwatch} New Stopwatch object.\n   */\n  bindStopwatch(tickCb) {\n    this._stopwatch = new Stopwatch(tickCb);\n    return this._stopwatch;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/audio/audio-recorder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 567,
    "kind": "class",
    "name": "AudioRecorder",
    "memberof": "src/audio/audio-recorder.js",
    "static": true,
    "longname": "src/audio/audio-recorder.js~AudioRecorder",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/audio/audio-recorder.js",
    "importStyle": "AudioRecorder",
    "description": "Audio recording component.",
    "lineNumber": 12,
    "interface": false
  },
  {
    "__docId__": 568,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#constructor",
    "access": "public",
    "description": "ITSLanguage AudioRecorder.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": true,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Override any of the default settings."
      }
    ]
  },
  {
    "__docId__": 569,
    "kind": "member",
    "name": "_settings",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#_settings",
    "access": "private",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 570,
    "kind": "member",
    "name": "userMediaApproval",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#userMediaApproval",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 571,
    "kind": "member",
    "name": "_recorder",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#_recorder",
    "access": "private",
    "description": "",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "WebAudioRecorder",
        "MediaRecorder"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 572,
    "kind": "member",
    "name": "_emitter",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#_emitter",
    "access": "private",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 573,
    "kind": "member",
    "name": "_stopwatch",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#_stopwatch",
    "access": "private",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 574,
    "kind": "member",
    "name": "audioContext",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#audioContext",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 576,
    "kind": "method",
    "name": "createAudioContext",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#createAudioContext",
    "access": "public",
    "description": "Get the audio context or create one.",
    "lineNumber": 49,
    "return": {
      "nullable": null,
      "types": [
        "AudioContext"
      ],
      "spread": false,
      "description": "The AudioContext created will be returned"
    },
    "params": []
  },
  {
    "__docId__": 577,
    "kind": "method",
    "name": "removeAllEventListeners",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#removeAllEventListeners",
    "access": "public",
    "description": "Turn off all event listeners for this recorder.",
    "lineNumber": 61,
    "params": [],
    "return": null
  },
  {
    "__docId__": 578,
    "kind": "method",
    "name": "addEventListener",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#addEventListener",
    "access": "public",
    "description": "Add an event listener. Listens to events emitted from the recorder.",
    "lineNumber": 71,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of the event."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "handler",
        "description": "Handler function to add."
      }
    ],
    "return": null
  },
  {
    "__docId__": 579,
    "kind": "method",
    "name": "removeEventListener",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#removeEventListener",
    "access": "public",
    "description": "Remove an event listener of the recorder.",
    "lineNumber": 81,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of the event."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "handler",
        "description": "Handler function to remove."
      }
    ],
    "return": null
  },
  {
    "__docId__": 580,
    "kind": "method",
    "name": "fireEvent",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#fireEvent",
    "access": "private",
    "description": "Fire an event.",
    "lineNumber": 92,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of the event."
      },
      {
        "nullable": null,
        "types": [
          "Object[]"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": "Arguments."
      }
    ],
    "return": null
  },
  {
    "__docId__": 581,
    "kind": "method",
    "name": "hasUserMediaApproval",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#hasUserMediaApproval",
    "access": "public",
    "description": "Check if the user has already given permission to access the microphone.",
    "lineNumber": 101,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if user has granted access to the microphone. False otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if user has granted access to the microphone. False otherwise."
    },
    "params": []
  },
  {
    "__docId__": 582,
    "kind": "method",
    "name": "_recordingCompatibility",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#_recordingCompatibility",
    "access": "private",
    "description": "Logs browser compatibility for audio recording.\nIn case of compatibility issues, an error is thrown.",
    "lineNumber": 111,
    "params": [],
    "return": null
  },
  {
    "__docId__": 583,
    "kind": "member",
    "name": "canMediaDevicesGetUserMedia",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#canMediaDevicesGetUserMedia",
    "access": "public",
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 585,
    "kind": "method",
    "name": "requestUserMedia",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#requestUserMedia",
    "access": "public",
    "description": "Request microphone access.\n\nCalling this function may result in thrown exceptions when browser\ndoesn't support provide live audio input.",
    "lineNumber": 147,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - A promise that resolves a MediaStream object.\n If the user denies permission, or matching media is not available, then the\n promise is rejected with PermissionDeniedError or NotFoundError respectively."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A promise that resolves a MediaStream object.\n If the user denies permission, or matching media is not available, then the\n promise is rejected with PermissionDeniedError or NotFoundError respectively."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If no live audio input is available or permitted."
      }
    ],
    "params": []
  },
  {
    "__docId__": 587,
    "kind": "method",
    "name": "_startUserMedia",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#_startUserMedia",
    "access": "private",
    "description": "Audio access was granted, start analysing.",
    "lineNumber": 172,
    "params": [
      {
        "nullable": null,
        "types": [
          "MediaStream"
        ],
        "spread": false,
        "optional": false,
        "name": "stream",
        "description": "Media Stream."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 588,
    "kind": "member",
    "name": "micInput",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#micInput",
    "access": "public",
    "description": null,
    "lineNumber": 180,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 590,
    "kind": "method",
    "name": "_getBestRecorder",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#_getBestRecorder",
    "access": "private",
    "description": "Get a recorder object that performs audio compression, when available.\n\nUsing the Media Stream Recording API for recording is the prefered\nsolution. It allows recording compressed audio which makes it quicker to\nsubmit. If not available, use a default createScriptProcessor is used.",
    "lineNumber": 202,
    "params": [
      {
        "nullable": null,
        "types": [
          "GainNode"
        ],
        "spread": false,
        "optional": false,
        "name": "micInputGain",
        "description": "The GainNode to analyze."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 591,
    "kind": "method",
    "name": "streamCallback",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#streamCallback",
    "access": "public",
    "description": "Called when a chunk of audio becomes available.",
    "lineNumber": 213,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayBuffer"
        ],
        "spread": false,
        "optional": false,
        "name": "chunk",
        "description": "A chunk of audio (Int16 formatted)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 592,
    "kind": "method",
    "name": "_requireGetUserMedia",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#_requireGetUserMedia",
    "access": "private",
    "description": "Throw an error if the user is not yet logged in.",
    "lineNumber": 222,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True when permission was already granted. False otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True when permission was already granted. False otherwise."
    },
    "params": []
  },
  {
    "__docId__": 593,
    "kind": "method",
    "name": "startRecordingSession",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#startRecordingSession",
    "access": "public",
    "description": "Set a new recording session id.",
    "lineNumber": 238,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} The id that was given or a unique generated one."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "When defined, stick this id to the recorded blob."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The id that was given or a unique generated one."
    }
  },
  {
    "__docId__": 594,
    "kind": "member",
    "name": "activeRecordingId",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#activeRecordingId",
    "access": "public",
    "description": null,
    "lineNumber": 241,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 595,
    "kind": "method",
    "name": "record",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#record",
    "access": "public",
    "description": "Start recording microphone input until stopped.",
    "lineNumber": 252,
    "params": [
      {
        "nullable": true,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "cb",
        "description": "The callback that provides a piece of raw audio when\nit becomes available. It may be used for streaming."
      }
    ],
    "emits": [
      {
        "types": [
          "Event"
        ],
        "description": "'recording' With arguments: [recording ID]."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 596,
    "kind": "method",
    "name": "stop",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#stop",
    "access": "public",
    "description": "Stop recording microphone input.",
    "lineNumber": 284,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "forced",
        "description": "Set whether to force the microphone to stop recording or let it end normally."
      }
    ],
    "emits": [
      {
        "types": [
          "Event"
        ],
        "description": "'recorded' With arguments: [recording ID, audio Blob, forced]."
      }
    ],
    "return": null
  },
  {
    "__docId__": 597,
    "kind": "method",
    "name": "isRecording",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#isRecording",
    "access": "public",
    "description": "Check if there is a recording in progress.",
    "lineNumber": 307,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if user is currently recording audio. False` otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if user is currently recording audio. False` otherwise."
    },
    "params": []
  },
  {
    "__docId__": 598,
    "kind": "method",
    "name": "toggleRecording",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#toggleRecording",
    "access": "public",
    "description": "Toggle audio playback. Switch from playing to paused state and back.",
    "lineNumber": 317,
    "params": [],
    "return": null
  },
  {
    "__docId__": 599,
    "kind": "method",
    "name": "getAudioSpecs",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#getAudioSpecs",
    "access": "public",
    "description": "Get the recorded audio specifications.",
    "lineNumber": 330,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} Containing audioFormat and audioParameters describing the format."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Containing audioFormat and audioParameters describing the format."
    },
    "params": []
  },
  {
    "__docId__": 600,
    "kind": "method",
    "name": "bindStopwatch",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#bindStopwatch",
    "access": "public",
    "description": "Bind a stopwatch to sync with the playing and stopping functionality of the recorder.",
    "lineNumber": 341,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Stopwatch} New Stopwatch object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "tickCb",
        "description": "Callback to invoke on every tick. A tick occurs once every 100 ms."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Stopwatch"
      ],
      "spread": false,
      "description": "New Stopwatch object."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If _tickCb is null."
      }
    ]
  },
  {
    "__docId__": 602,
    "kind": "file",
    "name": "src/audio/audio-tools.js",
    "content": "/* eslint-disable\n new-cap\n */\n/**\n * @title ITSLanguage Javascript Audio\n * @overview This is part of the ITSLanguage Javascript SDK to perform audio related functions.\n * @copyright (c) 2014 ITSLanguage\n * @license MIT\n * @author d-centralize\n */\n\n\n/**\n@module its.Audio.Tools\nITSLanguage Audio tools.\n*/\n\n\nimport pcm from 'pcmjs';\n\n\n/**\n * Generate a dummy Wave file for testing purposes.\n *\n * @param {number} duration - Length of audio in seconds.\n * @returns {string} A new URL containing the Wave file.\n */\nexport function generateWaveSample(duration) {\n  const effect = [];\n  const sampleRate = 22000;\n  const loops = duration * sampleRate;\n  for (let i = 0; i < loops; i++) {\n    effect[i] = 64 + Math.round(\n      32 * (Math.cos(i * i / 2000) + Math.sin(i * i / 4000)));\n  }\n  const wave = new pcm({channels: 1, rate: 22000, depth: 8}).toWav(effect);\n  return wave.encode();\n}\n\n\nexport default class VolumeMeter {\n  /**\n   * Represents a volume meter.\n   *\n   * @param {AudioContext} audioContext - The WebAudio context.\n   * @param {MediaStream} inputStream - The MediaStream to analyze.\n   */\n  constructor(audioContext, inputStream) {\n    this.audioContext = audioContext;\n    this.stream = inputStream;\n    this.willAnimate = true;\n  }\n\n\n  /**\n   * Start analysing the audio stream and provide updates to the specified callback function.\n   *\n   * @param {Function} callback - This function is called when there's a new volume reading is available.\n   * First parameter is the volume.\n   * @param {?Array} args - Optional array of parameters to pass to the callback after the volume parameter.\n   */\n  getVolumeIndication(callback, args) {\n    if (!callback) {\n      throw new Error('Callback parameter unspecified.');\n    }\n\n    // Convert single callback to Array of callbacks\n    if (!(callback instanceof Array)) {\n      callback = [callback];\n    }\n\n    this.volumeIndicationCallback = callback;\n    this.volumeIndicationCallbackArgs = args || [];\n\n    this.analyserNode = this.audioContext.createAnalyser();\n    this.analyserNode.fftSize = 2048;\n    this.stream.connect(this.analyserNode);\n\n    this._updateAnalysers();\n  }\n\n  static _getAverageVolume(array) {\n    let values = 0;\n\n    const length = array.length;\n\n    // Get all the frequency amplitudes\n    for (let i = 0; i < length; i++) {\n      values += array[i];\n    }\n\n    const average = values / length;\n    return average;\n  }\n\n  /**\n   * Calculate the volume, inform listeners by executing the callback.\n   * Repeat indefinitely.\n   */\n  _updateAnalysers() {\n    const volumeIndicationCallback = this.volumeIndicationCallback;\n    const volumeIndicationCallbackArgs = this.volumeIndicationCallbackArgs;\n    const analyserNode = this.analyserNode;\n    const volumeMeter = this;\n    let skippedCallbacks = 0;\n    let lastVolume = -1;\n\n    animloop();\n\n    function animloop() {\n      /* The Window.requestAnimationFrame() method tells the\n       * browser that you wish to perform an animation and\n       * requests that the browser call a specified function to\n       * update an animation before the next repaint. The method\n       * takes as an argument a callback to be invoked before\n       * the repaint.\n       */\n      const requestAnimationFrame = window.requestAnimationFrame ||\n        window.mozRequestAnimationFrame ||\n        window.webkitRequestAnimationFrame ||\n        window.msRequestAnimationFrame;\n\n      const freqByteData = new Uint8Array(analyserNode.frequencyBinCount);\n\n      analyserNode.getByteFrequencyData(freqByteData);\n      let averageVolume = VolumeMeter._getAverageVolume(freqByteData);\n\n      if (volumeMeter.willAnimate) {\n        requestAnimationFrame(animloop);\n      } else {\n        // Stop animating, provide callback with zero volume so the\n        // meter doesn't appear to be stuck at the last volume level.\n        averageVolume = 0;\n      }\n\n      // Callback only on substantial changes.\n      const minDiff = 1;\n      if (parseInt(averageVolume) >= lastVolume - minDiff &&\n        parseInt(averageVolume) <= lastVolume + minDiff) {\n        // console.log('Skip same average: ' + lastVolume);\n        return true;\n      }\n      // console.log('Got new volume: ' + parseInt(averageVolume) +\n      // ' (old: ' + lastVolume + ')');\n      lastVolume = parseInt(averageVolume);\n\n      const args = [averageVolume].concat(volumeIndicationCallbackArgs);\n      // Fire all callbacks.\n      volumeIndicationCallback.forEach(cb => {\n        // This kludge prevents firing an averageVolume of zero\n        // right away. The buffer probably needs filling before useful\n        // values become available. 5 seems to be the magic number.\n        if (skippedCallbacks < 5) {\n          skippedCallbacks += 1;\n          return true;\n        }\n        return cb(args);\n      });\n    }\n  }\n\n  /**\n   * Stop calculating the volume.\n   */\n  stopAnalyser() {\n    this.willAnimate = false;\n  }\n\n  /**\n   * Start calculating the volume.\n   */\n  resumeAnalyser() {\n    this.willAnimate = true;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/audio/audio-tools.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 603,
    "kind": "function",
    "name": "generateWaveSample",
    "memberof": "src/audio/audio-tools.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/audio/audio-tools.js~generateWaveSample",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/audio/audio-tools.js",
    "importStyle": "{generateWaveSample}",
    "description": "Generate a dummy Wave file for testing purposes.",
    "lineNumber": 28,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} A new URL containing the Wave file."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "duration",
        "description": "Length of audio in seconds."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "A new URL containing the Wave file."
    }
  },
  {
    "__docId__": 604,
    "kind": "class",
    "name": "VolumeMeter",
    "memberof": "src/audio/audio-tools.js",
    "static": true,
    "longname": "src/audio/audio-tools.js~VolumeMeter",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/audio/audio-tools.js",
    "importStyle": "VolumeMeter",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 605,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#constructor",
    "access": "public",
    "description": "Represents a volume meter.",
    "lineNumber": 48,
    "params": [
      {
        "nullable": null,
        "types": [
          "AudioContext"
        ],
        "spread": false,
        "optional": false,
        "name": "audioContext",
        "description": "The WebAudio context."
      },
      {
        "nullable": null,
        "types": [
          "MediaStream"
        ],
        "spread": false,
        "optional": false,
        "name": "inputStream",
        "description": "The MediaStream to analyze."
      }
    ]
  },
  {
    "__docId__": 606,
    "kind": "member",
    "name": "audioContext",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#audioContext",
    "access": "public",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 607,
    "kind": "member",
    "name": "stream",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#stream",
    "access": "public",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 608,
    "kind": "member",
    "name": "willAnimate",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#willAnimate",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 609,
    "kind": "method",
    "name": "getVolumeIndication",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#getVolumeIndication",
    "access": "public",
    "description": "Start analysing the audio stream and provide updates to the specified callback function.",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "This function is called when there's a new volume reading is available.\nFirst parameter is the volume."
      },
      {
        "nullable": true,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": "Optional array of parameters to pass to the callback after the volume parameter."
      }
    ],
    "return": null
  },
  {
    "__docId__": 610,
    "kind": "member",
    "name": "volumeIndicationCallback",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#volumeIndicationCallback",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 611,
    "kind": "member",
    "name": "volumeIndicationCallbackArgs",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#volumeIndicationCallbackArgs",
    "access": "public",
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 612,
    "kind": "member",
    "name": "analyserNode",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#analyserNode",
    "access": "public",
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 613,
    "kind": "method",
    "name": "_getAverageVolume",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/audio/audio-tools.js~VolumeMeter._getAverageVolume",
    "access": "private",
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 614,
    "kind": "method",
    "name": "_updateAnalysers",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#_updateAnalysers",
    "access": "private",
    "description": "Calculate the volume, inform listeners by executing the callback.\nRepeat indefinitely.",
    "lineNumber": 100,
    "params": [],
    "return": null
  },
  {
    "__docId__": 615,
    "kind": "method",
    "name": "stopAnalyser",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#stopAnalyser",
    "access": "public",
    "description": "Stop calculating the volume.",
    "lineNumber": 165,
    "params": [],
    "return": null
  },
  {
    "__docId__": 617,
    "kind": "method",
    "name": "resumeAnalyser",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#resumeAnalyser",
    "access": "public",
    "description": "Start calculating the volume.",
    "lineNumber": 172,
    "params": [],
    "return": null
  },
  {
    "__docId__": 619,
    "kind": "file",
    "name": "src/audio/media-recorder.js",
    "content": "/*\n * Use the Media Stream Recording API for recording and encoding. Ogg Opus\n * (audio/ogg) is the prefered output format.\n *\n * The Media Stream Recording API is W3C standard in the making:\n * https://dvcs.w3.org/hg/dap/raw-file/tip/media-stream-capture/RecordingProposal.html\n *\n * Currently only supported in Firefox. There's a standards author working for\n * Microsoft which hints wide adoption in the future.\n *\n * Encoder only supports 48k/16k mono audio channel.\n * http://dxr.mozilla.org/mozilla-central/source/content/media/MediaRecorder.cpp\n * https://wiki.mozilla.org/Gecko:MediaRecorder\n *\n */\n/**\n * @private\n */\nexport default class MediaRecorder {\n  /**\n   * MediaRecorder.\n   *\n   * @param {MediaStream} mediaStream - The MediaStream to analyze.\n   */\n  constructor(mediaStream) {\n    const self = this;\n    this.mediaRecorder = new window.MediaRecorder(mediaStream);\n    this.mediaRecorder.ondataavailable = function(e) {\n      self.recordedBlob = new Blob([e.data], {\n        type: 'audio/ogg'\n      });\n      console.log('Recorded audio/ogg Blob size: ' + self.recordedBlob.size);\n      if (self.callback) {\n        self.callback(self.recordedBlob);\n        self.callback = null;\n      }\n    };\n  }\n\n  /**\n   * Start recording audio.\n   */\n  record() {\n    this.recordedBlob = null;\n    this.callback = null;\n    this.mediaRecorder.start();\n  }\n\n  /**\n   * Is audio recording in progress.\n   *\n   * @returns {boolean} True when recording. False otherwise.\n   */\n  isRecording() {\n    return this.mediaRecorder.state === 'recording';\n  }\n\n  /**\n   * Stop recording audio.\n   */\n  stop() {\n    if (this.isRecording()) {\n      // Calling `stop()` throws a dataavailable event.\n      this.mediaRecorder.stop();\n    }\n  }\n\n  /**\n   * Request encoded audio to be returned through callback.\n   *\n   * @param {Function} callback - The callback to use when returning the audio as a blob in Ogg Opus format.\n   */\n  getEncodedAudio(callback) {\n    if (this.recordedBlob) {\n      // Data already available, return right away.\n      callback(this.recordedBlob);\n      return;\n    }\n    // Callback will trigger later when audio is ready.\n    this.callback = callback;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/audio/media-recorder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 620,
    "kind": "class",
    "name": "MediaRecorder",
    "memberof": "src/audio/media-recorder.js",
    "static": true,
    "longname": "src/audio/media-recorder.js~MediaRecorder",
    "access": "private",
    "export": true,
    "importPath": "itslanguage/audio/media-recorder.js",
    "importStyle": "MediaRecorder",
    "description": "",
    "lineNumber": 19,
    "interface": false
  },
  {
    "__docId__": 621,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/audio/media-recorder.js~MediaRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/media-recorder.js~MediaRecorder#constructor",
    "access": "public",
    "description": "MediaRecorder.",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "MediaStream"
        ],
        "spread": false,
        "optional": false,
        "name": "mediaStream",
        "description": "The MediaStream to analyze."
      }
    ]
  },
  {
    "__docId__": 622,
    "kind": "member",
    "name": "mediaRecorder",
    "memberof": "src/audio/media-recorder.js~MediaRecorder",
    "static": false,
    "longname": "src/audio/media-recorder.js~MediaRecorder#mediaRecorder",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 623,
    "kind": "method",
    "name": "record",
    "memberof": "src/audio/media-recorder.js~MediaRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/media-recorder.js~MediaRecorder#record",
    "access": "public",
    "description": "Start recording audio.",
    "lineNumber": 43,
    "params": [],
    "return": null
  },
  {
    "__docId__": 624,
    "kind": "member",
    "name": "recordedBlob",
    "memberof": "src/audio/media-recorder.js~MediaRecorder",
    "static": false,
    "longname": "src/audio/media-recorder.js~MediaRecorder#recordedBlob",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 625,
    "kind": "member",
    "name": "callback",
    "memberof": "src/audio/media-recorder.js~MediaRecorder",
    "static": false,
    "longname": "src/audio/media-recorder.js~MediaRecorder#callback",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 626,
    "kind": "method",
    "name": "isRecording",
    "memberof": "src/audio/media-recorder.js~MediaRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/media-recorder.js~MediaRecorder#isRecording",
    "access": "public",
    "description": "Is audio recording in progress.",
    "lineNumber": 54,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True when recording. False otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True when recording. False otherwise."
    },
    "params": []
  },
  {
    "__docId__": 627,
    "kind": "method",
    "name": "stop",
    "memberof": "src/audio/media-recorder.js~MediaRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/media-recorder.js~MediaRecorder#stop",
    "access": "public",
    "description": "Stop recording audio.",
    "lineNumber": 61,
    "params": [],
    "return": null
  },
  {
    "__docId__": 628,
    "kind": "method",
    "name": "getEncodedAudio",
    "memberof": "src/audio/media-recorder.js~MediaRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/media-recorder.js~MediaRecorder#getEncodedAudio",
    "access": "public",
    "description": "Request encoded audio to be returned through callback.",
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback to use when returning the audio as a blob in Ogg Opus format."
      }
    ],
    "return": null
  },
  {
    "__docId__": 630,
    "kind": "file",
    "name": "src/audio/tools.js",
    "content": "/**\n * @title ITSLanguage Javascript\n * @overview This is part of the ITSLanguage Javascript SDK to perform helper functions.\n * @copyright (c) 2014 ITSLanguage\n * @license MIT\n * @author d-centralize\n */\n\nconst ee = require('event-emitter');\n\n/**\n@module Tools\nITSLanguage helper tools.\n*/\n\n/**\n * A simple stopwatch that ticks every 100 ms. It can be bound to an {@link AudioPlayer} or {@link AudioRecorder}\n * which binds the stop and playing functionality to the stopping and starting of the Watch.\n * It can also be listened to by other entities.\n * @experimental When binding to an Audio Recorder, the stopwatch is not always synced properly.\n * A difference of 0.1s or 0.2s too high may occur when counting. When binding to an Audio Player however, the timer\n * will sync properly and show the correct duration of the loaded audio file.\n */\nexport default class Stopwatch {\n  /**\n   * @param {Function} tickCb - The callback that is invoked on every tick (every 100ms).\n   * @throws {Error} If tickCb is missing.\n   */\n  constructor(tickCb) {\n    if (!tickCb) {\n      throw new Error('tickCb parameter required');\n    }\n    this._interval = null;\n    this._value = 0;\n    this._tickCb = tickCb;\n    this._emitter = ee({});\n  }\n\n  /**\n   * Start counting and tick every 100 ms.\n   */\n  start() {\n    console.debug('Start counting');\n    // Tick every 100ms (0.1s)\n    const self = this;\n    this._interval = setInterval(() => {\n      self.update();\n    }, 100);\n  }\n\n  /**\n   * Stop counting.\n   */\n  stop() {\n    console.debug('Stop counting');\n    clearInterval(this._interval);\n    this.tick();\n    this._interval = null;\n  }\n\n  /**\n   * Reset count to 0.\n   */\n  reset() {\n    console.debug('Reset count');\n    this._value = 0;\n    this.tick();\n  }\n\n  /**\n   * Tick once and increment the value by 1.\n   */\n  update() {\n    this.tick();\n    this._value++;\n  }\n\n  /**\n   * Invoke the tick callback with the current value.\n   */\n  tick() {\n    this._tickCb(this._value);\n    this._emitter.emit('tick', this._value);\n  }\n\n  registerListener(tickCb) {\n    this._emitter.on('tick', tickCb);\n  }\n\n  stopListening(tickCb) {\n    this._emitter.off('tick', tickCb);\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/audio/tools.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 631,
    "kind": "variable",
    "name": "ee",
    "memberof": "src/audio/tools.js",
    "static": true,
    "longname": "src/audio/tools.js~ee",
    "access": "public",
    "export": false,
    "importPath": "itslanguage/audio/tools.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@title",
        "tagValue": "ITSLanguage Javascript"
      },
      {
        "tagName": "@overview",
        "tagValue": "This is part of the ITSLanguage Javascript SDK to perform helper functions."
      },
      {
        "tagName": "@copyright",
        "tagValue": "(c) 2014 ITSLanguage"
      },
      {
        "tagName": "@license",
        "tagValue": "MIT"
      },
      {
        "tagName": "@author",
        "tagValue": "d-centralize"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 632,
    "kind": "class",
    "name": "Stopwatch",
    "memberof": "src/audio/tools.js",
    "static": true,
    "longname": "src/audio/tools.js~Stopwatch",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/audio/tools.js",
    "importStyle": "Stopwatch",
    "description": "A simple stopwatch that ticks every 100 ms. It can be bound to an {@link AudioPlayer} or {@link AudioRecorder}\nwhich binds the stop and playing functionality to the stopping and starting of the Watch.\nIt can also be listened to by other entities.",
    "lineNumber": 24,
    "experimental": "When binding to an Audio Recorder, the stopwatch is not always synced properly.\nA difference of 0.1s or 0.2s too high may occur when counting. When binding to an Audio Player however, the timer\nwill sync properly and show the correct duration of the loaded audio file.",
    "interface": false
  },
  {
    "__docId__": 633,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/audio/tools.js~Stopwatch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 29,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "tickCb",
        "description": "The callback that is invoked on every tick (every 100ms)."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If tickCb is missing."
      }
    ]
  },
  {
    "__docId__": 634,
    "kind": "member",
    "name": "_interval",
    "memberof": "src/audio/tools.js~Stopwatch",
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#_interval",
    "access": "private",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 635,
    "kind": "member",
    "name": "_value",
    "memberof": "src/audio/tools.js~Stopwatch",
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#_value",
    "access": "private",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 636,
    "kind": "member",
    "name": "_tickCb",
    "memberof": "src/audio/tools.js~Stopwatch",
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#_tickCb",
    "access": "private",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 637,
    "kind": "member",
    "name": "_emitter",
    "memberof": "src/audio/tools.js~Stopwatch",
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#_emitter",
    "access": "private",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 638,
    "kind": "method",
    "name": "start",
    "memberof": "src/audio/tools.js~Stopwatch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#start",
    "access": "public",
    "description": "Start counting and tick every 100 ms.",
    "lineNumber": 42,
    "params": [],
    "return": null
  },
  {
    "__docId__": 640,
    "kind": "method",
    "name": "stop",
    "memberof": "src/audio/tools.js~Stopwatch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#stop",
    "access": "public",
    "description": "Stop counting.",
    "lineNumber": 54,
    "params": [],
    "return": null
  },
  {
    "__docId__": 642,
    "kind": "method",
    "name": "reset",
    "memberof": "src/audio/tools.js~Stopwatch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#reset",
    "access": "public",
    "description": "Reset count to 0.",
    "lineNumber": 64,
    "params": [],
    "return": null
  },
  {
    "__docId__": 644,
    "kind": "method",
    "name": "update",
    "memberof": "src/audio/tools.js~Stopwatch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#update",
    "access": "public",
    "description": "Tick once and increment the value by 1.",
    "lineNumber": 73,
    "params": [],
    "return": null
  },
  {
    "__docId__": 645,
    "kind": "method",
    "name": "tick",
    "memberof": "src/audio/tools.js~Stopwatch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#tick",
    "access": "public",
    "description": "Invoke the tick callback with the current value.",
    "lineNumber": 81,
    "params": [],
    "return": null
  },
  {
    "__docId__": 646,
    "kind": "method",
    "name": "registerListener",
    "memberof": "src/audio/tools.js~Stopwatch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#registerListener",
    "access": "public",
    "description": null,
    "lineNumber": 86,
    "undocument": true,
    "params": [
      {
        "name": "tickCb",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 647,
    "kind": "method",
    "name": "stopListening",
    "memberof": "src/audio/tools.js~Stopwatch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#stopListening",
    "access": "public",
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "params": [
      {
        "name": "tickCb",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 648,
    "kind": "file",
    "name": "src/audio/wave-packer.js",
    "content": "/**\n * Packer class for audio packing\n *\n * @private\n */\nexport default class WavePacker {\n  /**\n   * Stop recording audio.\n   *\n   * @param {number} recordingSampleRate - Sample rate of recording. Must be either 48000 or 44100.\n   * @param {number} sampleRate - Sample rate. Must be half or a quarter of the recording sample rate.\n   * @param {number} channels - Amount of audio channels. 1 or 2.\n   */\n  init(recordingSampleRate, sampleRate, channels) {\n    this.recordingSampleRate = recordingSampleRate;\n    if ([48000, 44100].indexOf(this.recordingSampleRate) === -1) {\n      throw new Error(\n        '48000 or 44100 are the only supported recordingSampleRates');\n    }\n\n    this.sampleRate = sampleRate;\n    if ([\n      this.recordingSampleRate,\n      this.recordingSampleRate / 2,\n      this.recordingSampleRate / 4\n    ].indexOf(this.sampleRate) === -1) {\n      throw new Error(\n        'sampleRate must be equal, half or a quarter of the ' +\n        'recording sample rate');\n    }\n\n    this.channels = channels;\n    this.recording = false;\n  }\n\n  clear() {\n    this.recLength = 0;\n    this.recBuffersL = [];\n    this.recBuffersR = [];\n  }\n\n  record(left, right) {\n    this.recBuffersL.push(left);\n    this.recBuffersR.push(right);\n    this.recLength += left.length;\n  }\n\n  recordStreaming(left, right, callback) {\n    function convertFloat32ToInt16(buffer) {\n      let l = buffer.length;\n      const buf = new Int16Array(l);\n      while (l--) {\n        buf[l] = Math.min(1, buffer[l]) * 0x7FFF;\n      }\n      return buf.buffer;\n    }\n    // Both the left and right channel's data is a view (Float32Array)\n    // on top of the buffer (ArrayBuffer). Each buffer's element should\n    // have _value between -1 and 1.\n    // The audio to export are 16 bit PCM samples that are wrapped in\n    // a WAVE file at the server. Therefore convert from float here.\n    const converted = convertFloat32ToInt16(left);\n    callback(converted);\n  }\n\n  exportWAV(callback) {\n    const bufferL = WavePacker.mergeBuffers(this.recBuffersL, this.recLength);\n    const bufferR = WavePacker.mergeBuffers(this.recBuffersR, this.recLength);\n    const interleaved = this.interleave(bufferL, bufferR);\n    const dataview = this.encodeWAV(interleaved);\n    const audioBlob = new Blob([dataview], {\n      type: 'audio/wav'\n    });\n    callback(audioBlob);\n  }\n\n\n  exportMonoWAV(callback) {\n    const bufferL = WavePacker.mergeBuffers(this.recBuffersL, this.recLength);\n    const dataview = this.encodeWAV(bufferL, true);\n    const audioBlob = new Blob([dataview], {\n      type: 'audio/wav'\n    });\n    callback(audioBlob);\n  }\n\n  /**\n   * Wrap the raw audio in a header to make it a WAVE format.\n   *\n   * Specs: {@link https://ccrma.stanford.edu/courses/422/projects/WaveFormat/}.\n   *\n   * @todo: This function should use the {@link createWAVEHeader} function for creating the header.\n   * @param {[]} interleaved - Array of interleaved audio.\n   */\n  encodeWAV(interleaved) {\n    const buffer = new ArrayBuffer(44 + interleaved.length * 2);\n    const view = new DataView(buffer);\n\n    // RIFF chunk descriptor\n    WavePacker.writeUTFBytes(view, 0, 'RIFF');\n    // file length\n    view.setUint32(4, 44 + interleaved.length * 2, true);\n    // RIFF type\n    WavePacker.writeUTFBytes(view, 8, 'WAVE');\n    // FMT sub-chunk\n    WavePacker.writeUTFBytes(view, 12, 'fmt ');\n    // format chunk length\n    view.setUint32(16, 16, true);\n    // sample format (raw)\n    view.setUint16(20, 1, true);\n    // channel count. mono=1, stereo=2\n    view.setUint16(22, this.channels, true);\n    // sample rate\n    view.setUint32(24, this.sampleRate, true);\n    // byte rate (sample rate * block align)\n    view.setUint32(28, this.sampleRate * 2 * this.channels, true);\n    // block align (channel count * bytes per sample)\n    view.setUint16(32, this.channels * 2, true);\n    // bits per sample\n    view.setUint16(34, 16, true);\n    // data sub-chunk\n    WavePacker.writeUTFBytes(view, 36, 'data');\n    view.setUint32(40, interleaved.length * 2, true);\n\n    // write the PCM samples\n    const lng = interleaved.length;\n    let index = 44;\n    const volume = 1;\n    for (let i = 0; i < lng; i++) {\n      view.setInt16(index, interleaved[i] * (0x7FFF * volume), true);\n      index += 2;\n    }\n\n    // Wrap in HTML5 Blob for transport\n    const blob = new Blob([view], {\n      type: 'audio/wav'\n    });\n    console.log('Recorded audio/wav Blob size: ' + blob.size);\n    return blob;\n  }\n\n  interleave(leftChannel, rightChannel) {\n    let result = null;\n    let length = null;\n    let i = null;\n    let inputIndex = null;\n    if (this.channels === 1) {\n      // Keep both right and left input channels, but \"pan\" them both\n      // in the center (to the single mono channel)\n      length = leftChannel.length;\n      result = new Float32Array(length);\n      for (i = 0; i < leftChannel.length; ++i) {\n        result[i] = 0.5 * (leftChannel[i] + rightChannel[i]);\n      }\n    } else {\n      length = leftChannel.length + rightChannel.length;\n      result = new Float32Array(length);\n\n      inputIndex = 0;\n      for (i = 0; i < length;) {\n        result[i++] = leftChannel[inputIndex];\n        result[i++] = rightChannel[inputIndex];\n        inputIndex++;\n      }\n    }\n\n    // Also downsample if needed.\n    if (this.recordingSampleRate !== this.sampleRate) {\n      // E.g. 44100/11025 = 4\n      const reduceBy = this.recordingSampleRate / this.sampleRate;\n      const resampledResult = new Float32Array(length / reduceBy);\n\n      inputIndex = 0;\n      for (i = 0; i < length;) {\n        let value = 0;\n        for (let j = 0; j < reduceBy; j++) {\n          value += result[inputIndex++];\n        }\n        resampledResult[i++] = 1 / reduceBy * value;\n      }\n      return resampledResult;\n    }\n    return result;\n  }\n\n  static mergeBuffers(channelBuffer, recordingLength) {\n    const result = new Float32Array(recordingLength);\n    let offset = 0;\n    const lng = channelBuffer.length;\n    for (let i = 0; i < lng; i++) {\n      const buffer = channelBuffer[i];\n      result.set(buffer, offset);\n      offset += buffer.length;\n    }\n    return result;\n  }\n\n  /**\n   * Deprecated function, will be removed in favor of the pure\n   * {@link wordToUTF8ByteArray} function.\n   *\n   * @deprecated\n   * @param {DataView} view - DataView to write the bytes to.\n   * @param {number} offset - Position in the DataView to start writing from.\n   * @param {string} string - String to write to the DataView.\n   * @returns {void} - Nothing will be returned.\n   */\n  static writeUTFBytes(view, offset, string) {\n    const lng = string.length;\n    for (let i = 0; i < lng; i++) {\n      view.setUint8(offset + i, string.charCodeAt(i));\n    }\n  }\n}\n\n/**\n * Composes a PCM WAVE file header.\n * This header will lack any size information, so in effect\n * timing information will most probably be incorrect.\n *\n * More information on the WAVE file specification can be found below.\n * For the SDK and our backend services we use the WAVE PCM format.\n *\n * @see http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html\n * @param {number} channels - Channels in the audio.\n * @param {number} sampleRate - SampleRate of the audio.\n * @returns {ArrayBuffer} - The header as ArrayBuffer.\n */\nexport function createWAVEHeader(channels, sampleRate) {\n  // Default WAVE header length is 44 bytes long.\n  const buffer = new ArrayBuffer(44);\n  const header = new DataView(buffer);\n\n  // Set RIFF chunk descriptor\n  wordToUTF8ByteArray('RIFF').forEach((ui8Int, index) => {\n    header.setUint8(index, ui8Int);\n  });\n\n  // Set RIFF type\n  wordToUTF8ByteArray('WAVE').forEach((ui8Int, index) => {\n    header.setUint8(index + 8, ui8Int);\n  });\n\n  // Set FMT sub-chunk\n  wordToUTF8ByteArray('fmt ').forEach((ui8Int, index) => {\n    header.setUint8(index + 12, ui8Int);\n  });\n\n  // Set format chunk length\n  header.setUint32(16, 16, true);\n\n  // Set sample format (raw)\n  header.setUint16(20, 1, true);\n\n  // Set channel count. mono=1, stereo=2\n  header.setUint16(22, channels, true);\n\n  // Set sample rate\n  header.setUint32(24, sampleRate, true);\n\n  // Set byte rate (sample rate * block align)\n  header.setUint32(28, sampleRate * 2 * channels, true);\n\n  // Set block align (channel count * bytes per sample)\n  header.setUint16(32, channels * 2, true);\n\n  // Set bits per sample\n  header.setUint16(34, 16, true);\n\n  // Set data sub-chunk\n  wordToUTF8ByteArray('data').forEach((ui8Int, index) => {\n    header.setUint8(index + 36, ui8Int);\n  });\n\n  // Return the ArrayBuffer of the header.\n  return header.buffer;\n}\n\n/**\n * Get an TypedArray (an Uint8Array to be more precise) that\n * represents a string.\n *\n * @param {string} word - The word to convert.\n * @returns {Uint8Array} - The converted word as Uint8Array.\n */\nexport function wordToUTF8ByteArray(word) {\n  const buffer = new ArrayBuffer(word.length);\n  const bufferView = new Uint8Array(buffer);\n  bufferView.map((item, index, array) => {\n    array[index] = word.charCodeAt(index);\n  });\n  return bufferView;\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/audio/wave-packer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 649,
    "kind": "class",
    "name": "WavePacker",
    "memberof": "src/audio/wave-packer.js",
    "static": true,
    "longname": "src/audio/wave-packer.js~WavePacker",
    "access": "private",
    "export": true,
    "importPath": "itslanguage/audio/wave-packer.js",
    "importStyle": "WavePacker",
    "description": "Packer class for audio packing",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 650,
    "kind": "method",
    "name": "init",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#init",
    "access": "public",
    "description": "Stop recording audio.",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "recordingSampleRate",
        "description": "Sample rate of recording. Must be either 48000 or 44100."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "sampleRate",
        "description": "Sample rate. Must be half or a quarter of the recording sample rate."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "channels",
        "description": "Amount of audio channels. 1 or 2."
      }
    ],
    "return": null
  },
  {
    "__docId__": 651,
    "kind": "member",
    "name": "recordingSampleRate",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#recordingSampleRate",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 652,
    "kind": "member",
    "name": "sampleRate",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#sampleRate",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 653,
    "kind": "member",
    "name": "channels",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#channels",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 654,
    "kind": "member",
    "name": "recording",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#recording",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 655,
    "kind": "method",
    "name": "clear",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#clear",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 656,
    "kind": "member",
    "name": "recLength",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#recLength",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 657,
    "kind": "member",
    "name": "recBuffersL",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#recBuffersL",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 658,
    "kind": "member",
    "name": "recBuffersR",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#recBuffersR",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 659,
    "kind": "method",
    "name": "record",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#record",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "params": [
      {
        "name": "left",
        "types": [
          "*"
        ]
      },
      {
        "name": "right",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 661,
    "kind": "method",
    "name": "recordStreaming",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#recordStreaming",
    "access": "public",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "params": [
      {
        "name": "left",
        "types": [
          "*"
        ]
      },
      {
        "name": "right",
        "types": [
          "*"
        ]
      },
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 662,
    "kind": "method",
    "name": "exportWAV",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#exportWAV",
    "access": "public",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "params": [
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 663,
    "kind": "method",
    "name": "exportMonoWAV",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#exportMonoWAV",
    "access": "public",
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "params": [
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 664,
    "kind": "method",
    "name": "encodeWAV",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#encodeWAV",
    "access": "public",
    "description": "Wrap the raw audio in a header to make it a WAVE format.\n\nSpecs: {@link https://ccrma.stanford.edu/courses/422/projects/WaveFormat/}.\n\n@todo: This function should use the {@link createWAVEHeader} function for creating the header.",
    "lineNumber": 95,
    "params": [
      {
        "nullable": null,
        "types": [
          "[]"
        ],
        "spread": false,
        "optional": false,
        "name": "interleaved",
        "description": "Array of interleaved audio."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 665,
    "kind": "method",
    "name": "interleave",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#interleave",
    "access": "public",
    "description": null,
    "lineNumber": 142,
    "undocument": true,
    "params": [
      {
        "name": "leftChannel",
        "types": [
          "*"
        ]
      },
      {
        "name": "rightChannel",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 666,
    "kind": "method",
    "name": "mergeBuffers",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/audio/wave-packer.js~WavePacker.mergeBuffers",
    "access": "public",
    "description": null,
    "lineNumber": 186,
    "undocument": true,
    "params": [
      {
        "name": "channelBuffer",
        "types": [
          "*"
        ]
      },
      {
        "name": "recordingLength",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 667,
    "kind": "method",
    "name": "writeUTFBytes",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/audio/wave-packer.js~WavePacker.writeUTFBytes",
    "access": "public",
    "description": "Deprecated function, will be removed in favor of the pure\n{@link wordToUTF8ByteArray} function.",
    "lineNumber": 208,
    "deprecated": true,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{void} - Nothing will be returned."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "DataView"
        ],
        "spread": false,
        "optional": false,
        "name": "view",
        "description": "DataView to write the bytes to."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "Position in the DataView to start writing from."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "string",
        "description": "String to write to the DataView."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "void"
      ],
      "spread": false,
      "description": "Nothing will be returned."
    }
  },
  {
    "__docId__": 668,
    "kind": "function",
    "name": "createWAVEHeader",
    "memberof": "src/audio/wave-packer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/audio/wave-packer.js~createWAVEHeader",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/audio/wave-packer.js",
    "importStyle": "{createWAVEHeader}",
    "description": "Composes a PCM WAVE file header.\nThis header will lack any size information, so in effect\ntiming information will most probably be incorrect.\n\nMore information on the WAVE file specification can be found below.\nFor the SDK and our backend services we use the WAVE PCM format.",
    "see": [
      "http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html"
    ],
    "lineNumber": 229,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ArrayBuffer} - The header as ArrayBuffer."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "channels",
        "description": "Channels in the audio."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "sampleRate",
        "description": "SampleRate of the audio."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ArrayBuffer"
      ],
      "spread": false,
      "description": "The header as ArrayBuffer."
    }
  },
  {
    "__docId__": 669,
    "kind": "function",
    "name": "wordToUTF8ByteArray",
    "memberof": "src/audio/wave-packer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/audio/wave-packer.js~wordToUTF8ByteArray",
    "access": "public",
    "export": true,
    "importPath": "itslanguage/audio/wave-packer.js",
    "importStyle": "{wordToUTF8ByteArray}",
    "description": "Get an TypedArray (an Uint8Array to be more precise) that\nrepresents a string.",
    "lineNumber": 286,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Uint8Array} - The converted word as Uint8Array."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "word",
        "description": "The word to convert."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": "The converted word as Uint8Array."
    }
  },
  {
    "__docId__": 670,
    "kind": "file",
    "name": "src/audio/web-audio-player.js",
    "content": "/**\n * @title ITSLanguage Javascript Audio\n * @overview This is part of the ITSLanguage Javascript SDK to perform audio related functions.\n * @copyright (c) 2014 ITSLanguage\n * @license MIT\n * @author d-centralize\n *\n * This class fires the same events as the HTML5 Audio does. {@link http://www.w3schools.com/tags/ref_av_dom.asp}\n * @private\n */\n\nexport default class WebAudioPlayer {\n  /**\n   * ITSLanguage WebAudioPlayer non-graphical component.\n   *\n   * This player uses the HTML5 Audio component for playback.\n   *\n   * @param {?Object} options - Override any of the default settings.\n   */\n  constructor(options) {\n    this._settings = Object.assign({}, options);\n\n    this._initPlayer();\n  }\n\n  _initPlayer() {\n    this.sound = new window.Audio();\n    this._pauseIsStop = false;\n\n    // The its.AudioPlayer API is based upon the same API calls as the\n    // HTML5 Audio element itself, therefore, just bubble up all events.\n    const self = this;\n\n    this.sound.addEventListener('playing', () => {\n      if (self._settings.playingCb) {\n        self._settings.playingCb();\n      }\n    });\n\n    this.sound.addEventListener('timeupdate', () => {\n      if (self._settings.timeupdateCb) {\n        self._settings.timeupdateCb();\n      }\n    });\n\n    this.sound.addEventListener('durationchange', () => {\n      if (self._settings.durationchangeCb) {\n        self._settings.durationchangeCb();\n      }\n    });\n\n    this.sound.addEventListener('canplay', () => {\n      if (self._settings.canplayCb) {\n        self._settings.canplayCb();\n      }\n    });\n\n    this.sound.addEventListener('ended', () => {\n      if (self._settings.endedCb) {\n        self._settings.endedCb();\n      }\n    });\n\n    this.sound.addEventListener('pause', () => {\n      // The HTML5 audio player only has a pause(), no stop().\n      // To differentiate between the two, a flag is set in case the user\n      // explicitly stopped (not paused) the audio.\n      if (self._pauseIsStop === true) {\n        self._pauseIsStop = false;\n        if (self._settings.pauseCb) {\n          self._settings.pauseCb();\n        }\n      } else if (self._settings.stoppedCb) {\n        self._settings.stoppedCb();\n      }\n      if (self._settings.playbackStoppedCb) {\n        self._settings.playbackStoppedCb();\n      }\n    });\n\n    this.sound.addEventListener('progress', () => {\n      if (self._settings.progressCb) {\n        self._settings.progressCb();\n      }\n    });\n\n    this.sound.addEventListener('error', e => {\n      switch (e.target.error.code) {\n        case e.target.error.MEDIA_ERR_ABORTED:\n          console.error('You aborted the playback.');\n          break;\n        case e.target.error.MEDIA_ERR_NETWORK:\n          console.error(\n            'A network error caused the audio download to fail.');\n          break;\n        case e.target.error.MEDIA_ERR_DECODE:\n          console.error(\n            'The audio playback was aborted due to a corruption ' +\n          'problem or because the media used features your ' +\n          'browser did not support.');\n          break;\n        case e.target.error.MEDIA_ERR_SRC_NOT_SUPPORTED:\n          console.error(\n            'The audio could not be loaded, either because the ' +\n          'server or network failed or because the format is ' +\n          'not supported.');\n          break;\n        default:\n          console.error('An unknown error occurred.');\n          break;\n      }\n      if (self._settings.errorCb) {\n        self._settings.errorCb();\n      }\n    });\n  }\n\n\n  /**\n   * Preload audio from an URL.\n   *\n   * @param {string} url - The URL that contains the audio.\n   * @param {boolean} [preload=true] - Try preloading metadata and possible some audio (default).\n   * Set to false to not download anything until playing.\n   * @param {?Function} loadedCb - The callback that is invoked when the duration of the audio file\n   * is first known.\n   */\n  load(url, preload, loadedCb) {\n    preload = preload === undefined ? true : preload;\n\n    // Automatically begin buffering the file, even if autoplay is off.\n    this.sound.autobuffer = Boolean(preload);\n\n    // Preloading options:\n    // none - Do not preload any media.\n    // Wait for a play event before downloading anything.\n    // metadata - Preload just the metadata. Grab the start and the end of\n    // the file via range-request and determine the duration.\n    // auto - Preload the whole file. Grab the start and the end of the\n    // file to determine duration, then seek back to the start\n    // again for the preload proper.\n    this.sound.preload = preload ? 'auto' : 'none';\n\n    const self = this;\n    if (loadedCb) {\n      this.sound.addEventListener('durationchange', () => {\n        console.log('Duration change for ' + url + ' to : ' +\n          self.sound.duration);\n        loadedCb(self.sound);\n      });\n    }\n\n    this.sound.src = url;\n  }\n\n\n  /**\n   * Start or continue playback of audio.\n   *\n   * @param {?number} position - When position is given, start playing from this position (seconds).\n   */\n  play(position) {\n    if (position !== undefined) {\n      if (this.sound.readyState < this.sound.HAVE_METADATA) {\n        // In case the audio wasn't already preloaded, do it now.\n        this.sound.preload = 'auto';\n        console.warn('Playing from a given position is not possible. ' +\n          'Audio was not yet loaded. Try again.');\n      } else {\n        console.debug('Scrub position to: ' + position);\n        this.sound.currentTime = position;\n      }\n    }\n    this.sound.play();\n    console.debug('Start playing from position: ' + this.sound.currentTime);\n  }\n\n  /**\n   * Unload previously loaded audio.\n   */\n  reset() {\n    this._initPlayer();\n  }\n\n  /**\n   * Stop playback of audio.\n   */\n  stop() {\n    // The HTML5 audio player only has a pause(), no stop().\n    // To differentiate between the two, set a flag.\n    this.sound.pause();\n    this.sound.currentTime = 0;\n  }\n\n  /**\n   * Pause playback of audio.\n   */\n  pause() {\n    this._pauseIsStop = true;\n    this.sound.pause();\n  }\n\n  /**\n   * Start preloading audio.\n   */\n  preload() {\n    // In case the audio wasn't already preloaded, do it now.\n    if (this.sound.preload !== 'auto') {\n      console.info('Start preloading audio.');\n      this.sound.preload = 'auto';\n    }\n  }\n\n\n  /**\n   * Start playing audio at the given offset.\n   *\n   * @param {number} percentage - Start at this percentage (0..100) of the audio stream.\n   */\n  scrub(percentage) {\n    // In case the audio wasn't already preloaded, do it now.\n    if (this.sound.readyState < this.sound.HAVE_METADATA) {\n      this.preload();\n      console.warn('Scrubbing not possible. Audio was not yet loaded. ' +\n        'Try again.');\n      return;\n    }\n\n    const newTime = this.sound.duration / 100 * percentage;\n    console.log('Moving audio position to: ' + percentage + '%: ' +\n      newTime + 's of total playing time: ' + this.sound.duration);\n    this.sound.currentTime = newTime;\n  }\n\n  /**\n   * Returns the percentage of which the buffer is filled.\n   *\n   * @returns {number} Percentage of buffer fill.\n   */\n  getBufferFill() {\n    if (this.sound.buffered === undefined ||\n      this.sound.buffered.length === 0) {\n      // Nothing buffered yet.\n      return 0;\n    }\n\n    // The fact that there's not one buffer segment is ignored here.\n    // Truely representing the buffered state requires multiple\n    // loading bars.\n    // Usually, when user didn't seek yet, there are two segments:\n    // Got segment from: 0 to: 187.63999938964844\n    // Got segment from: 222.44700622558594 to: 228.1140899658203\n    // The latter is gained when the HTML5 audio component tries to find\n    // the total audio duration.\n    // More info:\n    // http://html5doctor.com/html5-audio-the-state-of-play/#time-ranges\n    let probableEnd = 0;\n    for (let i = 0; i < this.sound.buffered.length; i++) {\n      const start = this.sound.buffered.start(i);\n      const end = this.sound.buffered.end(i);\n      // console.log('Got segment from: ' + start + ' to: ' + end);\n      // Often, the segment that starts from 0 keeps growing and\n      // indicates -most likely- the biggest buffer.\n      if (start === 0) {\n        probableEnd = end;\n      }\n    }\n\n    // Round up,so the buffer won't get stuck on 99% when\n    // duration and buffer are equal, except for some far decimal.\n    const loaded = Math.round(probableEnd * 100 / this.sound.duration);\n    console.log('Buffer filled to ' + loaded + '%');\n    return loaded;\n  }\n\n  /**\n   * Returns the current playing time as offset in seconds from the start.\n   *\n   * @returns {number} Time in seconds as offset from the start.\n   */\n  getCurrentTime() {\n    return this.sound.currentTime;\n  }\n\n  /**\n   * Returns the total duration in seconds.\n   *\n   * @returns {number} Time in seconds of fragment duration. 0 if no audio is loaded.\n   */\n  getDuration() {\n    let duration = this.sound.duration;\n    // When no audio is loaded, the duration may be NaN\n    if (!duration) {\n      duration = 0;\n    }\n    return duration;\n  }\n\n  /**\n   * Returns state of the player.\n   *\n   * @returns {boolean} True when player is currently playing. False when paused or stopped.\n   */\n  isPlaying() {\n    return !this.sound.paused;\n  }\n\n  setPlaybackRate(rate) {\n    this.sound.playbackRate = rate;\n  }\n\n  getPlaybackRate() {\n    return this.sound.playbackRate;\n  }\n\n  /**\n   * Returns ready state of the player.\n   *\n   * @returns {boolean} True when player is ready to start loading data or play. False when no audio is loaded\n   * or preparing.\n   */\n  canPlay() {\n    // Either the player is in a valid readyState (preloaded), or\n    // the player has a source attached and doesn't show any loading error (non-preloaded).\n    return this.sound.readyState >= this.sound.HAVE_METADATA ||\n      this.sound.src && !this.sound.error;\n  }\n\n  setAudioVolume(volume) {\n    this.sound.volume = volume;\n  }\n\n  getAudioVolume() {\n    return this.sound.volume;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/audio/web-audio-player.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 671,
    "kind": "class",
    "name": "WebAudioPlayer",
    "memberof": "src/audio/web-audio-player.js",
    "static": true,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer",
    "access": "private",
    "export": true,
    "importPath": "itslanguage/audio/web-audio-player.js",
    "importStyle": "WebAudioPlayer",
    "description": "",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@title",
        "tagValue": "ITSLanguage Javascript Audio"
      },
      {
        "tagName": "@overview",
        "tagValue": "This is part of the ITSLanguage Javascript SDK to perform audio related functions."
      },
      {
        "tagName": "@copyright",
        "tagValue": "(c) 2014 ITSLanguage"
      },
      {
        "tagName": "@license",
        "tagValue": "MIT"
      },
      {
        "tagName": "@author",
        "tagValue": "d-centralize\n\nThis class fires the same events as the HTML5 Audio does. {@link http://www.w3schools.com/tags/ref_av_dom.asp}"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 672,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#constructor",
    "access": "public",
    "description": "ITSLanguage WebAudioPlayer non-graphical component.\n\nThis player uses the HTML5 Audio component for playback.",
    "lineNumber": 20,
    "params": [
      {
        "nullable": true,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Override any of the default settings."
      }
    ]
  },
  {
    "__docId__": 673,
    "kind": "member",
    "name": "_settings",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#_settings",
    "access": "private",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 674,
    "kind": "method",
    "name": "_initPlayer",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#_initPlayer",
    "access": "private",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 675,
    "kind": "member",
    "name": "sound",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#sound",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 676,
    "kind": "member",
    "name": "_pauseIsStop",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#_pauseIsStop",
    "access": "private",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 677,
    "kind": "method",
    "name": "load",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#load",
    "access": "public",
    "description": "Preload audio from an URL.",
    "lineNumber": 128,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "The URL that contains the audio."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "preload",
        "description": "Try preloading metadata and possible some audio (default).\nSet to false to not download anything until playing."
      },
      {
        "nullable": true,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "loadedCb",
        "description": "The callback that is invoked when the duration of the audio file\nis first known."
      }
    ],
    "return": null
  },
  {
    "__docId__": 678,
    "kind": "method",
    "name": "play",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#play",
    "access": "public",
    "description": "Start or continue playback of audio.",
    "lineNumber": 162,
    "params": [
      {
        "nullable": true,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "position",
        "description": "When position is given, start playing from this position (seconds)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 679,
    "kind": "method",
    "name": "reset",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#reset",
    "access": "public",
    "description": "Unload previously loaded audio.",
    "lineNumber": 181,
    "params": [],
    "return": null
  },
  {
    "__docId__": 680,
    "kind": "method",
    "name": "stop",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#stop",
    "access": "public",
    "description": "Stop playback of audio.",
    "lineNumber": 188,
    "params": [],
    "return": null
  },
  {
    "__docId__": 681,
    "kind": "method",
    "name": "pause",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#pause",
    "access": "public",
    "description": "Pause playback of audio.",
    "lineNumber": 198,
    "params": [],
    "return": null
  },
  {
    "__docId__": 683,
    "kind": "method",
    "name": "preload",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#preload",
    "access": "public",
    "description": "Start preloading audio.",
    "lineNumber": 206,
    "params": [],
    "return": null
  },
  {
    "__docId__": 684,
    "kind": "method",
    "name": "scrub",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#scrub",
    "access": "public",
    "description": "Start playing audio at the given offset.",
    "lineNumber": 220,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "percentage",
        "description": "Start at this percentage (0..100) of the audio stream."
      }
    ],
    "return": null
  },
  {
    "__docId__": 685,
    "kind": "method",
    "name": "getBufferFill",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#getBufferFill",
    "access": "public",
    "description": "Returns the percentage of which the buffer is filled.",
    "lineNumber": 240,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Percentage of buffer fill."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Percentage of buffer fill."
    },
    "params": []
  },
  {
    "__docId__": 686,
    "kind": "method",
    "name": "getCurrentTime",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#getCurrentTime",
    "access": "public",
    "description": "Returns the current playing time as offset in seconds from the start.",
    "lineNumber": 281,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Time in seconds as offset from the start."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Time in seconds as offset from the start."
    },
    "params": []
  },
  {
    "__docId__": 687,
    "kind": "method",
    "name": "getDuration",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#getDuration",
    "access": "public",
    "description": "Returns the total duration in seconds.",
    "lineNumber": 290,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Time in seconds of fragment duration. 0 if no audio is loaded."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Time in seconds of fragment duration. 0 if no audio is loaded."
    },
    "params": []
  },
  {
    "__docId__": 688,
    "kind": "method",
    "name": "isPlaying",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#isPlaying",
    "access": "public",
    "description": "Returns state of the player.",
    "lineNumber": 304,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True when player is currently playing. False when paused or stopped."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True when player is currently playing. False when paused or stopped."
    },
    "params": []
  },
  {
    "__docId__": 689,
    "kind": "method",
    "name": "setPlaybackRate",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#setPlaybackRate",
    "access": "public",
    "description": null,
    "lineNumber": 308,
    "undocument": true,
    "params": [
      {
        "name": "rate",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 690,
    "kind": "method",
    "name": "getPlaybackRate",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#getPlaybackRate",
    "access": "public",
    "description": null,
    "lineNumber": 312,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 691,
    "kind": "method",
    "name": "canPlay",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#canPlay",
    "access": "public",
    "description": "Returns ready state of the player.",
    "lineNumber": 322,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True when player is ready to start loading data or play. False when no audio is loaded\nor preparing."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True when player is ready to start loading data or play. False when no audio is loaded\nor preparing."
    },
    "params": []
  },
  {
    "__docId__": 692,
    "kind": "method",
    "name": "setAudioVolume",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#setAudioVolume",
    "access": "public",
    "description": null,
    "lineNumber": 329,
    "undocument": true,
    "params": [
      {
        "name": "volume",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 693,
    "kind": "method",
    "name": "getAudioVolume",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#getAudioVolume",
    "access": "public",
    "description": null,
    "lineNumber": 333,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 694,
    "kind": "file",
    "name": "src/audio/web-audio-recorder.js",
    "content": "/**\n * WebAudioRecorder.\n * @private\n */\nexport default class WebAudioRecorder {\n  /**\n   * Use 'low level' processing tooling to record audio and get a Wave\n   * (audio/wav) encoded recording.\n   *\n   * Currently supported in all modern HTML5/WebAudio browsers.\n   *\n   * @param {GainNode} source - The source to record.\n   * @param {AudioContext} ctx - The AudioContext to use.\n   * @param {?Function} streamingCallback - The callback to deliver audio chunks to.\n   * @param {WavePacker} packer - Packer to use.\n   */\n  constructor(source, ctx, streamingCallback, packer) {\n    this.recording = false;\n\n    const context = ctx;\n    // For the best quality, use the samplerate in which audio is recorded.\n    this.recordedSampleRate = context.sampleRate;\n    // var sampleRate = recordedSampleRate;\n    // 48000hz -> 24000hz recording, 44100hz -> 22050hz recording.\n    // Sheffield determined the minimum to be 16000hz, so /4 is too low.\n    this.sampleRate = this.recordedSampleRate / 2;\n    // Streaming doesn't yet downsample: #1302.\n    this.sampleRate = streamingCallback ? this.recordedSampleRate :\n      this.sampleRate;\n\n    // Always record audio in mono.\n    this.channels = 1;\n    console.log('Recording at: ' +\n                  this.getAudioSpecs().audioParameters.sampleRate);\n\n    this.packer = packer;\n    this.packer.init(this.recordedSampleRate, this.sampleRate, this.channels);\n\n    // From the spec: This value controls how frequently the audioprocess\n    // event is dispatched and how many sample-frames need to be processed\n    // each call. Lower values for buffer size will result in a lower\n    // (better) latency. Higher values will be necessary to avoid audio\n    // breakup and glitches.\n    // Legal values are (256, 512, 1024, 2048, 4096, 8192, 16384).\n    const bufferSize = 8192;\n    const recorder = context.createScriptProcessor(bufferSize, 2, 2);\n    // Keep a reference to the scriptProcessor.\n    // This is a workaround for a bug in Chrome that would otherwise lead to\n    // the recorder being garbage collected before it even recorded anything.\n    // https://bugs.webkit.org/show_bug.cgi?id=112521\n    this._recorder = recorder;\n\n    const self = this;\n    recorder.onaudioprocess = function(audioProcessing) {\n      if (!self.recording) {\n        return;\n      }\n      const left = audioProcessing.inputBuffer.getChannelData(0);\n      const right = audioProcessing.inputBuffer.getChannelData(1);\n      // These returned channel buffers are pointers to the current samples\n      // coming in. Make a snapshot (clone). The webworkers can't serialize\n      // the pointers. Well, Chrome and FF could, but Edge can't.\n      const leftClone = new Float32Array(left);\n      const rightClone = new Float32Array(right);\n      self.packer.record(leftClone, rightClone);\n      if (streamingCallback) {\n        self.packer.recordStreaming(leftClone, rightClone, streamingCallback);\n      }\n    };\n\n    source.connect(recorder);\n    // If the script node is not connected to an output the \"onaudioprocess\"\n    // event is not triggered in chrome.\n    recorder.connect(context.destination);\n  }\n\n  /**\n   * Get the recorded audio specifications.\n   *\n   * @returns {Object} Containing metadata on the audio format.\n   */\n  getAudioSpecs() {\n    return {\n      audioFormat: 'audio/wave',\n      audioParameters: {\n        channels: this.channels,\n        sampleWidth: 16,\n        frameRate: this.sampleRate,\n        sampleRate: this.sampleRate\n      }\n    };\n  }\n\n  /**\n   * Start recording audio.\n   *\n   */\n  record() {\n    this.packer.clear();\n    this.recording = true;\n  }\n\n  /**\n   * Request encoded audio to be returned through callback.\n   *\n   * @param {Function} callback - The callback to use when returning the audio as a blob in Wave format.\n   */\n  getEncodedAudio(callback) {\n    this.packer.exportWAV(callback);\n  }\n\n  /**\n   * Is audio recording in progress.\n   *\n   * @returns {boolean} True when recording. False otherwise.\n   */\n  isRecording() {\n    return this.recording;\n  }\n\n  /**\n   * Stop recording audio.\n   */\n  stop() {\n    this.recording = false;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/audio/web-audio-recorder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 695,
    "kind": "class",
    "name": "WebAudioRecorder",
    "memberof": "src/audio/web-audio-recorder.js",
    "static": true,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "access": "private",
    "export": true,
    "importPath": "itslanguage/audio/web-audio-recorder.js",
    "importStyle": "WebAudioRecorder",
    "description": "WebAudioRecorder.",
    "lineNumber": 5,
    "interface": false
  },
  {
    "__docId__": 696,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#constructor",
    "access": "public",
    "description": "Use 'low level' processing tooling to record audio and get a Wave\n(audio/wav) encoded recording.\n\nCurrently supported in all modern HTML5/WebAudio browsers.",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "GainNode"
        ],
        "spread": false,
        "optional": false,
        "name": "source",
        "description": "The source to record."
      },
      {
        "nullable": null,
        "types": [
          "AudioContext"
        ],
        "spread": false,
        "optional": false,
        "name": "ctx",
        "description": "The AudioContext to use."
      },
      {
        "nullable": true,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "streamingCallback",
        "description": "The callback to deliver audio chunks to."
      },
      {
        "nullable": null,
        "types": [
          "WavePacker"
        ],
        "spread": false,
        "optional": false,
        "name": "packer",
        "description": "Packer to use."
      }
    ]
  },
  {
    "__docId__": 697,
    "kind": "member",
    "name": "recording",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#recording",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 698,
    "kind": "member",
    "name": "recordedSampleRate",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#recordedSampleRate",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 699,
    "kind": "member",
    "name": "sampleRate",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#sampleRate",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 701,
    "kind": "member",
    "name": "channels",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#channels",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 702,
    "kind": "member",
    "name": "packer",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#packer",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 703,
    "kind": "member",
    "name": "_recorder",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#_recorder",
    "access": "private",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 704,
    "kind": "method",
    "name": "getAudioSpecs",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#getAudioSpecs",
    "access": "public",
    "description": "Get the recorded audio specifications.",
    "lineNumber": 82,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} Containing metadata on the audio format."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Containing metadata on the audio format."
    },
    "params": []
  },
  {
    "__docId__": 705,
    "kind": "method",
    "name": "record",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#record",
    "access": "public",
    "description": "Start recording audio.",
    "lineNumber": 98,
    "params": [],
    "return": null
  },
  {
    "__docId__": 707,
    "kind": "method",
    "name": "getEncodedAudio",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#getEncodedAudio",
    "access": "public",
    "description": "Request encoded audio to be returned through callback.",
    "lineNumber": 108,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback to use when returning the audio as a blob in Wave format."
      }
    ],
    "return": null
  },
  {
    "__docId__": 708,
    "kind": "method",
    "name": "isRecording",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#isRecording",
    "access": "public",
    "description": "Is audio recording in progress.",
    "lineNumber": 117,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True when recording. False otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True when recording. False otherwise."
    },
    "params": []
  },
  {
    "__docId__": 709,
    "kind": "method",
    "name": "stop",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#stop",
    "access": "public",
    "description": "Stop recording audio.",
    "lineNumber": 124,
    "params": [],
    "return": null
  },
  {
    "__docId__": 711,
    "kind": "file",
    "name": "src/index.js",
    "content": "import {default as VolumeMeter, generateWaveSample} from './audio/audio-tools';\nimport AdministrativeSDK from './administrative-sdk/administrative-sdk';\nimport AudioPlayer from './audio/audio-player';\nimport AudioRecorder from './audio/audio-recorder';\nimport BasicAuth from './administrative-sdk/basic-auth/basic-auth';\nimport Category from './administrative-sdk/category/category';\nimport ChoiceChallenge from './administrative-sdk/choice-challenge/choice-challenge';\nimport Connection from './administrative-sdk/connection/connection-controller';\nimport EmailCredentials from './administrative-sdk/email-credentials/email-credentials';\nimport Group from './administrative-sdk/group/group';\nimport Organisation from './administrative-sdk/organisation/organisation';\nimport Player from './WebAudio/Player';\nimport Profile from './administrative-sdk/profile/profile';\nimport Progress from './administrative-sdk/progress/progress';\nimport PronunciationChallenge from './administrative-sdk/pronunciation-challenge/pronunciation-challenge';\nimport Role from './administrative-sdk/role/role';\nimport SpeechChallenge from './administrative-sdk/speech-challenge/speech-challenge';\nimport Stopwatch from './audio/tools';\nimport User from './administrative-sdk/user/user';\n\nexport {\n  AdministrativeSDK,\n  BasicAuth,\n  Category,\n  ChoiceChallenge,\n  Connection,\n  EmailCredentials,\n  Group,\n  Organisation,\n  Profile,\n  Progress,\n  PronunciationChallenge,\n  Role,\n  SpeechChallenge,\n  User,\n\n  AudioPlayer,\n  AudioRecorder,\n\n  generateWaveSample,\n\n  Stopwatch,\n\n  VolumeMeter,\n\n  Player\n};\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "kind": "index",
    "content": "# ITSLanguage JavaScript SDK\n\n> Build JavaScript applications for the ITSLanguage platform.\n\n| branch | build status |\n| ------ | ------------ |\n| master | [![Build Status][master build logo]][travis] |\n| next   | [![Build Status][next build logo]][travis] |\n\n## Getting started\n\nAdding ITSLanguage into your JavaScript project is as easy as:\n\n```shell\nnpm install --save @itslanguage/sdk\n```\n\nThis will install the latest stable version of the SDK to your project. If you want to live on the\nedge you can also try and install our `@next` version. It's just as easy as installing the stable\nrelease, just add the `@next` tag to the install option:\n\n```shell\nnpm install --save @itslanguage/sdk@next\n```\n\n**note**: for existing users, the v3.0.0 release was a scoped release. This means that you can only\ninstall this version by also updating all references to ITSLangauge SDK. An `import { Player } from\n'itslanguage';` should be refactored to `import { Player } from '@itslanguage/sdk';`.\nThe reason for this change is fairly simple: we want our users to be sure they install our software\nand using scopes gives us the opportunity to say so. Only we can push new versions to this scope.\n\n**note**: if you're using npm >= 5 in your project you can omit the `--save` flag. That is assumed\nby default.\n\n**note**: the ITSLanguage SDK is build with using [yarn] in favor of NPM. For using the SDK in your\nown project this is not an requirement.\n\n**Warning**: this will install the ITSLanguage Javascript SDK as a beta package to your project.\nThings might not work as expected. For instance the SDK might require a specific backend version\nto be able to function with this version to work on. So make sure you now what you're doing when\ninstalling the next branch to your project. Breaking changes will occur.\n\n### Usage\n\nThe API docs are released with every version from v3.0.0 and onwards. On our GitHub pages we also\nhost the latest version available (current master status). For more information on how to use the\nSDK the docs are the best place to look. It is an esdoc generated website, which also shows how\none can import that is needed. To import the default audio player you can just do this in your\nproject:\n\n```js\n\nimport { Player } from '@itslanguage/sdk';\n\n```\n\nSo, for more usage and examples read our documentation on our github pages.\nFor the master version look at [the master GitHub pages website]. For our `@next` branch look at\nthe documentation that is included in the packages (the docs folder).\n\n### Dependencies\n\nThis SDK was build with the browser in mind. However any JavaScript project can use this SDK to\nbuild applications for the ITSLanguage platform. There are, however, a few things to keep in mind;\nmostly the dependencies. Our development on the SDK is based on browser usage. We don't extensively\ntest on other platforms. Do let us know if something is not working. And of course, we accept pull\nrequests!\n\nITSLanguage JavaScript SDK uses:\n\n1. [The `fetch` API][MDN fetch]\n1. [URLSearchParams][MDN URLSearchParams]\n1. [FormData][MDN FormData]\n1. [WebSocket][MDN WebSocket]\n\nIt is expected that these are accessible through their `global` accessors (i.e.\nby simply calling `new FormData()`, `fetch(...)`, etc.).\n\nModern browsers support these (at least to the capacity we use it). Older\nbrowsers as well as `Node` don't necessarily support these because the are, as\nof writing this, still seen as experimental (browser) features. They are living\nstandards and therefore expected to be implemented in the future.\n\nIn the mean time; you might want to look at a few libraries which will add\nthese APIs to your environment. Here are a few we found useful.\n\n#### Browsers\n\n1. [whatwg-fetch][NPM whatwg-fetch]\n1. [url-search-params-polyfill][NPM url-search-params-polyfill]\n\n#### Node\n\n1. [node-fetch][NPM node-fetch]\n1. [url-search-params][NPM url-search-params]\n1. [form-data][NPM form-data]\n\n#### Both\n\n1. [isomorphic-fetch][NPM isomorphic-fetch]\n\nWe appreciate any contribution to extend/update these lists. Feel free to contact us on our GitHub\npage or drop us a line at support@itslanguage.nl\n\n## The Next Branch\n\nOur `next` branch can be used to try out new features that are coming out in the near future.\nImportant to keep in mind is that this version possibly does not work on your ITSLanguage\nbackend environment due to breaking changes. If not sure, drop us a line to find out.\n\n### Current status of next branch\n\nThese are the items currently we are currently developing on for the `@next` dist-tag which is\navailable on npm.\n\n- Add support for streaming audio\n- Improve our CI/CD flow for better releases\n- Improve communication/authentication mechanism\n- Improve websocket communication mechanism\n- Improve safari support (macOS and iOS)\n\n[master build logo]: https://travis-ci.org/itslanguage/itslanguage-js.svg?branch=master\n[next build logo]: https://travis-ci.org/itslanguage/itslanguage-js.svg?branch=next\n[travis]: https://travis-ci.org/itslanguage/itslanguage-js\n\n[the master GitHub pages website]: https://itslanguage.github.io/itslanguage-js/master\n\n[yarn]: https://yarnpkg.com\n\n[MDN fetch]: https://developer.mozilla.org/en/docs/Web/API/Fetch_API\n[MDN URLSearchParams]: https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\n[MDN FormData]: https://developer.mozilla.org/en-US/docs/Web/API/FormData\n[MDN WebSocket]: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n\n[NPM isomorphic-fetch]: https://www.npmjs.com/package/isomorphic-fetch\n[NPM form-data]: https://www.npmjs.com/package/form-data\n[NPM node-fetch]: https://www.npmjs.com/package/node-fetch\n[NPM url-search-params]: https://www.npmjs.com/package/url-search-params\n[NPM whatwg-fetch]: https://www.npmjs.com/package/whatwg-fetch\n[NPM url-search-params-polyfill]: https://www.npmjs.com/package/url-search-params-polyfill\n",
    "longname": "/home/travis/build/itslanguage/itslanguage-js/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"itslanguage\",\n  \"private\": true,\n  \"version\": \"0.0.0\",\n  \"description\": \"The core JavaScript SDK for ITSLanguage.\",\n  \"main\": \"index.js\",\n  \"engines\": {\n    \"npm\": \">=5\",\n    \"node\": \">=8\"\n  },\n  \"scripts\": {\n    \"npmcheckversion\": \"node ./internals/scripts/npmcheckversion.js\",\n    \"preinstall\": \"npm run npmcheckversion\",\n    \"prebuild\": \"npm run build:clean\",\n    \"build\": \"babel src --ignore '**/*.spec.js' --out-dir build --source-maps inline\",\n    \"postbuild\": \"npm run esdoc && ncp ./packages/itslanguage ./build/ && ncp ./esdoc ./build/docs\",\n    \"build:clean\": \"rimraf ./build/\",\n    \"esdoc\": \"esdoc -c esdoc.json\",\n    \"esdoc:clean\": \"rimraf ./esdoc\",\n    \"lint\": \"npm run lint:js\",\n    \"lint:eslint\": \"eslint --ignore-path .gitignore\",\n    \"lint:js\": \"npm run lint:eslint -- . \",\n    \"lint:staged\": \"lint-staged\",\n    \"test\": \"karma start --single-run --color\",\n    \"test:clean\": \"rimraf ./coverage\",\n    \"clean:all\": \"npm run build:clean && npm run esdoc:clean && npm run test:clean\"\n  },\n  \"lint-staged\": {\n    \"*.js\": \"lint:eslint\"\n  },\n  \"pre-commit\": \"lint:staged\",\n  \"author\": \"ITSLanguage (https://www.itslanguage.nl) <support@d-centralize.nl>\",\n  \"contributors\": [\n    \"Mathijs van den Worm <mathijs@d-centralize.nl>\",\n    \"Jogchum Koerts <jogchum.koerts@itslanguage.nl>\",\n    \"Loek Ehren <loek-ehren@hotmail.com>\"\n  ],\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/itslanguage/itslanguage-js.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/itslanguage/itslanguage-js/issues\"\n  },\n  \"homepage\": \"https://github.com/itslanguage/itslanguage-js#readme\",\n  \"dependencies\": {\n    \"autobahn\": \"0.11.2\",\n    \"client-oauth2\": \"4.1.0\",\n    \"debug\": \"3.0.1\",\n    \"event-emitter\": \"0.3.5\",\n    \"pcmjs\": \"0.0.2\",\n    \"uuid\": \"3.1.0\",\n    \"when\": \"3.7.8\"\n  },\n  \"devDependencies\": {\n    \"babel-cli\": \"6.26.0\",\n    \"babel-eslint\": \"8.0.0\",\n    \"babel-plugin-transform-class-properties\": \"6.24.1\",\n    \"babel-polyfill\": \"6.26.0\",\n    \"babel-preset-env\": \"1.6.0\",\n    \"babel-preset-stage-0\": \"6.24.1\",\n    \"babelify\": \"7.3.0\",\n    \"browserify\": \"14.4.0\",\n    \"browserify-istanbul\": \"2.0.0\",\n    \"esdoc\": \"1.0.3\",\n    \"esdoc-ecmascript-proposal-plugin\": \"1.0.0\",\n    \"esdoc-importpath-plugin\": \"1.0.1\",\n    \"esdoc-standard-plugin\": \"1.0.0\",\n    \"eslint\": \"4.7.2\",\n    \"eslint-config-d-centralize\": \"0.4.1\",\n    \"eslint-plugin-async-await\": \"0.0.0\",\n    \"eslint-plugin-jsdoc\": \"3.1.2\",\n    \"isparta\": \"4.0.0\",\n    \"jasmine-ajax\": \"3.3.1\",\n    \"jasmine-core\": \"2.8.0\",\n    \"karma\": \"1.7.1\",\n    \"karma-browserify\": \"5.1.1\",\n    \"karma-chrome-launcher\": \"2.2.0\",\n    \"karma-cli\": \"1.0.1\",\n    \"karma-coverage\": \"1.1.1\",\n    \"karma-jasmine\": \"1.1.0\",\n    \"lint-staged\": \"4.2.1\",\n    \"ncp\": \"2.0.0\",\n    \"pre-commit\": \"1.2.2\",\n    \"rimraf\": \"2.6.2\",\n    \"watchify\": \"3.9.0\"\n  }\n}\n",
    "longname": "/home/travis/build/itslanguage/itslanguage-js/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "globalIndex": false,
    "content": "# ITSLanguage Javascript SDK Manual\n\nThis area will contain the manual entries for the ITSLanguage Javascript SDK.\nThis is currently under construction.\n\n\n## Manual ToC\n\n- [Troubleshooting]\n\n[Troubleshooting]: manual/troubleshooting.html\n",
    "longname": "/home/travis/build/itslanguage/itslanguage-js/manual/index.md",
    "name": "./manual/index.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/travis/build/itslanguage/itslanguage-js/manual/troubleshooting.md",
    "name": "./manual/troubleshooting.md",
    "content": "# Troubleshooting\n\n## Webpack Error: Module not found\n\nThe `ws` module needs to be ignored. In your Webpack configuration, make sure the following is included:\n\n```js\nconst webpack = require('webpack');\n\n\nmodule.exports = {\n  plugins: [\n    webpack.IgnorePlugin(/^ws$/)\n    ...\n  ],\n  ...\n};\n```\n\n\n## Websocket calls are not responding\n\nThe project must be served over SSL.\n\nWhen using `webpack-dev-server`, make sure to add the `--https` flag.\n\nThe browser might show a warning that the website is insecure. Just ignore this warning and continue.\n",
    "static": true,
    "access": "public"
  }
]